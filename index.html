<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Spartizione Detriti OGame - CR (testo) + RR (API)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800&family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root {
    /* OGame-ish palette */
    --bg:#050a10;
    --panel:#0b1320;
    --panel2:#07101b;
    --text:#dbe7ff;
    --muted:#93a6c7;
    --line:rgba(120,160,220,.25);
    --accent:#4da3ff;      /* orange */
    --accent2:#2dd4ff;     /* cyan */
    --good:#39d98a;
    --bad:#ff5c5c;
    --warn:#ff5c5c;
    --font-ui: "Rajdhani", system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial;
    --font-title: "Orbitron", "Rajdhani", system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:var(--font-ui);color:var(--text);background:var(--bg);}
  body::before{
    content:"";
    position:fixed;
    inset:0;
    z-index:-1;
    background:
      radial-gradient(1200px 700px at 15% -10%, rgba(124,240,255,.10), transparent 55%),
      radial-gradient(900px 600px at 110% 10%, rgba(255,179,77,.10), transparent 55%),
      radial-gradient(2px 2px at 20% 30%, rgba(255,255,255,.9), transparent 60%),
      radial-gradient(1px 1px at 40% 60%, rgba(255,255,255,.75), transparent 60%),
      radial-gradient(1px 1px at 70% 20%, rgba(255,255,255,.7), transparent 60%),
      radial-gradient(1px 1px at 85% 80%, rgba(255,255,255,.65), transparent 60%),
      radial-gradient(1px 1px at 10% 85%, rgba(255,255,255,.6), transparent 60%),
      radial-gradient(1px 1px at 95% 45%, rgba(255,255,255,.55), transparent 60%),
      linear-gradient(180deg, rgba(15,25,40,.65), rgba(5,10,16,1));
    filter:saturate(1.05) contrast(1.05);
  }
  header{position:sticky;top:0;z-index:5;background:linear-gradient(180deg, rgba(7,12,18,.92), rgba(7,12,18,.65));backdrop-filter:blur(10px);border-bottom:1px solid var(--line);}
  .wrap{max-width:1100px;margin:0 auto;padding:14px 14px;}
  .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px;}
  .title{display:flex;align-items:center;gap:10px;min-width:0;}
  .actions{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end;}
  .badge{font-size:12px;color:var(--muted);border:1px solid var(--line);padding:4px 8px;border-radius:999px;background:rgba(16,26,46,.6)}
  h1{font-family:var(--font-title);font-size:16px;margin:0;letter-spacing:.8px;text-transform:uppercase}
  .tabs{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
  .tabbtn{border:1px solid var(--line);background:rgba(16,26,46,.6);color:var(--text);padding:8px 10px;border-radius:10px;cursor:pointer}
  .tabbtn.active{border-color:rgba(242,169,0,.8);box-shadow:0 0 0 2px rgba(242,169,0,.18) inset;background:rgba(242,169,0,.07)}
  .grid{display:grid;grid-template-columns:1fr;gap:12px;margin-top:14px}
  @media (min-width: 980px){ .grid{grid-template-columns: 1fr 1fr;} }
  .card{border:1px solid var(--line);background:linear-gradient(180deg, rgba(16,26,46,.8), rgba(14,23,40,.75));border-radius:16px;padding:12px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .card h2{margin:0 0 8px 0;font-size:14px;color:var(--text)}
  textarea,input{width:100%;background:rgba(8,12,20,.65);border:1px solid var(--line);color:var(--text);border-radius:12px;padding:10px;font-size:13px;outline:none}
  textarea{min-height:240px;resize:vertical;line-height:1.25}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .row > *{flex:1}
  button{border:1px solid rgba(88,166,255,.65);background:rgba(88,166,255,.15);color:var(--text);
    padding:9px 12px;border-radius:12px;cursor:pointer;font-weight:600}
  button:hover{background:rgba(88,166,255,.22)}
  .ghost{border-color:var(--line);background:rgba(16,26,46,.5);font-weight:600}
  .ghost:hover{background:rgba(16,26,46,.75)}
  .mini{font-size:12px;color:var(--muted)}
  .pill{display:inline-flex;gap:8px;align-items:center;border:1px solid var(--line);border-radius:999px;padding:6px 10px;background:rgba(16,26,46,.5)}
  .pill input{width:auto}
  .kpi{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px}
  .kpi .box{border:1px solid var(--line);background:rgba(8,12,20,.35);border-radius:12px;padding:10px}
  .kpi .box .v{font-size:14px;font-weight:800}
  .kpi .box .l{font-size:12px;color:var(--muted)}
  table{width:100%;border-collapse:collapse;overflow:hidden;border-radius:12px;border:1px solid var(--line);background:rgba(8,12,20,.35)}
  th,td{padding:8px 8px;border-bottom:1px solid rgba(34,52,85,.6);font-size:12px;text-align:right}
  th{text-align:right;color:var(--muted);font-weight:700;background:rgba(16,26,46,.55)}
  th:first-child, td:first-child{text-align:left}
  tr:last-child td{border-bottom:none}
  .good{color:var(--good)}
  .bad{color:var(--bad)}
  .warn{color:var(--warn)}
  details{border:1px solid var(--line);border-radius:12px;padding:10px;background:rgba(8,12,20,.25)}
  summary{cursor:pointer;color:var(--muted);font-weight:700}
  pre{margin:0;white-space:pre-wrap;word-break:break-word;font-size:12px;color:#cfe0ff}

.ico{width:16px;height:16px;vertical-align:-3px;margin-right:8px;fill:currentColor;opacity:.9}

.advanced{display:none}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1>Spartizione Detriti OGame</h1>
        <span class="badge">CR testo + RR API ‚Ä¢ logica foglio di calcolo</span>
      </div>
      <div class="actions">
        <button class="ghost" id="btnShare" type="button" title="Copia un link con la configurazione"><svg class="ico" viewBox="0 0 24 24" aria-hidden="true"><path d="M18 16a3 3 0 0 0-2.24 1.02L8.91 13.7a3.2 3.2 0 0 0 0-3.4l6.85-3.32A3 3 0 1 0 15 5a2.98 2.98 0 0 0 .07.63L8.22 8.95A3 3 0 1 0 9 12a2.98 2.98 0 0 0-.07-.63l6.85 3.32A3 3 0 1 0 18 16Z"/></svg>Condividi</button>
      </div>
    </div>
    <div class="tabs">
      <button class="tabbtn active" data-tab="cr">CR (testo)</button>
      <button class="tabbtn" data-tab="rr">RR (API via nomoreangel/proxy)</button>
      <button class="tabbtn" data-tab="risultati">Risultati</button>
      <button class="tabbtn" data-tab="log">Log</button>
    </div>
  </div>
</header>

<div class="wrap">
  <div id="tab-cr" class="tab">
    <div class="grid">
      <div class="card">
        <h2>Incolla qui il Combat Report (formato classico IT/EN)</h2>
        
      <div class="grid2" style="margin-bottom:10px">
        <div class="card">
          <div class="cardTitle">CR via API (NoMoreAngel)</div>
          <div class="row">
            <input id="crApiId" class="input" placeholder="es: cr-it-269-... oppure URL NoMoreAngel" />
            <button id="btnLoadCRApi" class="btn">Carica da API</button>
          </div>
          <div class="hint">Usa l'API-ID/CR-KEY. Verr√† convertito tramite NoMoreAngel (engOut) e parsato automaticamente.</div>
        </div>
      </div>

<textarea id="crText" placeholder="Incolla il CR qui..."></textarea>
        <div class="row" style="margin-top:10px">
          <button id="btnParseCR">Analizza CR</button>
          <button id="btnCRDemo" class="ghost">Demo</button>
        </div>
        <div class="mini" style="margin-top:8px">
          Estrae: attaccanti, difensore, coordinate, loot, perdite, DF (float).
        </div>
      </div>

      <div class="card">
        <h2>Opzioni di spartizione</h2>
        <div class="row">
          <label class="pill"><input type="radio" name="mode" value="paritaria" checked> Paritaria</label>
          <label class="pill"><input type="radio" name="mode" value="equa"> Equa (peso flotta in campo)</label>
        </div>
        <div class="kpi" id="kpiCR"></div>

        <details style="margin-top:10px" open>
          <summary>Costi navi / difese (come foglio)</summary>
          <div class="mini" style="margin-top:8px">
            I calcoli usano questi costi base. Se il tuo universo ha costi diversi, dimmelo e li rendiamo editabili.
          </div>
          <div id="costsTable" style="margin-top:8px"></div>
        </details>
      </div>
    </div>
  </div>

  <div id="tab-rr" class="tab" style="display:none">
    <div class="grid">
      <div class="card">
        <h2>Carica RR tramite API ID</h2>
        <div class="row advanced">
          <div style="flex:2">
            <label class="mini">Proxy base URL</label>
            <input id="proxyBase" value="https://ogame-api-proxy.matiasquiroz87.workers.dev/?apiid=" />
          </div>
          <div>
            <label class="mini">Timeout (ms)</label>
            <input id="timeoutMs" value="12000" />
          </div>
        </div>
        <div style="margin-top:8px">
          <label class="mini">Inserisci uno o pi√π RR apiid (uno per riga)</label>
          <textarea id="rrIds" placeholder="rr-it-269-...."></textarea>
        </div>
        <div class="row" style="margin-top:10px">
          <button id="btnLoadRR">Carica RR</button>
          <button id="btnClearRR" class="ghost">Pulisci</button>
        </div>
        <div class="mini" style="margin-top:8px">
          Il tool somma automaticamente le raccolte per giocatore (owner_name) e per risorsa.
        </div>
      </div>

      <div class="card">
        <h2>Raccolte lette</h2>
        <div id="rrTable"></div>
        <details style="margin-top:10px">
          <summary>Dettagli RR (debug)</summary>
          <pre id="rrRaw"></pre>
        </details>
      </div>
    </div>
  </div>

  <div id="tab-risultati" class="tab" style="display:none">
    <div class="card">
      <h2>Risultati (logica del foglio)</h2>
      <div class="mini">
        Formula (per risorsa): <b>quota = perdite_i + (gain_totale √ó peso_i) ‚àí raccolto_i</b><br/>
        dove <b>gain_totale = raccolto_totale ‚àí perdite_totali</b>. La somma delle quote = 0 (trasferimenti tra alleati).
      </div>
      <div style="margin-top:10px" id="resultsTables"></div>

      <details style="margin-top:12px" open>
        <summary>Trasporti finali suggeriti</summary>
        <div class="mini" style="margin-top:8px">
          Elenco di trasferimenti minimi tra chi deve inviare (negativo) e chi deve ricevere (positivo).
        </div>
        <div id="transports"></div>
      </details>
    </div>
  </div>

  <div id="tab-log" class="tab" style="display:none">
    <div class="card">
      <h2>Log</h2>
      <pre id="logBox"></pre>
    </div>
  </div>
</div>

<script>
const COSTS = {"Cargo leggero": [2000, 2000, 0], "Cargo Pesante": [6000, 6000, 0], "Caccia Leggero": [3000, 1000, 0], "Caccia Pesante": [6000, 4000, 0], "Incrociatore": [20000, 7000, 2000], "Nave da battaglia": [45000, 15000, 0], "Bombardiere": [50000, 25000, 15000], "Corazzata": [60000, 50000, 15000], "Incrociatore da Battaglia": [30000, 40000, 15000], "Reaper": [85000, 55000, 20000], "Pathfinder": [8000, 15000, 8000], "Riciclatrice": [10000, 6000, 2000], "Colonizzatrice": [10000, 20000, 10000], "Sonda spia": [0, 1000, 0], "Satellite Solare": [0, 2000, 500], "Crawler": [2000, 2000, 1000], "Morte Nera": [5000000, 4000000, 1000000], "Lanciamissili": [2000, 0, 0], "Laser leggero": [1500, 500, 0], "Laser pesante": [6000, 2000, 0], "Cannone Gauss": [20000, 15000, 2000], "Cannone ionico": [2000, 6000, 0], "Cannone al Plasma": [50000, 50000, 30000], "Cupola scudo piccola": [10000, 10000, 0], "Cupola scudo potenziata": [50000, 50000, 0]};

function fmt(n) {
  if (n === null || n === undefined || isNaN(n)) return '-';
  return Math.round(n).toLocaleString('it-IT');
}
function parseNum(str) {
  if (str === null || str === undefined) return 0;
  const s = String(str).replace(/\./g,'').replace(/,/g,'').replace(/\s+/g,'').trim();
  const n = Number(s);
  return isNaN(n) ? 0 : n;
}
const LOG = [];
function log(msg, level="info") {
  const t = new Date().toLocaleTimeString();
  const line = `[${t}] ${msg}`;
  LOG.push(line);
  const el = document.getElementById('logBox');
  if (el) el.textContent = LOG.join("\n");
}

function setTab(name) {
  document.querySelectorAll('.tabbtn').forEach(b => b.classList.toggle('active', b.dataset.tab===name));
  document.querySelectorAll('.tab').forEach(t => t.style.display = 'none');
  document.getElementById('tab-'+name).style.display = 'block';
}

document.querySelectorAll('.tabbtn').forEach(btn => btn.addEventListener('click', () => setTab(btn.dataset.tab)));

function renderCosts() {
  const rows = Object.entries(COSTS).map(([k,v]) => {
    const [m,c,d]=v;
    const g=m+c+d;
    return `<tr><td>${k}</td><td>${fmt(m)}</td><td>${fmt(c)}</td><td>${fmt(d)}</td><td>${fmt(g)}</td></tr>`;
  }).join('');
  document.getElementById('costsTable').innerHTML = `
    <table>
      <thead><tr><th>Unit√†</th><th>Metallo</th><th>Cristallo</th><th>Deuterio</th><th>Globale</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>`;
}
renderCosts();

// -------- CR PARSER (testo classico) --------
const STATE = {
  cr: null, // parsed CR
  rr: {}  // per player totals: {player: {m,c,d, list:[]}}
};

function parseCRText(text) {
  const out = {
    attackers: {}, // name -> {tag, initial{ship:count}, final{ship:count}}
    defenders: {},
    coords: null,
    loot: {m:0,c:0,d:0},
    df_float: {m:0,c:0,d:0},
    moonChance: null,
    lossesUnits: {att:0, def:0},
  };

  // coords + moon chance
  const coordM = text.match(/\b\[(\d+:\d+:\d+)\]|\b(\d+:\d+:\d+)\b/);
  if (coordM) out.coords = (coordM[1]||coordM[2]||null);

  const moonM = text.match(/possibilit[a√†].*?luna.*?(\d+)%/i);
  if (moonM) out.moonChance = parseNum(moonM[1]);

  // losses units
  const attLost = text.match(/attaccante ha perso un totale di\s*([\d\.,]+)\s*unit/i);
  const defLost = text.match(/difensore ha perso un totale di\s*([\d\.,]+)\s*unit/i);
  if (attLost) out.lossesUnits.att = parseNum(attLost[1]);
  if (defLost) out.lossesUnits.def = parseNum(defLost[1]);

  // loot
  const lootM = text.match(/saccheggia:\s*([\d\.,]+)\s*Metallo,\s*([\d\.,]+)\s*Cristallo\s*e\s*([\d\.,]+)\s*Deuterio/i);
  if (lootM) {
    out.loot.m = parseNum(lootM[1]);
    out.loot.c = parseNum(lootM[2]);
    out.loot.d = parseNum(lootM[3]);
  }

  // debris float line (EN)
  const dfM = text.match(/now float\s*([\d\.,]+)\s*metal,\s*([\d\.,]+)\s*crystal\s*and\s*([\d\.,]+)\s*deuterium/i);
  if (dfM) {
    out.df_float.m = parseNum(dfM[1]);
    out.df_float.c = parseNum(dfM[2]);
    out.df_float.d = parseNum(dfM[3]);
  }

  // Split pre/post battle (robusto: "Dopo la battaglia..." pu√≤ variare)
  let pre = text;
  let post = "";
  const idx = text.search(/\bDopo\s+la\s+battaglia\b/i);
  if (idx >= 0) {
    pre = text.slice(0, idx);
    post = text.slice(idx);
  }

  function parseSideBlocks(blockText, phase) {
    // phase: 'initial' or 'final'
    const lines = blockText.split(/\r?\n/);
    let current = null;
    let currentSide = null;
    for (let i=0;i<lines.length;i++) {
      const line = lines[i].trim();
      if (!line) continue;
      const h = line.match(/^(Attaccante|Difensore)\s+(.+?)\s+\[(.+?)\]\s*$/i);
      if (h) {
        currentSide = h[1].toLowerCase().startsWith('att') ? 'att' : 'def';
        const name = h[2].trim();
        const tag = h[3].trim();
        if (currentSide==='att') {
          if (!out.attackers[name]) out.attackers[name] = {tag, initial: {}, final: {}};
          out.attackers[name].tag = tag;
          current = out.attackers[name];
        } else {
          if (!out.defenders[name]) out.defenders[name] = {tag, initial: {}, final: {}};
          out.defenders[name].tag = tag;
          current = out.defenders[name];
        }
        continue;
      }
      if (!current) continue;
      if (line.startsWith('_')) continue;
      if (line.toLowerCase().includes('distrutto')) continue;

      // ship line: "Caccia Leggero 3.226.909 ( -xxx )"
      const m = line.match(/^(.+?)\s+([\d\.,]+)(?:\s*\(\s*-[\d\.,]+\s*\))?\s*$/);
      if (m) {
        const ship = m[1].trim();
        const count = parseNum(m[2]);
        if (phase==='initial') current.initial[ship] = (current.initial[ship]||0) + count;
        else current.final[ship] = (current.final[ship]||0) + count;
      }
    }
  }

  parseSideBlocks(pre, 'initial');
  if (post) parseSideBlocks(post, 'final');

  // Ensure final exists: if missing post, copy initial
  Object.values(out.attackers).forEach(p => {
    if (!p.final || Object.keys(p.final).length===0) p.final = JSON.parse(JSON.stringify(p.initial));
  });

  return out;
}

function computeFromSheetLogic(cr, rrTotals, mode) {
  const players = Object.keys(cr.attackers);
  const n = players.length || 1;

  // 1) losses per player by ship diffs
  const losses = {};
  const fleetValue = {};
  players.forEach(name => {
    const p = cr.attackers[name];
    losses[name] = {m:0,c:0,d:0, units:0};
    fleetValue[name] = 0;
    // Fleet in campo (initial) value
    for (const [ship, cnt] of Object.entries(p.initial)) {
      const cost = COSTS[ship];
      if (cost) {
        const g = (cost[0]+cost[1]+cost[2]) * cnt;
        fleetValue[name] += g;
      }
    }
    // losses
    const ships = new Set([...Object.keys(p.initial), ...Object.keys(p.final)]);
    ships.forEach(ship => {
      const ini = p.initial[ship] || 0;
      const fin = p.final[ship] || 0;
      const lostCnt = Math.max(0, ini - fin);
      if (lostCnt<=0) return;
      losses[name].units += lostCnt;
      const cost = COSTS[ship];
      if (!cost) return; // ignore unknown ships
      losses[name].m += cost[0] * lostCnt;
      losses[name].c += cost[1] * lostCnt;
      losses[name].d += cost[2] * lostCnt;
    });
  });

  const totLoss = players.reduce((a,nm)=>({
    m:a.m+losses[nm].m, c:a.c+losses[nm].c, d:a.d+losses[nm].d
  }), {m:0,c:0,d:0});

  // 2) total recycled from RR
  const totRec = players.reduce((a,nm)=>{
    const r = rrTotals[nm] || {m:0,c:0,d:0};
    return {m:a.m+r.m, c:a.c+r.c, d:a.d+r.d};
  }, {m:0,c:0,d:0});

  // 3) gain = recycled - losses (per resource)
  const gain = {m: totRec.m - totLoss.m, c: totRec.c - totLoss.c, d: totRec.d - totLoss.d};

  // 4) weights
  const weights = {};
  if (mode === 'paritaria') {
    players.forEach(nm => weights[nm] = 1/n);
  } else {
    const totFleet = players.reduce((s,nm)=> s + (fleetValue[nm]||0), 0) || 1;
    players.forEach(nm => weights[nm] = (fleetValue[nm]||0)/totFleet);
  }

  // 5) quota (= due): losses + gain*weight - collected
  const quota = {};
  players.forEach(nm => {
    const r = rrTotals[nm] || {m:0,c:0,d:0};
    quota[nm] = {
      m: losses[nm].m + gain.m * weights[nm] - r.m,
      c: losses[nm].c + gain.c * weights[nm] - r.c,
      d: losses[nm].d + gain.d * weights[nm] - r.d,
      w: weights[nm],
      fleet: fleetValue[nm],
      lost: losses[nm],
      rec: r
    };
  });

  return {players, losses, fleetValue, weights, totLoss, totRec, gain, quota};
}

function buildTransfers(players, quota, resKey) {
  const recv = [];
  const send = [];
  players.forEach(p => {
    const v = quota[p][resKey];
    if (v > 0.5) recv.push([p, v]);
    else if (v < -0.5) send.push([p, -v]);
  });
  recv.sort((a,b)=>b[1]-a[1]);
  send.sort((a,b)=>b[1]-a[1]);
  const moves = [];
  let i=0,j=0;
  while (i<send.length && j<recv.length) {
    const [sp, sv] = send[i];
    const [rp, rv] = recv[j];
    const x = Math.min(sv, rv);
    if (x>0.5) moves.push({from: sp, to: rp, amount: x});
    send[i][1] -= x;
    recv[j][1] -= x;
    if (send[i][1] <= 0.5) i++;
    if (recv[j][1] <= 0.5) j++;
  }
  return moves;
}

function renderKPI(cr) {
  const el = document.getElementById('kpiCR');
  if (!cr) { el.innerHTML = ""; return; }
  const attackers = Object.keys(cr.attackers).length;
  const defenders = Object.keys(cr.defenders).length;
  el.innerHTML = `
    <div class="box"><div class="v">${cr.coords || '-'}</div><div class="l">Coordinate</div></div>
    <div class="box"><div class="v">${attackers} / ${defenders}</div><div class="l">Attaccanti / Difensori</div></div>
    <div class="box"><div class="v">${cr.moonChance!==null ? (cr.moonChance+'%') : '-'}</div><div class="l">Chance Luna</div></div>
    <div class="box"><div class="v">${fmt(cr.df_float.m)}</div><div class="l">DF float M</div></div>
    <div class="box"><div class="v">${fmt(cr.df_float.c)}</div><div class="l">DF float C</div></div>
    <div class="box"><div class="v">${fmt(cr.df_float.d)}</div><div class="l">DF float D</div></div>
  `;
}

function renderRRTable(rrTotals) {
  const entries = Object.entries(rrTotals);
  if (entries.length===0) {
    document.getElementById('rrTable').innerHTML = '<div class="mini">Nessun RR caricato.</div>';
    return;
  }
  const rows = entries.map(([p,v]) => `
    <tr><td>${p}</td><td>${fmt(v.m)}</td><td>${fmt(v.c)}</td><td>${fmt(v.d)}</td><td>${v.count||0}</td></tr>
  `).join('');
  document.getElementById('rrTable').innerHTML = `
    <table>
      <thead><tr><th>Giocatore</th><th>Metallo</th><th>Cristallo</th><th>Deuterio</th><th>RR</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>`;
}

function renderResults(computed) {
  const {players, totLoss, totRec, gain, quota} = computed;

  const header = `
    <div class="kpi">
      <div class="box"><div class="v">${fmt(totRec.m)} / ${fmt(totRec.c)} / ${fmt(totRec.d)}</div><div class="l">Riciclato totale (M/C/D)</div></div>
      <div class="box"><div class="v">${fmt(totLoss.m)} / ${fmt(totLoss.c)} / ${fmt(totLoss.d)}</div><div class="l">Perdite totali (M/C/D)</div></div>
      <div class="box"><div class="v">${fmt(gain.m)} / ${fmt(gain.c)} / ${fmt(gain.d)}</div><div class="l">Gain da dividere (M/C/D)</div></div>
    </div>`;

  const rows = players.map(p => {
    const q = quota[p];
    const mClass = q.m>=0 ? 'good':'bad';
    const cClass = q.c>=0 ? 'good':'bad';
    const dClass = q.d>=0 ? 'good':'bad';
    return `
      <tr>
        <td>${p} <span class="mini">[${(q.w*100).toFixed(2)}%]</span></td>
        <td>${fmt(q.lost.m)}</td><td>${fmt(q.lost.c)}</td><td>${fmt(q.lost.d)}</td>
        <td>${fmt(q.rec.m)}</td><td>${fmt(q.rec.c)}</td><td>${fmt(q.rec.d)}</td>
        <td class="${mClass}">${fmt(q.m)}</td>
        <td class="${cClass}">${fmt(q.c)}</td>
        <td class="${dClass}">${fmt(q.d)}</td>
      </tr>`;
  }).join('');

  const table = `
    <table style="margin-top:10px">
      <thead>
        <tr>
          <th>Giocatore</th>
          <th>Perse M</th><th>Perse C</th><th>Perse D</th>
          <th>Raccolto M</th><th>Raccolto C</th><th>Raccolto D</th>
          <th>Quota M</th><th>Quota C</th><th>Quota D</th>
        </tr>
      </thead>
      <tbody>${rows}</tbody>
    </table>
    <div class="mini" style="margin-top:8px">
      Quota positiva = deve ricevere. Quota negativa = deve inviare.
    </div>`;

  document.getElementById('resultsTables').innerHTML = header + table;

  // transports
  const mt = buildTransfers(players, quota, 'm');
  const ct = buildTransfers(players, quota, 'c');
  const dt = buildTransfers(players, quota, 'd');

  function renderMoveList(label, moves) {
    if (!moves.length) return `<div class="mini">Nessun trasferimento per ${label} (gi√† bilanciato).</div>`;
    const r = moves.map(m => `<tr><td>${m.from}</td><td>${m.to}</td><td>${fmt(m.amount)}</td></tr>`).join('');
    return `
      <div style="margin-top:10px">
        <div class="mini" style="margin:6px 0"><b>${label}</b></div>
        <table>
          <thead><tr><th>Da</th><th>A</th><th>Quantit√†</th></tr></thead>
          <tbody>${r}</tbody>
        </table>
      </div>`;
  }
  document.getElementById('transports').innerHTML =
    renderMoveList('Metallo', mt) + renderMoveList('Cristallo', ct) + renderMoveList('Deuterio', dt);
}

function recomputeAndRender() {
  if (!STATE.cr) {
    log("‚ö†Ô∏è Nessun CR caricato.");
    return;
  }
  const mode = document.querySelector('input[name="mode"]:checked')?.value || 'paritaria';
  const rrTotals = STATE.rr || {};
  const computed = computeFromSheetLogic(STATE.cr, rrTotals, mode);
  renderResults(computed);
}

document.querySelectorAll('input[name="mode"]').forEach(r => r.addEventListener('change', () => {
  log("Modalit√†: " + document.querySelector('input[name="mode"]:checked').value);
  recomputeAndRender();
}));

document.getElementById('btnParseCR').addEventListener('click', () => {
  try {
    const text = document.getElementById('crText').value || '';
    const cr = parseCRText(text);
    STATE.cr = cr;
    renderKPI(cr);
    log(`‚úÖ CR caricato. Attaccanti: ${Object.keys(cr.attackers).length} ‚Ä¢ Difensori: ${Object.keys(cr.defenders).length} ‚Ä¢ Coord: ${cr.coords||'-'}`);
    recomputeAndRender();
    setTab('risultati');
  } catch (e) {
    log("‚ùå Errore parsing CR: " + (e?.message || e));
    console.error(e);
    setTab('log');
  }
});

document.getElementById('btnCRDemo').addEventListener('click', () => {
  const demo = `Il 28-01-2026 --:--:--, le seguenti flotte si scontrano in combattimento:

Attaccante Abubu [U E]
________________________________________________
Cargo Pesante 1
Caccia Leggero 3.226.909
Caccia Pesante 177.230
Incrociatore 557.550
Nave da battaglia 151.773
Corazzata 89.802
Incrociatore da Battaglia 462.085
Reaper 129.700
Pathfinder 96.320
_________________________________________

Difensore Bartok [SoV]
________________________________________________
Cargo leggero 515.205
Cargo Pesante 96.004
Caccia Leggero 487.861
_________________________________________

Dopo la battaglia...

Attaccante Abubu [U E]
________________________________________________
Cargo Pesante 1 ( -0 )
Caccia Leggero 2.961.733 ( -265.176 )
Caccia Pesante 167.384 ( -9.846 )
Incrociatore 544.263 ( -13.287 )
Nave da battaglia 150.566 ( -1.207 )
Corazzata 89.649 ( -153 )
Incrociatore da Battaglia 459.127 ( -2.958 )
Reaper 129.496 ( -204 )
Pathfinder 93.760 ( -2.560 )
_________________________________________

Difensore Bartok [SoV]
________________________________________________
Distrutto!
_________________________________________

L'attaccante saccheggia:
471.166.157 Metallo, 125.714.491 Cristallo e 21.863.628 Deuterio

L'attaccante ha perso un totale di 6.842.469.000 unit√†.
Il difensore ha perso un totale di 66.020.471.000 unit√†.
At these space coordinates now float 8.451.301.052 metal, 6.135.502.953 crystal and 1.725.266.027 deuterium.
La possibilit√† che si formi una luna dai detriti era del 22%.`;
  document.getElementById('crText').value = demo;
  log("Demo CR inserito.");
});

// -------- RR LOADER (API) --------
function abortableFetch(url, timeoutMs) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeoutMs);
  return fetch(url, {signal: controller.signal}).finally(() => clearTimeout(id));
}

function extractPre(html) {
  const m = html.match(/<pre[^>]*>([\s\S]*?)<\/pre>/i);
  if (!m) return null;
  const txt = m[1]
    .replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&amp;/g,'&')
    .replace(/&#039;/g,"'").replace(/&quot;/g,'"');
  return txt;
}

function parseRRFromPre(pre) {
  // regex extraction from stdClass print_r
  const owner = (pre.match(/\[owner_name\]\s*=>\s*([^\r\n]+)/) || [])[1];
  if (!owner) return null;
  const m = parseNum((pre.match(/\[metal_retrieved\]\s*=>\s*([\d\.,]+)/) || [])[1]);
  const c = parseNum((pre.match(/\[crystal_retrieved\]\s*=>\s*([\d\.,]+)/) || [])[1]);
  const d = parseNum((pre.match(/\[deuterium_retrieved\]\s*=>\s*([\d\.,]+)/) || [])[1]);
  const coords = (pre.match(/\[coordinates\]\s*=>\s*([^\r\n]+)/) || [])[1] || '';
  const rrid = (pre.match(/\[rr_id\]\s*=>\s*([^\r\n]+)/) || [])[1] || '';
  return {owner: owner.trim(), m, c, d, coords: coords.trim(), rrid: rrid.trim()};
}


// ----------------- CR via NoMoreAngel (API-Reader) -----------------
function decodeHtmlEntities(html){
  if (html == null) return '';
  const txt = document.createElement('textarea');
  txt.innerHTML = html;
  return txt.value;
}
function extractMarkdownContent(raw){
  // r.jina.ai spesso restituisce una pagina "Markdown Content: ...".
  const m = raw.match(/Markdown Content:\s*([\s\S]*)$/i);
  if (m) return m[1].trim();
  return raw;
}
async function fetchTextWithFallback(url, timeoutMs=12000){
  // 1) direct
  try{
    const res = await abortableFetch(url, timeoutMs);
    if(!res.ok) throw new Error('HTTP '+res.status);
    return await res.text();
  }catch(e1){
    // 2) Jina AI text proxy (bypasses CORS on many sites)
    const jinaUrl = "https://r.jina.ai/https://" + url.replace(/^https:\/\//,'');
    const res = await abortableFetch(jinaUrl, timeoutMs);
    if(!res.ok) throw new Error('HTTP '+res.status);
    return await res.text();
  }
}
function parseNmaNumberList(s){
  const arr = (s.match(/[0-9][0-9\.]*/g) || []).map(parseNum);
  return arr;
}
const EN2IT = {
  "Small Cargo":"Cargo leggero",
  "Large Cargo":"Cargo Pesante",
  "Light Fighter":"Caccia Leggero",
  "Heavy Fighter":"Caccia Pesante",
  "Cruiser":"Incrociatore",
  "Battleship":"Nave da battaglia",
  "Colony Ship":"Colonizzatrice",
  "Recycler":"Riciclatrice",
  "Espionage Probe":"Sonda spia",
  "Bomber":"Bombardiere",
  "Solar Satellite":"Satellite Solare",
  "Destroyer":"Corazzata",
  "Deathstar":"Morte Nera",
  "Battlecruiser":"Incrociatore da Battaglia",
  "Crawler":"Crawler",
  "Reaper":"Reaper",
  "Pathfinder":"Pathfinder",
  "Rocket Launcher":"Lanciamissili",
  "Light Laser":"Laser leggero",
  "Heavy Laser":"Laser pesante",
  "Gauss Cannon":"Cannone Gauss",
  "Ion Cannon":"Cannone ionico",
  "Plasma Turret":"Cannone al Plasma",
  "Small Shield Dome":"Cupola scudo piccola",
  "Large Shield Dome":"Cupola scudo potenziata"
};
const EN_SHIPS = Object.keys(EN2IT).sort((a,b)=>b.length-a.length);

function parseTypesFromSegment(seg){
  const found = [];
  const lower = seg;
  for(const name of EN_SHIPS){
    const re = new RegExp('\\b' + name.replace(/[-\/\\^$*+?.()|[\]{}]/g,'\\$&') + '\\b','g');
    let m;
    while((m=re.exec(lower))){
      found.push({name, idx:m.index});
    }
  }
  found.sort((a,b)=>a.idx-b.idx);
  // dedupe keeping order (same ship can appear once)
  const out = [];
  const seen = new Set();
  for(const f of found){
    if(seen.has(f.name)) continue;
    seen.add(f.name);
    out.push(f.name);
  }
  return out;
}

function addFleetCounts(target, player, types, counts){
  if(!target[player]) target[player] = {};
  for(let i=0;i<types.length;i++){
    const en = types[i];
    const it = EN2IT[en] || en;
    const val = counts[i] ?? 0;
    target[player][it] = (target[player][it]||0) + val;
  }
}

function parseNmaConvertedToState(md){
  const out = { date:null, time:null, coords:null, loot:{m:0,c:0,d:0}, debris:{m:0,c:0,d:0}, attackers:{}, defenders:{} };

  // General Info
  out.date = (md.match(/\bDate:\s*([0-9\-]+)/i)||[])[1] || null;
  out.time = (md.match(/\bTime:\s*([0-9:]+)/i)||[])[1] || null;
  out.coords = (md.match(/Combat coordinates:\s*([0-9:]+)/i)||[])[1] || null;
  out.loot.m = parseNum((md.match(/Metal loot:\s*([0-9\.,]+)/i)||[])[1]);
  out.loot.c = parseNum((md.match(/Crystal loot:\s*([0-9\.,]+)/i)||[])[1]);
  out.loot.d = parseNum((md.match(/Deuterium loot:\s*([0-9\.,]+)/i)||[])[1]);
  out.debris.m = parseNum((md.match(/Metal to debrisfield:\s*([0-9\.,]+)/i)||[])[1]);
  out.debris.c = parseNum((md.match(/Crystal to debrisfield:\s*([0-9\.,]+)/i)||[])[1]);
  // Deuterio DF non sempre presente nel convertito: lo lasciamo a 0.

  // Initial segment
  const initialSeg = (md.match(/####\s*Initial:\s*([\s\S]*?)####\s*Round\s*1/i)||[])[1] || '';
  // Attackers initial
  const reAInit = /Attacker\s*\[[^\]]+\]\s*([^\[]+?)\s*\[[^\]]*\][\s\S]*?\bType\s+([\s\S]*?)\s+\bCount\s+([\s\S]*?)\s+\bWeapon\b/gi;
  let m;
  while((m=reAInit.exec(initialSeg))){
    const player = (m[1]||'').trim();
    const types = parseTypesFromSegment(m[2]||'');
    const counts = parseNmaNumberList(m[3]||'');
    if(player && types.length) addFleetCounts(out.attackers, player, types, counts);
  }
  const reDInit = /Defender\s*\[[^\]]+\]\s*([^\[]+?)\s*\[[^\]]*\][\s\S]*?\bType\s+([\s\S]*?)\s+\bCount\s+([\s\S]*?)\s+\bWeapon\b/gi;
  while((m=reDInit.exec(initialSeg))){
    const player = (m[1]||'').trim();
    const types = parseTypesFromSegment(m[2]||'');
    const counts = parseNmaNumberList(m[3]||'');
    if(player && types.length) addFleetCounts(out.defenders, player, types, counts);
  }

  // last round segment (for remaining)
  const rounds = Array.from(md.matchAll(/####\s*Round\s*(\d+)/gi)).map(x=>parseInt(x[1],10)).filter(n=>!isNaN(n));
  const lastRound = rounds.length ? Math.max(...rounds) : 0;
  let lastSeg = '';
  if(lastRound){
    const reLast = new RegExp('####\\s*Round\\s*'+lastRound+'\\s*([\\s\\S]*)$','i');
    lastSeg = (md.match(reLast)||[])[1] || '';
  }
  const finalA = {};
  const finalD = {};

  const reARound = /Attacker\s+([A-Za-z0-9_\- ]+?)\s+([\s\S]*?)\s+\bCount\s+([\s\S]*?)\s+\bLost\b[\s\S]*?(?=\bAttacker\s+[A-Za-z0-9_\- ]+\b|\bDefender\s+[A-Za-z0-9_\- ]+\b|$)/g;
  while((m=reARound.exec(lastSeg))){
    const player = (m[1]||'').trim();
    const types = parseTypesFromSegment(m[2]||'');
    const counts = parseNmaNumberList(m[3]||'');
    if(player && types.length) addFleetCounts(finalA, player, types, counts);
  }
  const reDRound = /Defender\s+([A-Za-z0-9_\- ]+?)\s+([\s\S]*?)\s+\bCount\s+([\s\S]*?)\s+\bLost\b[\s\S]*?(?=\bAttacker\s+[A-Za-z0-9_\- ]+\b|\bDefender\s+[A-Za-z0-9_\- ]+\b|$)/g;
  while((m=reDRound.exec(lastSeg))){
    const player = (m[1]||'').trim();
    const types = parseTypesFromSegment(m[2]||'');
    const counts = parseNmaNumberList(m[3]||'');
    if(player && types.length) addFleetCounts(finalD, player, types, counts);
  }

  // Build a pseudo-CR object compatible with existing pipeline
  const cr = { coords: out.coords, debris: out.debris, loot: out.loot, attackers:{}, defenders:{} };

  // attackers initial + final => losses by ship
  for(const [p, shipsInit] of Object.entries(out.attackers)){
    const shipsFinal = finalA[p] || {};
    const ships = {};
    for(const [ship, initCount] of Object.entries(shipsInit)){
      const fin = shipsFinal[ship] ?? 0;
      ships[ship] = initCount; // keep initial for now; losses computed later by existing code using initial+after
    }
    cr.attackers[p] = { initial: shipsInit, final: shipsFinal };
  }
  for(const [p, shipsInit] of Object.entries(out.defenders)){
    const shipsFinal = finalD[p] || {};
    cr.defenders[p] = { initial: shipsInit, final: shipsFinal };
  }
  // Store some generic fields used by UI (if any)
  cr.date = out.date;
  cr.time = out.time;
  cr._fromNMA = true;
  return cr;
}

function nmaCrToItalianText(cr){
  // Convert into the same "CR (testo)" format our parseCRText expects.
  const lines = [];
  lines.push(`Il ${cr.date||'--'} --:--:--, le seguenti flotte si scontrano in combattimento:\n`);
  for(const [p, obj] of Object.entries(cr.attackers)){
    lines.push(`\nAttaccante ${p}\n________________________________________________\n`);
    const ships = obj.initial || {};
    for(const [ship, count] of Object.entries(ships)){
      if(count) lines.push(`${ship} ${fmt(count)}`.replace(/\./g,'.'));
    }
    lines.push('_________________________________________\n');
  }
  for(const [p, obj] of Object.entries(cr.defenders)){
    lines.push(`\nDifensore ${p}\n________________________________________________\n`);
    const ships = obj.initial || {};
    for(const [ship, count] of Object.entries(ships)){
      if(count) lines.push(`${ship} ${fmt(count)}`.replace(/\./g,'.'));
    }
    lines.push('_________________________________________\n');
  }
  lines.push('\nDopo la battaglia...\n');
  for(const [p, obj] of Object.entries(cr.attackers)){
    lines.push(`\nAttaccante ${p}\n________________________________________________\n`);
    const ships = obj.final || {};
    for(const [ship, count] of Object.entries(ships)){
      // qui non abbiamo ( -lost ), ma parseCRText accetta anche solo valore? Nel tuo parser serve "( - )".
      // Mettiamo formato semplice: "Ship X ( -0 )" per compatibilit√†.
      lines.push(`${ship} ${fmt(count)} ( -0 )`.replace(/\./g,'.'));
    }
    lines.push('_________________________________________\n');
  }
  for(const [p, obj] of Object.entries(cr.defenders)){
    lines.push(`\nDifensore ${p}\n________________________________________________\n`);
    const ships = obj.final || {};
    if(Object.keys(ships).length===0) lines.push('Distrutto!');
    else {
      for(const [ship, count] of Object.entries(ships)){
        lines.push(`${ship} ${fmt(count)} ( -0 )`.replace(/\./g,'.'));
      }
    }
    lines.push('_________________________________________\n');
  }
  // loot / DF
  lines.push(`\nL'attaccante saccheggia:\n${fmt(cr.loot?.m||0)} Metallo, ${fmt(cr.loot?.c||0)} Cristallo e ${fmt(cr.loot?.d||0)} Deuterio\n`);
  lines.push(`At these space coordinates now float ${fmt(cr.debris?.m||0)} metal, ${fmt(cr.debris?.c||0)} crystal and ${fmt(cr.debris?.d||0)} deuterium.\n`);
  return lines.join('\n');
}

document.getElementById('btnLoadCRApi')?.addEventListener('click', async () => {
  const apiId = (document.getElementById('crApiId').value || '').trim();
  if(!apiId){ log("‚ö†Ô∏è Inserisci un API ID CR."); return; }
  const timeoutMs = parseNum(document.getElementById('timeoutMs')?.value) || 12000;
  const url = apiId.startsWith('http')
    ? apiId
    : `https://nomoreangel.de/api-reader/?apiid=${encodeURIComponent(apiId)}&engOut=on`;
  log(`CR API: richiesta NoMoreAngel per ${apiId}...`);
  try{
    const raw = await fetchTextWithFallback(url, timeoutMs);
    const md = extractMarkdownContent(raw);
    const crNma = parseNmaConvertedToState(md);
    const crText = nmaCrToItalianText(crNma);
    document.getElementById('crText').value = crText;
    log("‚úÖ CR convertito (NoMoreAngel) incollato nel box. Ora analizzo...");
    // usa parser esistente
    const crParsed = parseCRText(crText);
    STATE.cr = crParsed;
    renderKPI(crParsed);
    recomputeAndRender();
    setTab('risultati');
    log(`‚úÖ CR API OK. Attaccanti: ${Object.keys(crParsed.attackers).length} ‚Ä¢ Difensori: ${Object.keys(crParsed.defenders).length}`);
  }catch(e){
    log("‚ùå Errore CR API: " + (e?.message||e));
    setTab('log');
    console.error(e);
  }
});


document.getElementById('btnLoadRR').addEventListener('click', async () => {
  const base = (document.getElementById('proxyBase').value || '').trim();
  const timeoutMs = parseNum(document.getElementById('timeoutMs').value) || 12000;
  const ids = (document.getElementById('rrIds').value || '').split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  if (!ids.length) {
    log("‚ö†Ô∏è Nessun RR apiid inserito.");
    return;
  }
  log(`Carico ${ids.length} RR...`);
  const rawLog = [];
  for (const id of ids) {
    const url = base + encodeURIComponent(id);
    try {
      const res = await abortableFetch(url, timeoutMs);
      const text = await res.text();
      rawLog.push(`--- ${id} status=${res.status} ok=${res.ok} url=${url} ---\n` + text.slice(0,1200));
      const pre = extractPre(text) || text;
      const parsed = parseRRFromPre(pre);
      if (!parsed) {
        log(`‚ùå RR non parsato: ${id} (owner_name non trovato)`);
        continue;
      }
      const p = parsed.owner;
      if (!STATE.rr[p]) STATE.rr[p] = {m:0,c:0,d:0,count:0, list:[]};
      STATE.rr[p].m += parsed.m;
      STATE.rr[p].c += parsed.c;
      STATE.rr[p].d += parsed.d;
      STATE.rr[p].count += 1;
      STATE.rr[p].list.push(parsed);
      log(`‚úÖ RR: ${p} +${fmt(parsed.m)}M +${fmt(parsed.c)}C +${fmt(parsed.d)}D (${parsed.coords})`);
    } catch (e) {
      log(`‚ùå Errore fetch RR ${id}: ${e?.message || e}`);
    }
  }
  document.getElementById('rrRaw').textContent = rawLog.join("\n\n");
  renderRRTable(STATE.rr);
  recomputeAndRender();
  setTab('risultati');
});

document.getElementById('btnClearRR').addEventListener('click', () => {
  STATE.rr = {};
  document.getElementById('rrRaw').textContent = '';
  renderRRTable(STATE.rr);
  recomputeAndRender();
  log("RR puliti.");
});

// ----------------- Condivisione (link con stato) -----------------
function encodeShareState(obj){
  // base64(url-safe) di JSON UTF-8
  const json = JSON.stringify(obj);
  const b64 = btoa(unescape(encodeURIComponent(json)))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/g, '');
  return b64;
}
function decodeShareState(b64){
  const pad = '==='.slice((b64.length + 3) % 4);
  const s = (b64 + pad).replace(/-/g, '+').replace(/_/g, '/');
  const json = decodeURIComponent(escape(atob(s)));
  return JSON.parse(json);
}
function collectShareState(){
  return {
    v: 1,
    crText: (document.getElementById('crText').value || '').trim(),
    proxyBase: (document.getElementById('proxyBase').value || '').trim(),
    timeoutMs: parseNum(document.getElementById('timeoutMs').value) || 12000,
    rrIds: (document.getElementById('rrIds').value || '').trim(),
    // per comodit√†: se hai gi√† caricato RR, includiamo anche il totale per player
    rrTotals: STATE.rr || {},
  };
}
function applyShareState(st){
  if (!st || typeof st !== 'object') return;
  if (typeof st.proxyBase === 'string' && st.proxyBase.trim()) document.getElementById('proxyBase').value = st.proxyBase.trim();
  if (st.timeoutMs) document.getElementById('timeoutMs').value = String(st.timeoutMs);
  if (typeof st.rrIds === 'string') document.getElementById('rrIds').value = st.rrIds;
  if (typeof st.crText === 'string') document.getElementById('crText').value = st.crText;

  // Se abbiamo gi√† totals, possiamo renderizzarli subito senza rifetch.
  if (st.rrTotals && typeof st.rrTotals === 'object' && Object.keys(st.rrTotals).length){
    STATE.rr = st.rrTotals;
    renderRRTable(STATE.rr);
  }
  // Analizza CR (se presente)
  if ((document.getElementById('crText').value || '').trim()) {
    try { parseCRText(); } catch(e){ log('Errore analisi CR da link: ' + (e?.message||e)); }
  }
  recomputeAndRender();
}
function shareLink(){
  const st = collectShareState();
  const token = encodeShareState(st);
  const url = `${location.origin}${location.pathname}#s=${token}`;
  return url;
}
async function doShare(){
  const url = shareLink();
  const title = 'Spartizione Detriti OGame';
  const text = 'Link con CR/RR precompilati';
  try {
    if (navigator.share) {
      await navigator.share({title, text, url});
      log('‚úÖ Link condiviso.');
      return;
    }
  } catch (e) {
    // se l'utente annulla, non √® un errore grave
  }
  try {
    await navigator.clipboard.writeText(url);
    log('‚úÖ Link copiato negli appunti.');
  } catch (e) {
    // fallback
    prompt('Copia questo link:', url);
    log('‚ÑπÔ∏è Link mostrato in prompt (clipboard non disponibile).');
  }
}

document.getElementById('btnShare').addEventListener('click', () => {
  doShare();
});

// Carica stato da hash (se presente)
(() => {
  const m = (location.hash || '').match(/#s=([A-Za-z0-9\-_]+)/);
  if (!m) return;
  try {
    const st = decodeShareState(m[1]);
    applyShareState(st);
    setTab('cr');
    log('üîó Stato caricato dal link.');
  } catch (e) {
    log('‚ö†Ô∏è Hash di condivisione non valido: ' + (e?.message || e));
  }
})();

// Initial
log("Pronto. 1) Incolla CR (testo) e Analizza. 2) Carica RR (API) per sommare raccolte. 3) Vedi Risultati.");
</script>
</body>
</html>
