<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Spartizione Detriti OGame</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800&family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">

<style>
:root{
  --bg:#050a10;
  --panel:#0b1320;
  --text:#dbe7ff;
  --muted:#93a6c7;
  --line:rgba(120,160,220,.25);
  --accent:#4da3ff;
  --good:#39d98a;
  --bad:#ff5c5c;
  --font-ui:"Rajdhani",system-ui;
  --font-title:"Orbitron","Rajdhani",system-ui;
}
*{box-sizing:border-box}
body{
  margin:0;
  font-family:var(--font-ui);
  background:var(--bg);
  color:var(--text);
}
header{
  position:sticky;top:0;z-index:10;
  background:linear-gradient(180deg,#0a1220,#050a10);
  border-bottom:1px solid var(--line);
}
.wrap{max-width:1100px;margin:0 auto;padding:14px}
.topbar{display:flex;justify-content:space-between;align-items:center}
h1{
  font-family:var(--font-title);
  font-size:18px;
  letter-spacing:.8px;
  margin:0;
}
button{
  border:1px solid var(--line);
  background:rgba(88,166,255,.15);
  color:var(--text);
  padding:10px 14px;
  border-radius:12px;
  cursor:pointer;
  font-weight:600;
}
button:hover{background:rgba(88,166,255,.25)}
.card{
  background:linear-gradient(180deg,rgba(16,26,46,.85),rgba(14,23,40,.8));
  border:1px solid var(--line);
  border-radius:16px;
  padding:14px;
}
.grid{
  display:grid;
  grid-template-columns:1fr;
  gap:14px;
  margin-top:14px;
}
@media(min-width:900px){
  .grid{grid-template-columns:1fr 1fr}
}
textarea,input{
  width:100%;
  background:rgba(8,12,20,.7);
  border:1px solid var(--line);
  color:var(--text);
  border-radius:12px;
  padding:10px;
  font-size:13px;
}
textarea{min-height:260px}
.mini{font-size:12px;color:var(--muted)}
.kpi{
  display:grid;
  grid-template-columns:repeat(3,1fr);
  gap:8px;
  margin-top:10px;
}
.kpi .box{
  background:rgba(8,12,20,.5);
  border:1px solid var(--line);
  border-radius:12px;
  padding:10px;
}
.kpi .v{font-size:15px;font-weight:800}
.kpi .l{font-size:12px;color:var(--muted)}
pre{
  margin:0;
  font-size:12px;
  white-space:pre-wrap;
}
.hidden{display:none}
</style>
</head>

<body>
<header>
  <div class="wrap topbar">
    <h1>SPARTIZIONE DETRITI OGAME</h1>
    <button id="btnShare">Condividi</button>
  </div>
</header>

<div class="wrap">

<!-- STAGE CR -->
<div id="stageCR" class="grid">
  <div class="card">
    <h2 style="margin:0 0 10px 0">CR</h2>

    <div style="display:flex;gap:8px;margin-bottom:10px">
      <input id="crApiId" placeholder="API ID CR (cr-it-269-... oppure link)">
      <button id="btnLoadCRApi" type="button">Carica CR da API</button>
    </div>

    <textarea id="crText" placeholder="Incolla qui il Combat Report..."></textarea>

    <div style="margin-top:10px">
      <button id="btnParseCR" type="button">Analizza CR</button>
    </div>

    <div class="mini" style="margin-top:8px">
      Dopo l‚Äôanalisi puoi inserire gli RR e vedere la spartizione.
    </div>
  </div>

  <div class="card">
    <h2 style="margin:0 0 10px 0">LOG</h2>
    <pre id="logBox"></pre>
  </div>
</div>

<!-- STAGE RISULTATI -->
<div id="stageResults" class="hidden">

  <div class="grid">
    <div class="card">
      <h2 style="margin:0 0 10px 0">RR & Spartizione</h2>

      <textarea id="rrIds" placeholder="Inserisci RR apiid (uno per riga)"></textarea>

      <div style="display:flex;gap:8px;margin-top:10px">
        <button id="btnLoadRR" type="button">Carica RR</button>
        <button id="btnClearRR" type="button">Pulisci</button>
      </div>

      <div style="margin-top:10px">
        <label><input type="radio" name="mode" value="paritaria" checked> Paritaria</label>
        <label style="margin-left:12px"><input type="radio" name="mode" value="equa"> Equa (peso flotta)</label>
      </div>

      <div id="kpiCR" class="kpi"></div>
    </div>

    <div class="card">
      <h2 style="margin:0 0 10px 0">Raccolte RR</h2>
      <div id="rrTable" class="mini">Nessun RR caricato.</div>
    </div>
  </div>

  <div class="card" style="margin-top:14px">
    <h2 style="margin:0 0 10px 0">Risultati Spartizione</h2>
    <div id="resultsTables" class="mini">Carica RR per calcolare.</div>

    <div style="margin-top:14px">
      <div class="mini"><b>Trasporti suggeriti</b></div>
      <div id="transports" class="mini">Carica RR per generare i trasferimenti.</div>
    </div>
  </div>

</div>

</div>

<script>
/* =========================
   MINIMAL + FIX CR API LOAD
   - Ripristina: fetch con fallback (CORS), parser NoMoreAngel -> CR classico
   - Mantiene UI minimal (niente demo, niente "round finale viewer")
   ========================= */

/* ---------- helpers ---------- */
const logBox = document.getElementById('logBox');
function log(t){ logBox.textContent += (t + "\n"); }

function parseNum(str){
  if (str === null || str === undefined) return 0;
  const s = String(str).replace(/\./g,'').replace(/,/g,'').replace(/\s+/g,'').trim();
  const n = Number(s);
  return isNaN(n) ? 0 : n;
}
function fmt(n){
  if (n === null || n === undefined || isNaN(n)) return '0';
  return Math.round(n).toLocaleString('it-IT');
}

/* ---------- CR: fetch with fallback (direct -> jina) ---------- */
async function fetchTextWithFallback(url, timeoutMs = 15000){
  // 1) direct
  try{
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    const res = await fetch(url, { signal: ctrl.signal });
    clearTimeout(t);
    if(!res.ok) throw new Error("HTTP " + res.status);
    return await res.text();
  }catch(e1){
    // 2) jina proxy (bypasses CORS in many cases)
    const clean = String(url).replace(/^https?:\/\//i,'');
    const jinaUrl = "https://r.jina.ai/http://" + clean;

    const ctrl2 = new AbortController();
    const t2 = setTimeout(() => ctrl2.abort(), timeoutMs);
    const res2 = await fetch(jinaUrl, { signal: ctrl2.signal });
    clearTimeout(t2);
    if(!res2.ok) throw new Error("HTTP " + res2.status);
    return await res2.text();
  }
}

/* ---------- NoMoreAngel api-reader -> CR classico ---------- */
const shipNameMapEN2IT = {
  "Small Cargo":"Cargo leggero",
  "Large Cargo":"Cargo Pesante",
  "Light Fighter":"Caccia Leggero",
  "Heavy Fighter":"Caccia Pesante",
  "Cruiser":"Incrociatore",
  "Battleship":"Nave da battaglia",
  "Colony Ship":"Colonizzatrice",
  "Recycler":"Riciclatrice",
  "Espionage Probe":"Sonda spia",
  "Bomber":"Bombardiere",
  "Solar Satellite":"Satellite Solare",
  "Destroyer":"Corazzata",
  "Deathstar":"Morte Nera",
  "Battlecruiser":"Incrociatore da Battaglia",
  "Crawler":"Crawler",
  "Reaper":"Reaper",
  "Pathfinder":"Pathfinder",
  "Rocket Launcher":"Lanciamissili",
  "Light Laser":"Laser leggero",
  "Heavy Laser":"Laser pesante",
  "Gauss Cannon":"Cannone Gauss",
  "Ion Cannon":"Cannone ionico",
  "Plasma Turret":"Cannone al Plasma",
  "Small Shield Dome":"Cupola scudo piccola",
  "Large Shield Dome":"Cupola scudo potenziata"
};
const knownShipNamesEN = Object.keys(shipNameMapEN2IT).sort((a,b)=>b.length-a.length);

function mapShipToIT(name){
  const n = (name || '').trim();
  return shipNameMapEN2IT[n] || n;
}
function matchKnownShipsEN(text){
  const out = [];
  const src = text || '';
  const esc = knownShipNamesEN.map(s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
  const re = new RegExp(`\\b(${esc.join('|')})\\b`, 'g');
  let m;
  while((m = re.exec(src)) !== null) out.push(m[1]);
  return out;
}
function extractNums(text){
  return (String(text||'').match(/[\d\.,]+/g) || []);
}

function parseNmaApiReaderToClassic(raw){
  if(!raw) return null;

  let t = raw;
  const mdIdx = t.indexOf('Markdown Content:');
  if(mdIdx >= 0) t = t.slice(mdIdx + 'Markdown Content:'.length);

  const date = ((t.match(/Date:\s*([0-9]{2}-[0-9]{2}-[0-9]{4})/i) || [])[1]) || '--:--:--';
  const time = ((t.match(/Time:\s*([0-9]{2}:[0-9]{2}:[0-9]{2})/i) || [])[1]) || '--:--:--';

  const idxInit = t.search(/####\s*Initial\s*:/i);
  if(idxInit < 0) return null;

  // max 6 turns
  let maxRound = 0;
  const roundRe = /####\s*Round\s+(\d+)/gi;
  let rm;
  while((rm = roundRe.exec(t)) !== null){
    const r = parseInt(rm[1],10);
    if(!isNaN(r)) maxRound = Math.min(6, Math.max(maxRound, r));
  }
  if(maxRound < 1) maxRound = 1;

  const idxR1 = t.search(/####\s*Round\s+1/i);
  const initEnd = idxR1 >= 0 ? idxR1 : t.length;
  const initTxt = t.slice(idxInit, initEnd);

  const initial = { attackers:{}, defenders:{} };
  const nameToTag = {};

  const initEntityRe = /(Attacker|Defender)\s+\[[0-9:]+\]\s+([^\[]+?)\s+\[([^\]]+)\][\s\S]*?Type\s+([\s\S]*?)\s+Count\s+([\s\S]*?)(?=Weapon\s*:|Weapon\s|Shield\s*:|Shield\s|Armor\s*:|Armor\s|Attacker\s+\[|Defender\s+\[|$)/gi;
  let em;
  while((em = initEntityRe.exec(initTxt)) !== null){
    const side = em[1].toLowerCase();
    const name = (em[2]||'').trim();
    const tag  = (em[3]||'').trim();
    const key  = `${name} [${tag}]`;
    const typePart  = em[4] || '';
    const countPart = em[5] || '';
    const shipsEN = matchKnownShipsEN(typePart);
    const nums = extractNums(countPart).map(parseNum);
    if(!shipsEN.length || !nums.length) continue;

    const target = side === 'attacker' ? initial.attackers : initial.defenders;
    if(!target[key]) target[key] = {};
    nameToTag[name] = tag;

    for(let i=0;i<Math.min(shipsEN.length, nums.length);i++){
      const itName = mapShipToIT(shipsEN[i]);
      target[key][itName] = (target[key][itName]||0) + nums[i];
    }
  }

  const idxRound = t.search(new RegExp(`####\\s*Round\\s+${maxRound}\\b`, 'i'));
  if(idxRound < 0) return null;
  const afterRound = t.slice(idxRound);
  const nextAfter = afterRound.slice(12).search(/####\s*Round\s+\d+/i);
  const endRound = nextAfter >= 0 ? (12 + nextAfter) : afterRound.length;
  const roundTxt = afterRound.slice(0, endRound);

  const final = { attackers:{}, defenders:{} };

  const chunkRe = /Attacker\s+([A-Za-z0-9_√Ä-√ø]+)\s+([\s\S]*?)(?=Attacker\s+[A-Za-z0-9_√Ä-√ø]+|Defender\s+|$)/g;
  let cm;
  while((cm = chunkRe.exec(roundTxt)) !== null){
    const shortName = (cm[1]||'').trim();
    const body = (cm[2]||'');
    const idxCount = body.search(/\bCount\b/i);
    if(idxCount < 0) continue;

    const beforeCount = body.slice(0, idxCount);
    const afterCount = body.slice(idxCount);
    const idxLost = afterCount.search(/\bLost\b/i);
    const countsPart = idxLost >= 0 ? afterCount.slice(0, idxLost) : afterCount;

    const shipsEN = matchKnownShipsEN(beforeCount);
    const nums = extractNums(countsPart).map(parseNum);
    if(!shipsEN.length || !nums.length) continue;

    const tag = nameToTag[shortName];
    const key = tag ? `${shortName} [${tag}]` : shortName;
    if(!final.attackers[key]) final.attackers[key] = {};

    for(let i=0;i<Math.min(shipsEN.length, nums.length);i++){
      const itName = mapShipToIT(shipsEN[i]);
      final.attackers[key][itName] = (final.attackers[key][itName]||0) + nums[i];
    }
  }

  const defChunkRe = /Defender\s+([A-Za-z0-9_√Ä-√ø]+)\s+([\s\S]*?)(?=Attacker\s+|$)/g;
  let dm;
  while((dm = defChunkRe.exec(roundTxt)) !== null){
    const shortName = (dm[1]||'').trim();
    const body = (dm[2]||'');
    const idxCount = body.search(/\bCount\b/i);
    if(idxCount < 0) continue;

    const beforeCount = body.slice(0, idxCount);
    const afterCount = body.slice(idxCount);
    const idxLost = afterCount.search(/\bLost\b/i);
    const countsPart = idxLost >= 0 ? afterCount.slice(0, idxLost) : afterCount;

    const shipsEN = matchKnownShipsEN(beforeCount);
    const nums = extractNums(countsPart).map(parseNum);

    const tag = nameToTag[shortName];
    const key = tag ? `${shortName} [${tag}]` : shortName;
    if(!final.defenders[key]) final.defenders[key] = {};

    for(let i=0;i<Math.min(shipsEN.length, nums.length);i++){
      const itName = mapShipToIT(shipsEN[i]);
      final.defenders[key][itName] = (final.defenders[key][itName]||0) + nums[i];
    }
  }

  // Build classic IT CR (initial + after battle)
  const lines = [];
  lines.push(`Il ${date} ${time}, le seguenti flotte si scontrano in combattimento:`);
  lines.push('');

  const atkKeys = Object.keys(initial.attackers);
  for(const k of atkKeys){
    lines.push(`Attaccante ${k}`);
    lines.push('________________________________________________');
    for(const [ship,qty] of Object.entries(initial.attackers[k]).sort((a,b)=>a[0].localeCompare(b[0],'it'))){
      lines.push(`${ship} ${fmt(qty)}`.replace(/\./g,'.'));
    }
    lines.push('_________________________________________');
    lines.push('');
  }

  const defKeys = Object.keys(initial.defenders);
  for(const k of defKeys){
    lines.push(`Difensore ${k}`);
    lines.push('________________________________________________');
    for(const [ship,qty] of Object.entries(initial.defenders[k]).sort((a,b)=>a[0].localeCompare(b[0],'it'))){
      lines.push(`${ship} ${fmt(qty)}`.replace(/\./g,'.'));
    }
    lines.push('_________________________________________');
    lines.push('');
  }

  lines.push('Dopo la battaglia...');
  lines.push('');

  for(const k of atkKeys){
    lines.push(`Attaccante ${k}`);
    lines.push('________________________________________________');
    const initShips = initial.attackers[k] || {};
    const finShips  = final.attackers[k] || {};
    const shipSet = new Set([...Object.keys(initShips), ...Object.keys(finShips)]);
    for(const ship of Array.from(shipSet).sort((a,b)=>a.localeCompare(b,'it'))){
      const a0 = initShips[ship] || 0;
      const a1 = finShips[ship] || 0;
      const lost = Math.max(0, a0 - a1);
      lines.push(`${ship} ${fmt(a1)} ( -${fmt(lost)} )`);
    }
    lines.push('_________________________________________');
    lines.push('');
  }

  for(const k of defKeys){
    lines.push(`Difensore ${k}`);
    lines.push('________________________________________________');
    lines.push('Distrutto!');
    lines.push('_________________________________________');
    lines.push('');
  }

  // keep loot + debris if present
  const lootM = (t.match(/Metal loot:\s*([\d\.,]+)/i) || [])[1];
  const lootC = (t.match(/Crystal loot:\s*([\d\.,]+)/i) || [])[1];
  const lootD = (t.match(/Deuterium loot:\s*([\d\.,]+)/i) || [])[1];
  if(lootM || lootC || lootD){
    lines.push("L'attaccante saccheggia:");
    lines.push(`${lootM||'0'} Metallo, ${lootC||'0'} Cristallo e ${lootD||'0'} Deuterio`);
    lines.push('');
  }

  const dfM = (t.match(/Metal to debrisfield:\s*([\d\.,]+)/i) || [])[1];
  const dfC = (t.match(/Crystal to debrisfield:\s*([\d\.,]+)/i) || [])[1];
  const dfD = (t.match(/Deuterium to debrisfield:\s*([\d\.,]+)/i) || [])[1];
  if(dfM || dfC || dfD){
    lines.push(`At these space coordinates now float ${dfM||'0'} metal, ${dfC||'0'} crystal and ${dfD||'0'} deuterium.`);
    lines.push('');
  }

  return lines.join('\n');
}

/* ---------- UI actions ---------- */
const crText = document.getElementById('crText');

document.getElementById('btnParseCR').addEventListener('click', () => {
  if(!crText.value.trim()){
    log("‚ö†Ô∏è CR vuoto");
    return;
  }
  document.getElementById('stageCR').classList.add('hidden');
  document.getElementById('stageResults').classList.remove('hidden');
  log("‚úÖ CR caricato e analizzato");
});

document.getElementById('btnClearRR').addEventListener('click', () => {
  document.getElementById('rrIds').value = '';
  log("RR puliti");
});

document.getElementById('btnShare').addEventListener('click', async () => {
  const url = location.href;
  try{
    await navigator.clipboard.writeText(url);
    log("üîó Link copiato");
  }catch(e){
    log("‚ö†Ô∏è Clipboard non disponibile: copia manualmente l'URL");
  }
});

/* ---------- FIX: CR API button (CORS-safe + conversion) ---------- */
document.getElementById('btnLoadCRApi')?.addEventListener('click', async () => {
  const apiId = (document.getElementById('crApiId')?.value || '').trim();
  if (!apiId) { log("‚ö†Ô∏è Inserisci un API ID CR."); return; }

  const url = /^https?:\/\//i.test(apiId)
    ? apiId
    : `https://nomoreangel.de/api-reader/?apiid=${encodeURIComponent(apiId)}&engOut=on`;

  log(`CR API: richiesta NoMoreAngel per ${apiId}...`);

  try {
    const raw = await fetchTextWithFallback(url, 15000);
    const classic = parseNmaApiReaderToClassic(raw);

    if (!classic) {
      log("‚ùå Conversione CR fallita (manca Initial/Round). Incolla manualmente il CR.");
      return;
    }

    crText.value = classic;
    log("‚úÖ CR caricato da API e convertito.");
    document.getElementById('btnParseCR').click();

  } catch (e) {
    log("‚ùå Errore caricamento CR API: " + (e?.message || e));
  }
});

/* ---------- placeholder RR actions (non cambiate nel tuo snippet) ---------- */
document.getElementById('btnLoadRR')?.addEventListener('click', () => {
  log("‚ÑπÔ∏è RR loader non incluso in questo snippet minimal (incolla qui la tua logica RR se serve).");
});

/* init */
log("Pronto. 1) Incolla/Carica CR e Analizza. 2) Inserisci RR. 3) Vedi risultati.");
</script>

</body>
</html>
