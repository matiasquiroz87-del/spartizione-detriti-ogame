<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Spartizione Detriti OGame - CR (testo) + RR (API)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800&family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root {
    /* OGame-ish palette */
    --bg:#050a10;
    --panel:#0b1320;
    --panel2:#07101b;
    --text:#dbe7ff;
    --muted:#93a6c7;
    --line:rgba(120,160,220,.25);
    --accent:#4da3ff;      /* orange */
    --accent2:#2dd4ff;     /* cyan */
    --good:#39d98a;
    --bad:#ff5c5c;
    --warn:#ff5c5c;
    --font-ui: "Rajdhani", system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial;
    --font-title: "Orbitron", "Rajdhani", system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:var(--font-ui);color:var(--text);background:var(--bg);}
  body::before{
    content:"";
    position:fixed;
    inset:0;
    z-index:-1;
    background:
      radial-gradient(1200px 700px at 15% -10%, rgba(124,240,255,.10), transparent 55%),
      radial-gradient(900px 600px at 110% 10%, rgba(255,179,77,.10), transparent 55%),
      radial-gradient(2px 2px at 20% 30%, rgba(255,255,255,.9), transparent 60%),
      radial-gradient(1px 1px at 40% 60%, rgba(255,255,255,.75), transparent 60%),
      radial-gradient(1px 1px at 70% 20%, rgba(255,255,255,.7), transparent 60%),
      radial-gradient(1px 1px at 85% 80%, rgba(255,255,255,.65), transparent 60%),
      radial-gradient(1px 1px at 10% 85%, rgba(255,255,255,.6), transparent 60%),
      radial-gradient(1px 1px at 95% 45%, rgba(255,255,255,.55), transparent 60%),
      linear-gradient(180deg, rgba(15,25,40,.65), rgba(5,10,16,1));
    filter:saturate(1.05) contrast(1.05);
  }
  header{position:sticky;top:0;z-index:5;background:linear-gradient(180deg, rgba(7,12,18,.92), rgba(7,12,18,.65));backdrop-filter:blur(10px);border-bottom:1px solid var(--line);}
  .wrap{max-width:1100px;margin:0 auto;padding:14px 14px;}
  .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px;}
  .title{display:flex;align-items:center;gap:10px;min-width:0;}
  .actions{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end;}
  .badge{font-size:12px;color:var(--muted);border:1px solid var(--line);padding:4px 8px;border-radius:999px;background:rgba(16,26,46,.6)}
  h1{font-family:var(--font-title);font-size:16px;margin:0;letter-spacing:.8px;text-transform:uppercase}
  .tabs{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
  .tabbtn{border:1px solid var(--line);background:rgba(16,26,46,.6);color:var(--text);padding:8px 10px;border-radius:10px;cursor:pointer}
  .tabbtn.active{border-color:rgba(242,169,0,.8);box-shadow:0 0 0 2px rgba(242,169,0,.18) inset;background:rgba(242,169,0,.07)}
  .grid{display:grid;grid-template-columns:1fr;gap:12px;margin-top:14px}
  @media (min-width: 980px){ .grid{grid-template-columns: 1fr 1fr;} }
  .card{border:1px solid var(--line);background:linear-gradient(180deg, rgba(16,26,46,.8), rgba(14,23,40,.75));border-radius:16px;padding:12px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .card h2{margin:0 0 8px 0;font-size:14px;color:var(--text)}
  textarea,input{width:100%;background:rgba(8,12,20,.65);border:1px solid var(--line);color:var(--text);border-radius:12px;padding:10px;font-size:13px;outline:none}
  textarea{min-height:240px;resize:vertical;line-height:1.25}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .row > *{flex:1}
  button{border:1px solid rgba(88,166,255,.65);background:rgba(88,166,255,.15);color:var(--text);
    padding:9px 12px;border-radius:12px;cursor:pointer;font-weight:600}
  button:hover{background:rgba(88,166,255,.22)}
  .ghost{border-color:var(--line);background:rgba(16,26,46,.5);font-weight:600}
  .ghost:hover{background:rgba(16,26,46,.75)}
  .mini{font-size:12px;color:var(--muted)}
  .pill{display:inline-flex;gap:8px;align-items:center;border:1px solid var(--line);border-radius:999px;padding:6px 10px;background:rgba(16,26,46,.5)}
  .pill input{width:auto}
  .kpi{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px}
  .kpi .box{border:1px solid var(--line);background:rgba(8,12,20,.35);border-radius:12px;padding:10px}
  .kpi .box .v{font-size:14px;font-weight:800}
  .kpi .box .l{font-size:12px;color:var(--muted)}
  table{width:100%;border-collapse:collapse;overflow:hidden;border-radius:12px;border:1px solid var(--line);background:rgba(8,12,20,.35)}
  th,td{padding:8px 8px;border-bottom:1px solid rgba(34,52,85,.6);font-size:12px;text-align:right}
  th{text-align:right;color:var(--muted);font-weight:700;background:rgba(16,26,46,.55)}
  th:first-child, td:first-child{text-align:left}
  tr:last-child td{border-bottom:none}
  .good{color:var(--good)}
  .bad{color:var(--bad)}
  .warn{color:var(--warn)}
  details{border:1px solid var(--line);border-radius:12px;padding:10px;background:rgba(8,12,20,.25)}
  summary{cursor:pointer;color:var(--muted);font-weight:700}
  pre{margin:0;white-space:pre-wrap;word-break:break-word;font-size:12px;color:#cfe0ff}

.ico{width:16px;height:16px;vertical-align:-3px;margin-right:8px;fill:currentColor;opacity:.9}

.advanced{display:none}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1>Spartizione Detriti OGame</h1>
        <span class="badge">CR testo + RR API • logica foglio di calcolo</span>
      </div>
      <div class="actions">
        <button class="ghost" id="btnShare" type="button" title="Copia un link con la configurazione"><svg class="ico" viewBox="0 0 24 24" aria-hidden="true"><path d="M18 16a3 3 0 0 0-2.24 1.02L8.91 13.7a3.2 3.2 0 0 0 0-3.4l6.85-3.32A3 3 0 1 0 15 5a2.98 2.98 0 0 0 .07.63L8.22 8.95A3 3 0 1 0 9 12a2.98 2.98 0 0 0-.07-.63l6.85 3.32A3 3 0 1 0 18 16Z"/></svg>Condividi</button>
      </div>
    </div>
    <div class="tabs">
      <button class="tabbtn active" data-tab="cr">CR (testo)</button>
      <button class="tabbtn" data-tab="rr">RR (API via nomoreangel/proxy)</button>
      <button class="tabbtn" data-tab="risultati">Risultati</button>
      <button class="tabbtn" data-tab="log">Log</button>
    </div>
  </div>
</header>

<div class="wrap">
  <div id="tab-cr" class="tab">
    <div class="grid">
      <div class="card">
        <h2>Incolla qui il Combat Report (formato classico IT/EN)</h2>
        <textarea id="crText" placeholder="Incolla il CR qui..."></textarea>
        <div class="row" style="margin-top:10px">
          <button id="btnParseCR">Analizza CR</button>
          <button id="btnCRDemo" class="ghost">Demo</button>
        </div>

        <div class="hr" style="margin:12px 0"></div>

        <div class="mini" style="margin-bottom:8px">CR da API (NoMoreAngel)</div>
        <div class="row" style="gap:10px; flex-wrap:wrap">
          <input id="crApiId" style="flex:1; min-width:260px" placeholder="API ID (es: cr-it-269-...) oppure URL NoMoreAngel" />
          <button id="btnLoadCRApi" class="ghost">Carica da API</button>
        </div>
        <details style="margin-top:10px">
          <summary class="mini">Debug: risposta conversione (HTML)</summary>
          <pre id="crApiRaw" class="codebox" style="max-height:220px; overflow:auto"></pre>
        </details>

        <div class="mini" style="margin-top:8px">
          Estrae: attaccanti, difensore, coordinate, loot, perdite, DF (float).
        </div>
      </div>

      <div class="card">
        <h2>Opzioni di spartizione</h2>
        <div class="row">
          <label class="pill"><input type="radio" name="mode" value="paritaria" checked> Paritaria</label>
          <label class="pill"><input type="radio" name="mode" value="equa"> Equa (peso flotta in campo)</label>
        </div>
        <div class="kpi" id="kpiCR"></div>

        <details style="margin-top:10px" open>
          <summary>Costi navi / difese (come foglio)</summary>
          <div class="mini" style="margin-top:8px">
            I calcoli usano questi costi base. Se il tuo universo ha costi diversi, dimmelo e li rendiamo editabili.
          </div>
          <div id="costsTable" style="margin-top:8px"></div>
        </details>
      </div>
    </div>
  </div>

  <div id="tab-rr" class="tab" style="display:none">
    <div class="grid">
      <div class="card">
        <h2>Carica RR tramite API ID</h2>
        <div class="row advanced">
          <div style="flex:2">
            <label class="mini">Proxy base URL</label>
            <input id="proxyBase" value="https://ogame-api-proxy.matiasquiroz87.workers.dev/?apiid=" />
          </div>
          <div>
            <label class="mini">Timeout (ms)</label>
            <input id="timeoutMs" value="12000" />
          </div>
        </div>
        <div style="margin-top:8px">
          <label class="mini">Inserisci uno o più RR apiid (uno per riga)</label>
          <textarea id="rrIds" placeholder="rr-it-269-...."></textarea>
        </div>
        <div class="row" style="margin-top:10px">
          <button id="btnLoadRR">Carica RR</button>
          <button id="btnClearRR" class="ghost">Pulisci</button>
        </div>
        <div class="mini" style="margin-top:8px">
          Il tool somma automaticamente le raccolte per giocatore (owner_name) e per risorsa.
        </div>
      </div>

      <div class="card">
        <h2>Raccolte lette</h2>
        <div id="rrTable"></div>
        <details style="margin-top:10px">
          <summary>Dettagli RR (debug)</summary>
          <pre id="rrRaw"></pre>
        </details>
      </div>
    </div>
  </div>

  <div id="tab-risultati" class="tab" style="display:none">
    <div class="card">
      <h2>Risultati (logica del foglio)</h2>
      <div class="mini">
        Formula (per risorsa): <b>quota = perdite_i + (gain_totale × peso_i) − raccolto_i</b><br/>
        dove <b>gain_totale = raccolto_totale − perdite_totali</b>. La somma delle quote = 0 (trasferimenti tra alleati).
      </div>
      <div style="margin-top:10px" id="resultsTables"></div>

      <details style="margin-top:12px" open>
        <summary>Trasporti finali suggeriti</summary>
        <div class="mini" style="margin-top:8px">
          Elenco di trasferimenti minimi tra chi deve inviare (negativo) e chi deve ricevere (positivo).
        </div>
        <div id="transports"></div>
      </details>
    </div>
  </div>

  <div id="tab-log" class="tab" style="display:none">
    <div class="card">
      <h2>Log</h2>
      <pre id="logBox"></pre>
    </div>
  </div>
</div>

<script>
const COSTS = {"Cargo leggero": [2000, 2000, 0], "Cargo Pesante": [6000, 6000, 0], "Caccia Leggero": [3000, 1000, 0], "Caccia Pesante": [6000, 4000, 0], "Incrociatore": [20000, 7000, 2000], "Nave da battaglia": [45000, 15000, 0], "Bombardiere": [50000, 25000, 15000], "Corazzata": [60000, 50000, 15000], "Incrociatore da Battaglia": [30000, 40000, 15000], "Reaper": [85000, 55000, 20000], "Pathfinder": [8000, 15000, 8000], "Riciclatrice": [10000, 6000, 2000], "Colonizzatrice": [10000, 20000, 10000], "Sonda spia": [0, 1000, 0], "Satellite Solare": [0, 2000, 500], "Crawler": [2000, 2000, 1000], "Morte Nera": [5000000, 4000000, 1000000], "Lanciamissili": [2000, 0, 0], "Laser leggero": [1500, 500, 0], "Laser pesante": [6000, 2000, 0], "Cannone Gauss": [20000, 15000, 2000], "Cannone ionico": [2000, 6000, 0], "Cannone al Plasma": [50000, 50000, 30000], "Cupola scudo piccola": [10000, 10000, 0], "Cupola scudo potenziata": [50000, 50000, 0]};

function fmt(n) {
  if (n === null || n === undefined || isNaN(n)) return '-';
  return Math.round(n).toLocaleString('it-IT');
}
function parseNum(str) {
  if (str === null || str === undefined) return 0;
  const s = String(str).replace(/\./g,'').replace(/,/g,'').replace(/\s+/g,'').trim();
  const n = Number(s);
  return isNaN(n) ? 0 : n;
}
const LOG = [];
function log(msg, level="info") {
  const t = new Date().toLocaleTimeString();
  const line = `[${t}] ${msg}`;
  LOG.push(line);
  const el = document.getElementById('logBox');
  if (el) el.textContent = LOG.join("\n");
}

function toast(msg, type="info"){
  log((type === "error" ? "❌ " : "") + msg, type);
  if(type === "error"){
    try{ alert(msg); }catch(_){/* ignore */}
  }
}

// Error hooks: se la console non è visibile, scriviamo nel log.
window.addEventListener('error', (e) => {
  try { log('JS ERROR: ' + (e.message || (e.error && e.error.message) || 'unknown') + (e.filename ? (' @ ' + e.filename + ':' + e.lineno) : '')); } catch(_) {}
});
window.addEventListener('unhandledrejection', (e) => {
  try { log('PROMISE REJECTION: ' + (e.reason?.message || String(e.reason))); } catch(_) {}
});

function setTab(name) {
  document.querySelectorAll('.tabbtn').forEach(b => b.classList.toggle('active', b.dataset.tab===name));
  document.querySelectorAll('.tab').forEach(t => t.style.display = 'none');
  document.getElementById('tab-'+name).style.display = 'block';
}

document.querySelectorAll('.tabbtn').forEach(btn => btn.addEventListener('click', () => setTab(btn.dataset.tab)));

function renderCosts() {
  const rows = Object.entries(COSTS).map(([k,v]) => {
    const [m,c,d]=v;
    const g=m+c+d;
    return `<tr><td>${k}</td><td>${fmt(m)}</td><td>${fmt(c)}</td><td>${fmt(d)}</td><td>${fmt(g)}</td></tr>`;
  }).join('');
  document.getElementById('costsTable').innerHTML = `
    <table>
      <thead><tr><th>Unità</th><th>Metallo</th><th>Cristallo</th><th>Deuterio</th><th>Globale</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>`;
}
renderCosts();

// -------- CR PARSER (testo classico) --------
const STATE = {
  cr: null, // parsed CR
  rr: {}  // per player totals: {player: {m,c,d, list:[]}}
};

function parseCRText(text) {
  const out = {
    attackers: {}, // name -> {tag, initial{ship:count}, final{ship:count}}
    defenders: {},
    coords: null,
    loot: {m:0,c:0,d:0},
    df_float: {m:0,c:0,d:0},
    moonChance: null,
    lossesUnits: {att:0, def:0},
  };

  // coords + moon chance
  const coordM = text.match(/\b\[(\d+:\d+:\d+)\]|\b(\d+:\d+:\d+)\b/);
  if (coordM) out.coords = (coordM[1]||coordM[2]||null);

  const moonM = text.match(/possibilit[aà].*?luna.*?(\d+)%/i);
  if (moonM) out.moonChance = parseNum(moonM[1]);

  // losses units
  const attLost = text.match(/attaccante ha perso un totale di\s*([\d\.,]+)\s*unit/i);
  const defLost = text.match(/difensore ha perso un totale di\s*([\d\.,]+)\s*unit/i);
  if (attLost) out.lossesUnits.att = parseNum(attLost[1]);
  if (defLost) out.lossesUnits.def = parseNum(defLost[1]);

  // loot
  const lootM = text.match(/saccheggia:\s*([\d\.,]+)\s*Metallo,\s*([\d\.,]+)\s*Cristallo\s*e\s*([\d\.,]+)\s*Deuterio/i);
  if (lootM) {
    out.loot.m = parseNum(lootM[1]);
    out.loot.c = parseNum(lootM[2]);
    out.loot.d = parseNum(lootM[3]);
  }

  // debris float line (EN)
  const dfM = text.match(/now float\s*([\d\.,]+)\s*metal,\s*([\d\.,]+)\s*crystal\s*and\s*([\d\.,]+)\s*deuterium/i);
  if (dfM) {
    out.df_float.m = parseNum(dfM[1]);
    out.df_float.c = parseNum(dfM[2]);
    out.df_float.d = parseNum(dfM[3]);
  }

  // Split pre/post battle (robusto: "Dopo la battaglia..." può variare)
  let pre = text;
  let post = "";
  const idx = text.search(/\bDopo\s+la\s+battaglia\b/i);
  if (idx >= 0) {
    pre = text.slice(0, idx);
    post = text.slice(idx);
  }

  function parseSideBlocks(blockText, phase) {
    // phase: 'initial' or 'final'
    const lines = blockText.split(/\r?\n/);
    let current = null;
    let currentSide = null;
    for (let i=0;i<lines.length;i++) {
      const line = lines[i].trim();
      if (!line) continue;
      const h = line.match(/^(Attaccante|Difensore)\s+(.+?)\s+\[(.+?)\]\s*$/i);
      if (h) {
        currentSide = h[1].toLowerCase().startsWith('att') ? 'att' : 'def';
        const name = h[2].trim();
        const tag = h[3].trim();
        if (currentSide==='att') {
          if (!out.attackers[name]) out.attackers[name] = {tag, initial: {}, final: {}};
          out.attackers[name].tag = tag;
          current = out.attackers[name];
        } else {
          if (!out.defenders[name]) out.defenders[name] = {tag, initial: {}, final: {}};
          out.defenders[name].tag = tag;
          current = out.defenders[name];
        }
        continue;
      }
      if (!current) continue;
      if (line.startsWith('_')) continue;
      if (line.toLowerCase().includes('distrutto')) continue;

      // ship line: "Caccia Leggero 3.226.909 ( -xxx )"
      const m = line.match(/^(.+?)\s+([\d\.,]+)(?:\s*\(\s*-[\d\.,]+\s*\))?\s*$/);
      if (m) {
        const ship = m[1].trim();
        const count = parseNum(m[2]);
        if (phase==='initial') current.initial[ship] = (current.initial[ship]||0) + count;
        else current.final[ship] = (current.final[ship]||0) + count;
      }
    }
  }

  parseSideBlocks(pre, 'initial');
  if (post) parseSideBlocks(post, 'final');

  // Ensure final exists: if missing post, copy initial
  Object.values(out.attackers).forEach(p => {
    if (!p.final || Object.keys(p.final).length===0) p.final = JSON.parse(JSON.stringify(p.initial));
  });

  return out;
}

function computeFromSheetLogic(cr, rrTotals, mode) {
  const players = Object.keys(cr.attackers);
  const n = players.length || 1;

  // 1) losses per player by ship diffs
  const losses = {};
  const fleetValue = {};
  players.forEach(name => {
    const p = cr.attackers[name];
    losses[name] = {m:0,c:0,d:0, units:0};
    fleetValue[name] = 0;
    // Fleet in campo (initial) value
    for (const [ship, cnt] of Object.entries(p.initial)) {
      const cost = COSTS[ship];
      if (cost) {
        const g = (cost[0]+cost[1]+cost[2]) * cnt;
        fleetValue[name] += g;
      }
    }
    // losses
    const ships = new Set([...Object.keys(p.initial), ...Object.keys(p.final)]);
    ships.forEach(ship => {
      const ini = p.initial[ship] || 0;
      const fin = p.final[ship] || 0;
      const lostCnt = Math.max(0, ini - fin);
      if (lostCnt<=0) return;
      losses[name].units += lostCnt;
      const cost = COSTS[ship];
      if (!cost) return; // ignore unknown ships
      losses[name].m += cost[0] * lostCnt;
      losses[name].c += cost[1] * lostCnt;
      losses[name].d += cost[2] * lostCnt;
    });
  });

  const totLoss = players.reduce((a,nm)=>({
    m:a.m+losses[nm].m, c:a.c+losses[nm].c, d:a.d+losses[nm].d
  }), {m:0,c:0,d:0});

  // 2) total recycled from RR
  const totRec = players.reduce((a,nm)=>{
    const r = rrTotals[nm] || {m:0,c:0,d:0};
    return {m:a.m+r.m, c:a.c+r.c, d:a.d+r.d};
  }, {m:0,c:0,d:0});

  // 3) gain = recycled - losses (per resource)
  const gain = {m: totRec.m - totLoss.m, c: totRec.c - totLoss.c, d: totRec.d - totLoss.d};

  // 4) weights
  const weights = {};
  if (mode === 'paritaria') {
    players.forEach(nm => weights[nm] = 1/n);
  } else {
    const totFleet = players.reduce((s,nm)=> s + (fleetValue[nm]||0), 0) || 1;
    players.forEach(nm => weights[nm] = (fleetValue[nm]||0)/totFleet);
  }

  // 5) quota (= due): losses + gain*weight - collected
  const quota = {};
  players.forEach(nm => {
    const r = rrTotals[nm] || {m:0,c:0,d:0};
    quota[nm] = {
      m: losses[nm].m + gain.m * weights[nm] - r.m,
      c: losses[nm].c + gain.c * weights[nm] - r.c,
      d: losses[nm].d + gain.d * weights[nm] - r.d,
      w: weights[nm],
      fleet: fleetValue[nm],
      lost: losses[nm],
      rec: r
    };
  });

  return {players, losses, fleetValue, weights, totLoss, totRec, gain, quota};
}

function buildTransfers(players, quota, resKey) {
  const recv = [];
  const send = [];
  players.forEach(p => {
    const v = quota[p][resKey];
    if (v > 0.5) recv.push([p, v]);
    else if (v < -0.5) send.push([p, -v]);
  });
  recv.sort((a,b)=>b[1]-a[1]);
  send.sort((a,b)=>b[1]-a[1]);
  const moves = [];
  let i=0,j=0;
  while (i<send.length && j<recv.length) {
    const [sp, sv] = send[i];
    const [rp, rv] = recv[j];
    const x = Math.min(sv, rv);
    if (x>0.5) moves.push({from: sp, to: rp, amount: x});
    send[i][1] -= x;
    recv[j][1] -= x;
    if (send[i][1] <= 0.5) i++;
    if (recv[j][1] <= 0.5) j++;
  }
  return moves;
}

function renderKPI(cr) {
  const el = document.getElementById('kpiCR');
  if (!cr) { el.innerHTML = ""; return; }
  const attackers = Object.keys(cr.attackers).length;
  const defenders = Object.keys(cr.defenders).length;
  el.innerHTML = `
    <div class="box"><div class="v">${cr.coords || '-'}</div><div class="l">Coordinate</div></div>
    <div class="box"><div class="v">${attackers} / ${defenders}</div><div class="l">Attaccanti / Difensori</div></div>
    <div class="box"><div class="v">${cr.moonChance!==null ? (cr.moonChance+'%') : '-'}</div><div class="l">Chance Luna</div></div>
    <div class="box"><div class="v">${fmt(cr.df_float.m)}</div><div class="l">DF float M</div></div>
    <div class="box"><div class="v">${fmt(cr.df_float.c)}</div><div class="l">DF float C</div></div>
    <div class="box"><div class="v">${fmt(cr.df_float.d)}</div><div class="l">DF float D</div></div>
  `;
}

function renderRRTable(rrTotals) {
  const entries = Object.entries(rrTotals);
  if (entries.length===0) {
    document.getElementById('rrTable').innerHTML = '<div class="mini">Nessun RR caricato.</div>';
    return;
  }
  const rows = entries.map(([p,v]) => `
    <tr><td>${p}</td><td>${fmt(v.m)}</td><td>${fmt(v.c)}</td><td>${fmt(v.d)}</td><td>${v.count||0}</td></tr>
  `).join('');
  document.getElementById('rrTable').innerHTML = `
    <table>
      <thead><tr><th>Giocatore</th><th>Metallo</th><th>Cristallo</th><th>Deuterio</th><th>RR</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>`;
}

function renderResults(computed) {
  const {players, totLoss, totRec, gain, quota} = computed;

  const header = `
    <div class="kpi">
      <div class="box"><div class="v">${fmt(totRec.m)} / ${fmt(totRec.c)} / ${fmt(totRec.d)}</div><div class="l">Riciclato totale (M/C/D)</div></div>
      <div class="box"><div class="v">${fmt(totLoss.m)} / ${fmt(totLoss.c)} / ${fmt(totLoss.d)}</div><div class="l">Perdite totali (M/C/D)</div></div>
      <div class="box"><div class="v">${fmt(gain.m)} / ${fmt(gain.c)} / ${fmt(gain.d)}</div><div class="l">Gain da dividere (M/C/D)</div></div>
    </div>`;

  const rows = players.map(p => {
    const q = quota[p];
    const mClass = q.m>=0 ? 'good':'bad';
    const cClass = q.c>=0 ? 'good':'bad';
    const dClass = q.d>=0 ? 'good':'bad';
    return `
      <tr>
        <td>${p} <span class="mini">[${(q.w*100).toFixed(2)}%]</span></td>
        <td>${fmt(q.lost.m)}</td><td>${fmt(q.lost.c)}</td><td>${fmt(q.lost.d)}</td>
        <td>${fmt(q.rec.m)}</td><td>${fmt(q.rec.c)}</td><td>${fmt(q.rec.d)}</td>
        <td class="${mClass}">${fmt(q.m)}</td>
        <td class="${cClass}">${fmt(q.c)}</td>
        <td class="${dClass}">${fmt(q.d)}</td>
      </tr>`;
  }).join('');

  const table = `
    <table style="margin-top:10px">
      <thead>
        <tr>
          <th>Giocatore</th>
          <th>Perse M</th><th>Perse C</th><th>Perse D</th>
          <th>Raccolto M</th><th>Raccolto C</th><th>Raccolto D</th>
          <th>Quota M</th><th>Quota C</th><th>Quota D</th>
        </tr>
      </thead>
      <tbody>${rows}</tbody>
    </table>
    <div class="mini" style="margin-top:8px">
      Quota positiva = deve ricevere. Quota negativa = deve inviare.
    </div>`;

  document.getElementById('resultsTables').innerHTML = header + table;

  // transports
  const mt = buildTransfers(players, quota, 'm');
  const ct = buildTransfers(players, quota, 'c');
  const dt = buildTransfers(players, quota, 'd');

  function renderMoveList(label, moves) {
    if (!moves.length) return `<div class="mini">Nessun trasferimento per ${label} (già bilanciato).</div>`;
    const r = moves.map(m => `<tr><td>${m.from}</td><td>${m.to}</td><td>${fmt(m.amount)}</td></tr>`).join('');
    return `
      <div style="margin-top:10px">
        <div class="mini" style="margin:6px 0"><b>${label}</b></div>
        <table>
          <thead><tr><th>Da</th><th>A</th><th>Quantità</th></tr></thead>
          <tbody>${r}</tbody>
        </table>
      </div>`;
  }
  document.getElementById('transports').innerHTML =
    renderMoveList('Metallo', mt) + renderMoveList('Cristallo', ct) + renderMoveList('Deuterio', dt);
}

function recomputeAndRender() {
  if (!STATE.cr) {
    log("⚠️ Nessun CR caricato.");
    return;
  }
  const mode = document.querySelector('input[name="mode"]:checked')?.value || 'paritaria';
  const rrTotals = STATE.rr || {};
  const computed = computeFromSheetLogic(STATE.cr, rrTotals, mode);
  renderResults(computed);
}

document.querySelectorAll('input[name="mode"]').forEach(r => r.addEventListener('change', () => {
  log("Modalità: " + document.querySelector('input[name="mode"]:checked').value);
  recomputeAndRender();
}));

document.getElementById('btnParseCR').addEventListener('click', () => {
  try {
    const text = document.getElementById('crText').value || '';
    const cr = parseCRText(text);
    STATE.cr = cr;
    renderKPI(cr);
    log(`✅ CR caricato. Attaccanti: ${Object.keys(cr.attackers).length} • Difensori: ${Object.keys(cr.defenders).length} • Coord: ${cr.coords||'-'}`);
    recomputeAndRender();
    setTab('risultati');
  } catch (e) {
    log("❌ Errore parsing CR: " + (e?.message || e));
    console.error(e);
    setTab('log');
  }
});

document.getElementById('btnCRDemo').addEventListener('click', () => {
  const demo = `Il 28-01-2026 --:--:--, le seguenti flotte si scontrano in combattimento:

Attaccante Abubu [U E]
________________________________________________
Cargo Pesante 1
Caccia Leggero 3.226.909
Caccia Pesante 177.230
Incrociatore 557.550
Nave da battaglia 151.773
Corazzata 89.802
Incrociatore da Battaglia 462.085
Reaper 129.700
Pathfinder 96.320
_________________________________________

Difensore Bartok [SoV]
________________________________________________
Cargo leggero 515.205
Cargo Pesante 96.004
Caccia Leggero 487.861
_________________________________________

Dopo la battaglia...

Attaccante Abubu [U E]
________________________________________________
Cargo Pesante 1 ( -0 )
Caccia Leggero 2.961.733 ( -265.176 )
Caccia Pesante 167.384 ( -9.846 )
Incrociatore 544.263 ( -13.287 )
Nave da battaglia 150.566 ( -1.207 )
Corazzata 89.649 ( -153 )
Incrociatore da Battaglia 459.127 ( -2.958 )
Reaper 129.496 ( -204 )
Pathfinder 93.760 ( -2.560 )
_________________________________________

Difensore Bartok [SoV]
________________________________________________
Distrutto!
_________________________________________

L'attaccante saccheggia:
471.166.157 Metallo, 125.714.491 Cristallo e 21.863.628 Deuterio

L'attaccante ha perso un totale di 6.842.469.000 unità.
Il difensore ha perso un totale di 66.020.471.000 unità.
At these space coordinates now float 8.451.301.052 metal, 6.135.502.953 crystal and 1.725.266.027 deuterium.
La possibilità che si formi una luna dai detriti era del 22%.`;
  document.getElementById('crText').value = demo;
  log("Demo CR inserito.");
});

// -------- CR LOADER (API -> NoMoreAngel conversion) --------
function normalizeHTMLFromJina(text){
  const idx = (text||'').search(/<!DOCTYPE html>|<html[\s>]/i);
  return idx >= 0 ? text.slice(idx) : (text||'');
}

async function fetchTextWithFallback(url, timeoutMs=12000){
  // 1) direct
  try{
    const res = await abortableFetch(url, timeoutMs);
    if(!res.ok) throw new Error('HTTP ' + res.status);
    return await res.text();
  }catch(e1){
    // 2) Jina AI proxy (often bypasses CORS)
    const clean = url.replace(/^https:\/\//i,'');
    const jinaUrl = `https://r.jina.ai/https://${clean}`;
    const res = await abortableFetch(jinaUrl, timeoutMs);
    if(!res.ok) throw new Error('HTTP ' + res.status);
    return await res.text();
  }
}

function decodeHtmlEntities(html){
  if(html == null) return '';
  const txt = document.createElement('textarea');
  txt.innerHTML = html;
  return txt.value;
}

function cleanupText(s){
  return (s||'')
    .replace(/\r/g,'')
    .replace(/\u00a0/g,' ')
    .replace(/\n{3,}/g,'\n\n')
    .trim();
}

const shipNameMapEN2IT = {
  "Small Cargo":"Cargo leggero",
  "Large Cargo":"Cargo Pesante",
  "Light Fighter":"Caccia Leggero",
  "Heavy Fighter":"Caccia Pesante",
  "Cruiser":"Incrociatore",
  "Battleship":"Nave da battaglia",
  "Colony Ship":"Colonizzatrice",
  "Recycler":"Riciclatrice",
  "Espionage Probe":"Sonda spia",
  "Bomber":"Bombardiere",
  "Solar Satellite":"Satellite Solare",
  "Destroyer":"Corazzata",
  "Deathstar":"Morte Nera",
  "Battlecruiser":"Incrociatore da Battaglia",
  "Crawler":"Crawler",
  "Reaper":"Reaper",
  "Pathfinder":"Pathfinder",
  "Rocket Launcher":"Lanciamissili",
  "Light Laser":"Laser leggero",
  "Heavy Laser":"Laser pesante",
  "Gauss Cannon":"Cannone Gauss",
  "Ion Cannon":"Cannone ionico",
  "Plasma Turret":"Cannone al Plasma",
  "Small Shield Dome":"Cupola scudo piccola",
  "Large Shield Dome":"Cupola scudo potenziata",
};

function mapShipNameToIT(name){
  const n = (name||'').trim();
  return shipNameMapEN2IT[n] || n;
}

function parseNmaTypeCountTable(tbl){
  const rows = Array.from(tbl.querySelectorAll('tr'));
  const findRow = (label) => rows.find(r => (r.children?.[0]?.textContent||'').trim().toLowerCase() === label.toLowerCase());
  const typeRow = findRow('Type');
  const countRow = findRow('Count');
  if(!typeRow || !countRow) return null;
  const types = Array.from(typeRow.children).slice(1).map(td => (td.textContent||'').trim());
  const counts = Array.from(countRow.children).slice(1).map(td => parseNum(td.textContent||'0'));
  const out = {};
  for(let i=0;i<types.length;i++){
    const t = mapShipNameToIT(types[i]);
    if(!t) continue;
    out[t] = (out[t]||0) + (counts[i]||0);
  }
  return out;
}

function parseHeaderBlockText(text){
  const lines = (text||'').split(/\n+/).map(s=>s.trim()).filter(Boolean);
  const role = lines[0] || '';
  const coordLine = lines.find(l => /^\[\d+:\d+:\d+\]/.test(l)) || '';
  const coords = (coordLine.match(/^\[([^\]]+)\]/)||[])[1] || '';
  const nameLine = lines.find(l => !l.startsWith('[') && !/^\[\d+:\d+:\d+\]/.test(l) && !/Weapon:|Shield:|Armor:|\(Moon\)|\(Planet\)/i.test(l)) || '';
  const tagLine = lines.find(l => /^\[[^\]]+\]/.test(l) && !/^\[\d+:\d+:\d+\]/.test(l)) || '';
  const tag = (tagLine.match(/^\[([^\]]+)\]/)||[])[1] || '';
  return {role: role.trim(), name: nameLine.trim(), tag: tag.trim(), coords: coords.trim()};
}

function extractGeneralInfoFromNMA(doc){
  const out = {};
  const mains = Array.from(doc.querySelectorAll('.main'));
  const gi = mains.find(d => /General Information/i.test(d.textContent||'')) || null;
  if(gi){
    const t = gi.textContent || '';
    out.date = (t.match(/Date:\s*([0-9]{2}-[0-9]{2}-[0-9]{4})/i)||[])[1] || '';
    out.time = (t.match(/Time:\s*([0-9]{2}:[0-9]{2}:[0-9]{2})/i)||[])[1] || '';
    out.coords = (t.match(/Combat coordinates:\s*([0-9]+:[0-9]+:[0-9]+)/i)||[])[1] || '';
    out.loot_m = parseNum((t.match(/Metal loot:\s*([\d\.,]+)/i)||[])[1]);
    out.loot_c = parseNum((t.match(/Crystal loot:\s*([\d\.,]+)/i)||[])[1]);
    out.loot_d = parseNum((t.match(/Deuterium loot:\s*([\d\.,]+)/i)||[])[1]);
    out.units_lost_a = parseNum((t.match(/Units attacker lost:\s*([\d\.,]+)/i)||[])[1]);
    out.units_lost_d = parseNum((t.match(/Units defender lost:\s*([\d\.,]+)/i)||[])[1]);
    out.df_m = parseNum((t.match(/Metal to debrisfield:\s*([\d\.,]+)/i)||[])[1]);
    out.df_c = parseNum((t.match(/Crystal to debrisfield:\s*([\d\.,]+)/i)||[])[1]);
    out.moon_chance = parseNum((t.match(/Moon chance:\s*([\d\.,]+)/i)||[])[1]);
  }
  return out;
}


// --- NoMoreAngel API-Reader: supporto output "Markdown Content" (es. r.jina.ai) ---
function isLikelyMarkdownNMA(text){
  if(!text) return false;
  const t = String(text);
  return /Markdown Content:/i.test(t) || /###\s+General Information:/i.test(t) || /API-Reader\s*=+/i.test(t);
}
function mdExtractSection(text, startRe, endRe){
  const mStart = text.search(startRe);
  if(mStart < 0) return '';
  const sub = text.slice(mStart);
  const mEnd = sub.search(endRe);
  return (mEnd>=0 ? sub.slice(0,mEnd) : sub);
}
function mdGetLineValue(md, labelRe){
  const m = md.match(labelRe);
  return m ? (m[1]||'').trim() : '';
}
function mdShipListFromTypeLine(typeLine){
  // Estrae i nomi nave/difesa in EN da una stringa "Type ...".
  const names = Object.keys(shipNameMapEN2IT).sort((a,b)=>b.length-a.length);
  const found = [];
  let s = ' ' + (typeLine||'') + ' ';
  for(const name of names){
    const re = new RegExp('(^|\\s)'+escapeRegExp(name)+'(\\s|$)','g');
    if(re.test(s)){
      // contiamo quante volte appare (di solito 1)
      re.lastIndex = 0;
      let match;
      while((match=re.exec(s))){
        found.push({name, idx: match.index});
      }
    }
  }
  found.sort((a,b)=>a.idx-b.idx);
  // dedup preservando ordine
  const out = [];
  const seen = new Set();
  for(const f of found){
    if(seen.has(f.name)) continue;
    seen.add(f.name);
    out.push(f.name);
  }
  return out;
}
function mdNumsFromCountLine(countLine){
  // estrae numeri con separatori (.) e ritorna array di int
  const nums = (countLine||'').match(/\d[\d\.]*/g) || [];
  return nums.map(parseNum);
}
function mdParseInitialFleets(md){
  const out = {attackers:{}, defenders:{}};
  const initial = mdExtractSection(md, /####\s*Initial:/i, /####\s*Round\s*1/i);
  if(!initial) return out;
  const chunks = initial.replace(/\r/g,' ').split(/(?=Attacker\s+\[|Defender\s+\[)/g).map(s=>s.trim()).filter(Boolean);
  for(const ch of chunks){
    const head = ch.match(/^(Attacker|Defender)\s+\[(\d+:\d+:\d+)\]\s+([^\[]+?)\s+\[([^\]]+)\]/i);
    if(!head) continue;
    const side = /defender/i.test(head[1]) ? 'defenders' : 'attackers';
    const coords = head[2];
    const name = head[3].trim();
    const tag  = head[4].trim();
    const typeLine = (ch.match(/\bType\s+([\s\S]*?)\s+Count\b/i) || [,''])[1];
    const countLine = (ch.match(/\bCount\s+([\s\S]*?)\s+Weapon\b/i) || [,''])[1];
    const types = mdShipListFromTypeLine(typeLine);
    const counts = mdNumsFromCountLine(countLine);
    if(!types.length || !counts.length) continue;
    if(!out[side][name]) out[side][name] = {tag, coords, ships:{}};
    for(let i=0;i<Math.min(types.length, counts.length);i++){
      const it = shipNameMapEN2IT[types[i]] || types[i];
      out[side][name].ships[it] = (out[side][name].ships[it]||0) + counts[i];
    }
  }
  return out;
}
function mdParseRound3(md){
  const out = {attackers:{}, defenders:{}};
  const r3 = mdExtractSection(md, /####\s*Round\s*3/i, /(####\s*Round\s*4|$)/i);
  if(!r3) return out;
  // Prendiamo solo la parte che contiene i blocchi "Attacker X ... Count ... Lost ..."
  const blocks = r3.replace(/\r/g,' ').split(/(?=Attacker\s+[A-Za-z0-9_]+?\s|Defender\s+[A-Za-z0-9_]+?\s)/g).map(s=>s.trim()).filter(Boolean);
  for(const b of blocks){
    const head = b.match(/^(Attacker|Defender)\s+([A-Za-z0-9_]+)\b/i);
    if(!head) continue;
    const side = /defender/i.test(head[1]) ? 'defenders' : 'attackers';
    const name = head[2].trim();
    const typeLine = (b.match(/\b([A-Z][A-Za-z ]+?)\s+Count\b/i) || [,''])[1]; // dopo nome, prima Count
    const countLine = (b.match(/\bCount\s+([\s\S]*?)\s+Lost\b/i) || [,''])[1];
    const lostLine = (b.match(/\bLost\s+([\s\S]*?)$/i) || [,''])[1];
    const types = mdShipListFromTypeLine(typeLine);
    const counts = mdNumsFromCountLine(countLine);
    const losts  = mdNumsFromCountLine(lostLine);
    if(!types.length || !counts.length) continue;
    if(!out[side][name]) out[side][name] = {ships:{}, lost:{}}; 
    for(let i=0;i<Math.min(types.length, counts.length);i++){
      const it = shipNameMapEN2IT[types[i]] || types[i];
      out[side][name].ships[it] = (out[side][name].ships[it]||0) + counts[i];
      out[side][name].lost[it]  = (out[side][name].lost[it]||0) + (losts[i]||0);
    }
  }
  return out;
}
function buildClassicCRTextFromNMAMarkdown(md){
  const gi = {
    date: mdGetLineValue(md, /Date:\s*([0-9\-]+)/i),
    time: mdGetLineValue(md, /Time:\s*([0-9:]+)/i),
    coords: mdGetLineValue(md, /Combat coordinates:\s*([0-9:]+)/i),
    lootM: parseNum(mdGetLineValue(md, /Metal loot:\s*([\d\.]+)/i)),
    lootC: parseNum(mdGetLineValue(md, /Crystal loot:\s*([\d\.]+)/i)),
    lootD: parseNum(mdGetLineValue(md, /Deuterium loot:\s*([\d\.]+)/i)),
    unitsLostA: parseNum(mdGetLineValue(md, /Units attacker lost:\s*([\d\.]+)/i)),
    unitsLostD: parseNum(mdGetLineValue(md, /Units defender lost:\s*([\d\.]+)/i)),
    dfM: parseNum(mdGetLineValue(md, /Metal to debrisfield:\s*([\d\.]+)/i)),
    dfC: parseNum(mdGetLineValue(md, /Crystal to debrisfield:\s*([\d\.]+)/i)),
    moonChance: mdGetLineValue(md, /Moon chance:\s*([0-9]+%?)/i),
  };
  const fleets0 = mdParseInitialFleets(md);
  const r3 = mdParseRound3(md);

  // calcola rimanenti e perdite totali (solo per attaccanti che troviamo)
  const afterA = {};
  for(const [name, data] of Object.entries(fleets0.attackers)){
    const initShips = data.ships || {};
    const round = r3.attackers[name];
    const shipsBefore = (round && round.ships) ? round.ships : {};
    const lostThis = (round && round.lost) ? round.lost : {};
    const rem = {};
    for(const [ship, cnt] of Object.entries(shipsBefore)){
      rem[ship] = Math.max(0, (cnt||0) - (lostThis[ship]||0));
    }
    // se round3 non ha quella nave ma era in init, assumiamo 0 rimasti? (conservativo)
    for(const ship of Object.keys(initShips)){
      if(rem[ship] == null) rem[ship] = 0;
    }
    afterA[name] = {tag: data.tag, rem, init:initShips};
  }
  const afterD = {};
  for(const [name, data] of Object.entries(fleets0.defenders)){
    const initShips = data.ships || {};
    const round = r3.defenders[name];
    const shipsBefore = (round && round.ships) ? round.ships : {};
    const lostThis = (round && round.lost) ? round.lost : {};
    const rem = {};
    for(const [ship, cnt] of Object.entries(shipsBefore)){
      rem[ship] = Math.max(0, (cnt||0) - (lostThis[ship]||0));
    }
    for(const ship of Object.keys(initShips)){
      if(rem[ship] == null) rem[ship] = 0;
    }
    afterD[name] = {tag: data.tag, rem, init:initShips};
  }

  // compone testo "stile OGame IT" compatibile col parser esistente
  let out = '';
  const dateStr = gi.date ? gi.date : '--';
  out += `Il ${dateStr} --:--:--, le seguenti flotte si scontrano in combattimento:\n\n\n`;
  for(const [name, data] of Object.entries(fleets0.attackers)){
    out += `Attaccante ${name} [${data.tag||''}]\n________________________________________________\n\n`;
    for(const [ship,cnt] of Object.entries(data.ships||{})){
      out += `${ship} ${fmt(cnt)}\n`;
    }
    out += `_________________________________________\n\n`;
  }
  for(const [name, data] of Object.entries(fleets0.defenders)){
    out += `Difensore ${name} [${data.tag||''}]\n________________________________________________\n\n`;
    for(const [ship,cnt] of Object.entries(data.ships||{})){
      out += `${ship} ${fmt(cnt)}\n`;
    }
    out += `_________________________________________\n\n`;
  }

  out += `\nDopo la battaglia...\n\n`;
  for(const [name, data] of Object.entries(afterA)){
    out += `Attaccante ${name} [${data.tag||''}]\n________________________________________________\n\n`;
    // mostra rimanenti e perdite (init - rem)
    for(const ship of Object.keys(data.init)){
      const init = data.init[ship]||0;
      const rem = data.rem[ship]||0;
      const lost = init - rem;
      out += `${ship} ${fmt(rem)} ( -${fmt(lost)} )\n`;
    }
    out += `_________________________________________\n\n`;
  }
  for(const [name, data] of Object.entries(afterD)){
    const allZero = Object.values(data.rem||{}).every(v => (v||0)===0);
    out += `Difensore ${name} [${data.tag||''}]\n________________________________________________\n\n`;
    if(allZero) out += `Distrutto!\n`;
    else{
      for(const ship of Object.keys(data.init)){
        const init = data.init[ship]||0;
        const rem = data.rem[ship]||0;
        const lost = init - rem;
        out += `${ship} ${fmt(rem)} ( -${fmt(lost)} )\n`;
      }
    }
    out += `_________________________________________\n\n`;
  }

  out += `\nL'attaccante ha vinto la battaglia!\n\n`;
  out += `L'attaccante saccheggia:\n${fmt(gi.lootM)} Metallo, ${fmt(gi.lootC)} Cristallo e ${fmt(gi.lootD)} Deuterio\n\n`;
  out += `L'attaccante ha perso un totale di ${fmt(gi.unitsLostA)} unità.\n`;
  out += `Il difensore ha perso un totale di ${fmt(gi.unitsLostD)} unità.\n`;
  if(gi.dfM || gi.dfC){
    out += `At these space coordinates now float ${fmt(gi.dfM)} metal, ${fmt(gi.dfC)} crystal and 0 deuterium.\n`;
  }
  if(gi.moonChance){
    out += `La possibilità che si formi una luna dai detriti era del ${gi.moonChance.replace('%','')}%.\n`;
  }
  return out.trim();
}

function buildClassicCRTextFromNMA(doc){
  const info = extractGeneralInfoFromNMA(doc);
  const attackersInit = {};
  const defendersInit = {};
  const attackersFinal = {};
  const defendersFinal = {};

  // Initial: header blocks are td.cr inside a "Combat Report" table
  const headerTds = Array.from(doc.querySelectorAll('td.cr'))
    .filter(td => /^(Attacker|Defender)\b/i.test((td.textContent||'').trim()) && /Weapon:/i.test(td.textContent||''));

  for(const td of headerTds){
    const meta = parseHeaderBlockText(td.textContent||'');
    if(!meta.name) continue;
    const outer = td.closest('table.cr');
    if(!outer) continue;
    const innerTables = Array.from(outer.querySelectorAll('table.cr'));
    const typeTable = innerTables.find(t => (t.textContent||'').includes('Type') && (t.textContent||'').includes('Count'));
    if(!typeTable) continue;
    const units = parseNmaTypeCountTable(typeTable);
    if(!units) continue;
    const bucket = /^Defender/i.test(meta.role) ? defendersInit : attackersInit;
    if(!bucket[meta.name]) bucket[meta.name] = {tag: meta.tag, coords: meta.coords, units: {}};
    for(const [k,v] of Object.entries(units)) bucket[meta.name].units[k] = (bucket[meta.name].units[k]||0) + v;
  }

  // Final: Round 3 blocks have "Attacker Name" and a Count row (remaining)
  const roundHeaders = Array.from(doc.querySelectorAll('td.cr'))
    .filter(td => /^(Attacker|Defender)\s+\S+/i.test((td.textContent||'').trim()) && !/Weapon:/i.test(td.textContent||''));

  for(const td of roundHeaders){
    const txt = (td.textContent||'').trim();
    const m = txt.match(/^(Attacker|Defender)\s+(.+)$/i);
    if(!m) continue;
    const role = m[1];
    const name = m[2].trim();
    const outer = td.closest('table.cr');
    if(!outer) continue;
    const typeTable = Array.from(outer.querySelectorAll('table.cr'))
      .find(t => (t.textContent||'').includes('Type') && (t.textContent||'').includes('Count'));
    if(!typeTable) continue;
    const units = parseNmaTypeCountTable(typeTable);
    if(!units) continue;
    const bucket = /^Defender/i.test(role) ? defendersFinal : attackersFinal;
    if(!bucket[name]) bucket[name] = {units: {}};
    for(const [k,v] of Object.entries(units)) bucket[name].units[k] = (bucket[name].units[k]||0) + v;
  }

  // --- Compose classic text ---
  const date = info.date || '--/--/----';
  const header = `Il ${date} --:--:--, le seguenti flotte si scontrano in combattimento:`;

  function fmtDot(n){
    return (n||0).toLocaleString('it-IT');
  }
  function block(roleIt, name, tag, unitMap){
    const lines = [];
    lines.push(`${roleIt} ${name}${tag ? ' ['+tag+']' : ''}`);
    lines.push(`________________________________________________`);
    const entries = Object.entries(unitMap||{}).filter(([,v]) => v && v>0);
    // stable-ish order: keep common ships first
    const order = [
      'Cargo leggero','Cargo Pesante','Caccia Leggero','Caccia Pesante','Incrociatore','Nave da battaglia','Colonizzatrice','Riciclatrice','Sonda spia','Bombardiere','Satellite Solare','Corazzata','Morte Nera','Incrociatore da Battaglia','Crawler','Reaper','Pathfinder',
      'Lanciamissili','Laser leggero','Laser pesante','Cannone Gauss','Cannone ionico','Cannone al Plasma','Cupola scudo piccola','Cupola scudo potenziata'
    ];
    const idx = new Map(order.map((k,i)=>[k,i]));
    entries.sort((a,b)=> (idx.get(a[0])??999) - (idx.get(b[0])??999) || a[0].localeCompare(b[0]));
    for(const [k,v] of entries){
      lines.push(`${k} ${fmtDot(v)}`);
    }
    lines.push(`_________________________________________`);
    return lines.join('\n');
  }

  function blockAfter(roleIt, name, tag, initUnits, finalUnits){
    const lines = [];
    lines.push(`${roleIt} ${name}${tag ? ' ['+tag+']' : ''}`);
    lines.push(`________________________________________________`);
    const keys = new Set([...Object.keys(initUnits||{}), ...Object.keys(finalUnits||{})]);
    const entries = Array.from(keys).map(k => {
      const ini = initUnits?.[k]||0;
      const fin = finalUnits?.[k]||0;
      return [k, fin, ini-fin];
    }).filter(([,fin,loss]) => fin>0 || loss>0);
    const order = [
      'Cargo leggero','Cargo Pesante','Caccia Leggero','Caccia Pesante','Incrociatore','Nave da battaglia','Colonizzatrice','Riciclatrice','Sonda spia','Bombardiere','Satellite Solare','Corazzata','Morte Nera','Incrociatore da Battaglia','Crawler','Reaper','Pathfinder',
      'Lanciamissili','Laser leggero','Laser pesante','Cannone Gauss','Cannone ionico','Cannone al Plasma','Cupola scudo piccola','Cupola scudo potenziata'
    ];
    const idx = new Map(order.map((k,i)=>[k,i]));
    entries.sort((a,b)=> (idx.get(a[0])??999) - (idx.get(b[0])??999) || a[0].localeCompare(b[0]));
    for(const [k,fin,loss] of entries){
      lines.push(`${k} ${fmtDot(fin)} ( -${fmtDot(loss)} )`);
    }
    lines.push(`_________________________________________`);
    return lines.join('\n');
  }

  const aBlocks = Object.entries(attackersInit).map(([name,infoA]) => block('Attaccante', name, infoA.tag, infoA.units));
  const dBlocks = Object.entries(defendersInit).map(([name,infoD]) => block('Difensore', name, infoD.tag, infoD.units));

  const afterA = Object.entries(attackersInit).map(([name,infoA]) => {
    const fin = attackersFinal[name]?.units || {};
    return blockAfter('Attaccante', name, infoA.tag, infoA.units, fin);
  });
  const afterD = Object.entries(defendersInit).map(([name,infoD]) => {
    const fin = defendersFinal[name]?.units || {};
    const any = Object.values(fin).some(v => v>0);
    if(!any) {
      return `Difensore ${name}${infoD.tag ? ' ['+infoD.tag+']' : ''}\n________________________________________________\nDistrutto!\n_________________________________________`;
    }
    return blockAfter('Difensore', name, infoD.tag, infoD.units, fin);
  });

  const tail = [];
  if(info.loot_m || info.loot_c || info.loot_d){
    tail.push('');
    tail.push(`L'attaccante saccheggia:`);
    tail.push(`${fmtDot(info.loot_m)} Metallo, ${fmtDot(info.loot_c)} Cristallo e ${fmtDot(info.loot_d)} Deuterio`);
  }
  if(info.units_lost_a){
    tail.push('');
    tail.push(`L'attaccante ha perso un totale di ${fmtDot(info.units_lost_a)} unità.`);
  }
  if(info.units_lost_d){
    tail.push(`Il difensore ha perso un totale di ${fmtDot(info.units_lost_d)} unità.`);
  }
  if(info.df_m || info.df_c){
    tail.push(`At these space coordinates now float ${fmtDot(info.df_m)} metal, ${fmtDot(info.df_c)} crystal and 0 deuterium.`);
  }
  if(info.moon_chance){
    tail.push(`La possibilità che si formi una luna dai detriti era del ${fmtDot(info.moon_chance)}%.`);
  }

  return cleanupText([
    header,
    '',
    ...aBlocks,
    '',
    ...dBlocks,
    '',
    'Dopo la battaglia...',
    '',
    ...afterA,
    '',
    ...afterD,
    ...tail
  ].join('\n'));
}

document.getElementById('btnLoadCRApi')?.addEventListener('click', async () => {
  const apiId = (document.getElementById('crApiId').value || '').trim();
  if(!apiId){
    toast('Inserisci un API ID CR.', 'error');
    return;
  }
  const timeoutMs = parseNum(document.getElementById('timeoutMs')?.value) || 12000;
  const url = /^https?:\/\//i.test(apiId)
    ? apiId
    : `https://nomoreangel.de/api-reader/?apiid=${encodeURIComponent(apiId)}&engOut=on`;
  log(`CR API: richiesta NoMoreAngel... (${url})`);
  try{
    const raw = await fetchTextWithFallback(url, timeoutMs);
    const html = normalizeHTMLFromJina(raw);
    const preview = html.slice(0, 8000);
    const preEl = document.getElementById('crApiRaw');
    if(preEl) preEl.textContent = preview;
    let text = null;
    // Alcuni proxy (es. r.jina.ai) restituiscono "Markdown Content" invece dell'HTML originale
    if(isLikelyMarkdownNMA(htmlRaw) || isLikelyMarkdownNMA(html)){
      text = buildClassicCRTextFromNMAMarkdown(htmlRaw || html);
    } else {
      const doc = new DOMParser().parseFromString(html, 'text/html');
      text = buildClassicCRTextFromNMA(doc);
      // fallback: se l'HTML è stato "spogliato" e sembra markdown, prova parser markdown
      if((!text || text.length < 200) && isLikelyMarkdownNMA(htmlRaw)){
        text = buildClassicCRTextFromNMAMarkdown(htmlRaw);
      }
    }
    if(!text || text.length < 200){
      throw new Error("Conversione ricevuta, ma non riesco a costruire il CR testo.");
    }
    document.getElementById('crText').value = text;
    log(`✅ CR convertito da NoMoreAngel (lunghezza: ${text.length}). Ora analizzo...`);
    const cr = parseCRText(text);
    STATE.cr = cr;
    renderKPI(cr);
    recomputeAndRender();
    setTab('risultati');
  }catch(e){
    log('❌ Errore CR API: ' + (e?.message || e));
    console.error(e);
    setTab('log');
  }
});

// -------- RR LOADER (API) --------
function abortableFetch(url, timeoutMs) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeoutMs);
  return fetch(url, {signal: controller.signal}).finally(() => clearTimeout(id));
}

function extractPre(html) {
  const m = html.match(/<pre[^>]*>([\s\S]*?)<\/pre>/i);
  if (!m) return null;
  const txt = m[1]
    .replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&amp;/g,'&')
    .replace(/&#039;/g,"'").replace(/&quot;/g,'"');
  return txt;
}

function parseRRFromPre(pre) {
  // regex extraction from stdClass print_r
  const owner = (pre.match(/\[owner_name\]\s*=>\s*([^\r\n]+)/) || [])[1];
  if (!owner) return null;
  const m = parseNum((pre.match(/\[metal_retrieved\]\s*=>\s*([\d\.,]+)/) || [])[1]);
  const c = parseNum((pre.match(/\[crystal_retrieved\]\s*=>\s*([\d\.,]+)/) || [])[1]);
  const d = parseNum((pre.match(/\[deuterium_retrieved\]\s*=>\s*([\d\.,]+)/) || [])[1]);
  const coords = (pre.match(/\[coordinates\]\s*=>\s*([^\r\n]+)/) || [])[1] || '';
  const rrid = (pre.match(/\[rr_id\]\s*=>\s*([^\r\n]+)/) || [])[1] || '';
  return {owner: owner.trim(), m, c, d, coords: coords.trim(), rrid: rrid.trim()};
}

document.getElementById('btnLoadRR').addEventListener('click', async () => {
  const base = (document.getElementById('proxyBase').value || '').trim();
  const timeoutMs = parseNum(document.getElementById('timeoutMs').value) || 12000;
  const ids = (document.getElementById('rrIds').value || '').split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  if (!ids.length) {
    log("⚠️ Nessun RR apiid inserito.");
    return;
  }
  log(`Carico ${ids.length} RR...`);
  const rawLog = [];
  for (const id of ids) {
    const url = base + encodeURIComponent(id);
    try {
      const res = await abortableFetch(url, timeoutMs);
      const text = await res.text();
      rawLog.push(`--- ${id} status=${res.status} ok=${res.ok} url=${url} ---\n` + text.slice(0,1200));
      const pre = extractPre(text) || text;
      const parsed = parseRRFromPre(pre);
      if (!parsed) {
        log(`❌ RR non parsato: ${id} (owner_name non trovato)`);
        continue;
      }
      const p = parsed.owner;
      if (!STATE.rr[p]) STATE.rr[p] = {m:0,c:0,d:0,count:0, list:[]};
      STATE.rr[p].m += parsed.m;
      STATE.rr[p].c += parsed.c;
      STATE.rr[p].d += parsed.d;
      STATE.rr[p].count += 1;
      STATE.rr[p].list.push(parsed);
      log(`✅ RR: ${p} +${fmt(parsed.m)}M +${fmt(parsed.c)}C +${fmt(parsed.d)}D (${parsed.coords})`);
    } catch (e) {
      log(`❌ Errore fetch RR ${id}: ${e?.message || e}`);
    }
  }
  document.getElementById('rrRaw').textContent = rawLog.join("\n\n");
  renderRRTable(STATE.rr);
  recomputeAndRender();
  setTab('risultati');
});

document.getElementById('btnClearRR').addEventListener('click', () => {
  STATE.rr = {};
  document.getElementById('rrRaw').textContent = '';
  renderRRTable(STATE.rr);
  recomputeAndRender();
  log("RR puliti.");
});

// ----------------- Condivisione (link con stato) -----------------
function encodeShareState(obj){
  // base64(url-safe) di JSON UTF-8
  const json = JSON.stringify(obj);
  const b64 = btoa(unescape(encodeURIComponent(json)))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/g, '');
  return b64;
}
function decodeShareState(b64){
  const pad = '==='.slice((b64.length + 3) % 4);
  const s = (b64 + pad).replace(/-/g, '+').replace(/_/g, '/');
  const json = decodeURIComponent(escape(atob(s)));
  return JSON.parse(json);
}
function collectShareState(){
  return {
    v: 1,
    crText: (document.getElementById('crText').value || '').trim(),
    proxyBase: (document.getElementById('proxyBase').value || '').trim(),
    timeoutMs: parseNum(document.getElementById('timeoutMs').value) || 12000,
    rrIds: (document.getElementById('rrIds').value || '').trim(),
    // per comodità: se hai già caricato RR, includiamo anche il totale per player
    rrTotals: STATE.rr || {},
  };
}
function applyShareState(st){
  if (!st || typeof st !== 'object') return;
  if (typeof st.proxyBase === 'string' && st.proxyBase.trim()) document.getElementById('proxyBase').value = st.proxyBase.trim();
  if (st.timeoutMs) document.getElementById('timeoutMs').value = String(st.timeoutMs);
  if (typeof st.rrIds === 'string') document.getElementById('rrIds').value = st.rrIds;
  if (typeof st.crText === 'string') document.getElementById('crText').value = st.crText;

  // Se abbiamo già totals, possiamo renderizzarli subito senza rifetch.
  if (st.rrTotals && typeof st.rrTotals === 'object' && Object.keys(st.rrTotals).length){
    STATE.rr = st.rrTotals;
    renderRRTable(STATE.rr);
  }
  // Analizza CR (se presente)
  if ((document.getElementById('crText').value || '').trim()) {
    try { parseCRText(); } catch(e){ log('Errore analisi CR da link: ' + (e?.message||e)); }
  }
  recomputeAndRender();
}
function shareLink(){
  const st = collectShareState();
  const token = encodeShareState(st);
  const url = `${location.origin}${location.pathname}#s=${token}`;
  return url;
}
async function doShare(){
  const url = shareLink();
  const title = 'Spartizione Detriti OGame';
  const text = 'Link con CR/RR precompilati';
  try {
    if (navigator.share) {
      await navigator.share({title, text, url});
      log('✅ Link condiviso.');
      return;
    }
  } catch (e) {
    // se l'utente annulla, non è un errore grave
  }
  try {
    await navigator.clipboard.writeText(url);
    log('✅ Link copiato negli appunti.');
  } catch (e) {
    // fallback
    prompt('Copia questo link:', url);
    log('ℹ️ Link mostrato in prompt (clipboard non disponibile).');
  }
}

document.getElementById('btnShare').addEventListener('click', () => {
  doShare();
});

// Carica stato da hash (se presente)
(() => {
  const m = (location.hash || '').match(/#s=([A-Za-z0-9\-_]+)/);
  if (!m) return;
  try {
    const st = decodeShareState(m[1]);
    applyShareState(st);
    setTab('cr');
    log('🔗 Stato caricato dal link.');
  } catch (e) {
    log('⚠️ Hash di condivisione non valido: ' + (e?.message || e));
  }
})();

// Initial
log("Pronto. 1) Incolla CR (testo) e Analizza. 2) Carica RR (API) per sommare raccolte. 3) Vedi Risultati.");
</script>
</body>
</html>
