<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Spartizione Detriti OGame - CR (testo) + RR (API)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800&family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root {
    /* OGame-ish palette */
    --bg:#050a10;
    --panel:#0b1320;
    --panel2:#07101b;
    --text:#dbe7ff;
    --muted:#93a6c7;
    --line:rgba(120,160,220,.25);
    --accent:#4da3ff;      /* orange */
    --accent2:#2dd4ff;     /* cyan */
    --good:#39d98a;
    --bad:#ff5c5c;
    --warn:#ff5c5c;
    --font-ui: "Rajdhani", system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial;
    --font-title: "Orbitron", "Rajdhani", system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:var(--font-ui);color:var(--text);background:var(--bg);}
  body::before{
    content:"";
    position:fixed;
    inset:0;
    z-index:-1;
    background:
      radial-gradient(1200px 700px at 15% -10%, rgba(124,240,255,.10), transparent 55%),
      radial-gradient(900px 600px at 110% 10%, rgba(255,179,77,.10), transparent 55%),
      radial-gradient(2px 2px at 20% 30%, rgba(255,255,255,.9), transparent 60%),
      radial-gradient(1px 1px at 40% 60%, rgba(255,255,255,.75), transparent 60%),
      radial-gradient(1px 1px at 70% 20%, rgba(255,255,255,.7), transparent 60%),
      radial-gradient(1px 1px at 85% 80%, rgba(255,255,255,.65), transparent 60%),
      radial-gradient(1px 1px at 10% 85%, rgba(255,255,255,.6), transparent 60%),
      radial-gradient(1px 1px at 95% 45%, rgba(255,255,255,.55), transparent 60%),
      linear-gradient(180deg, rgba(15,25,40,.65), rgba(5,10,16,1));
    filter:saturate(1.05) contrast(1.05);
  }
  header{position:sticky;top:0;z-index:5;background:linear-gradient(180deg, rgba(7,12,18,.92), rgba(7,12,18,.65));backdrop-filter:blur(10px);border-bottom:1px solid var(--line);}
  .wrap{max-width:1100px;margin:0 auto;padding:14px 14px;}
  .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px;}
  .title{display:flex;align-items:center;gap:10px;min-width:0;}
  .actions{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end;}
  .badge{font-size:12px;color:var(--muted);border:1px solid var(--line);padding:4px 8px;border-radius:999px;background:rgba(16,26,46,.6)}
  h1{font-family:var(--font-title);font-size:16px;margin:0;letter-spacing:.8px;text-transform:uppercase}
  .tabs{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
  .tabbtn{border:1px solid var(--line);background:rgba(16,26,46,.6);color:var(--text);padding:8px 10px;border-radius:10px;cursor:pointer}
  .tabbtn.active{border-color:rgba(242,169,0,.8);box-shadow:0 0 0 2px rgba(242,169,0,.18) inset;background:rgba(242,169,0,.07)}
  .grid{display:grid;grid-template-columns:1fr;gap:12px;margin-top:14px}
  @media (min-width: 980px){ .grid{grid-template-columns: 1fr 1fr;} }
  .card{border:1px solid var(--line);background:linear-gradient(180deg, rgba(16,26,46,.8), rgba(14,23,40,.75));border-radius:16px;padding:12px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .card h2{margin:0 0 8px 0;font-size:14px;color:var(--text)}
  textarea,input{width:100%;background:rgba(8,12,20,.65);border:1px solid var(--line);color:var(--text);border-radius:12px;padding:10px;font-size:13px;outline:none}
  textarea{min-height:240px;resize:vertical;line-height:1.25}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .row > *{flex:1}
  button{border:1px solid rgba(88,166,255,.65);background:rgba(88,166,255,.15);color:var(--text);
    padding:9px 12px;border-radius:12px;cursor:pointer;font-weight:600}
  button:hover{background:rgba(88,166,255,.22)}
  .ghost{border-color:var(--line);background:rgba(16,26,46,.5);font-weight:600}
  .ghost:hover{background:rgba(16,26,46,.75)}
  .mini{font-size:12px;color:var(--muted)}
  .pill{display:inline-flex;gap:8px;align-items:center;border:1px solid var(--line);border-radius:999px;padding:6px 10px;background:rgba(16,26,46,.5)}
  .pill input{width:auto}
  .kpi{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px}
  .kpi .box{border:1px solid var(--line);background:rgba(8,12,20,.35);border-radius:12px;padding:10px}
  .kpi .box .v{font-size:14px;font-weight:800}
  .kpi .box .l{font-size:12px;color:var(--muted)}
  table{width:100%;border-collapse:collapse;overflow:hidden;border-radius:12px;border:1px solid var(--line);background:rgba(8,12,20,.35)}
  th,td{padding:8px 8px;border-bottom:1px solid rgba(34,52,85,.6);font-size:12px;text-align:right}
  th{text-align:right;color:var(--muted);font-weight:700;background:rgba(16,26,46,.55)}
  th:first-child, td:first-child{text-align:left}
  tr:last-child td{border-bottom:none}
  .good{color:var(--good)}
  .bad{color:var(--bad)}
  .warn{color:var(--warn)}
  details{border:1px solid var(--line);border-radius:12px;padding:10px;background:rgba(8,12,20,.25)}
  summary{cursor:pointer;color:var(--muted);font-weight:700}
  pre{margin:0;white-space:pre-wrap;word-break:break-word;font-size:12px;color:#cfe0ff}

.ico{width:16px;height:16px;vertical-align:-3px;margin-right:8px;fill:currentColor;opacity:.9}

.advanced{display:none}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1>Spartizione Detriti OGame</h1>
        <span class="badge">CR testo + RR API • logica foglio di calcolo</span>
      </div>
      <div class="actions">
        <button class="ghost" id="btnShare" type="button" title="Copia un link con la configurazione"><svg class="ico" viewBox="0 0 24 24" aria-hidden="true"><path d="M18 16a3 3 0 0 0-2.24 1.02L8.91 13.7a3.2 3.2 0 0 0 0-3.4l6.85-3.32A3 3 0 1 0 15 5a2.98 2.98 0 0 0 .07.63L8.22 8.95A3 3 0 1 0 9 12a2.98 2.98 0 0 0-.07-.63l6.85 3.32A3 3 0 1 0 18 16Z"/></svg>Condividi</button>
      </div>
    </div>
    <div class="tabs">
      <button class="tabbtn active" data-tab="cr">CR (testo)</button>
      <button class="tabbtn" data-tab="rr">RR (API via nomoreangel/proxy)</button>
      <button class="tabbtn" data-tab="risultati">Risultati</button>
      <button class="tabbtn" data-tab="log">Log</button>
    </div>
  </div>
</header>

<div class="wrap">
  <div id="tab-cr" class="tab">
    <div class="grid">
      <div class="card">
        <h2>Incolla qui il Combat Report (formato classico IT/EN)</h2>
        
        <div class="row" style="margin-bottom:10px; gap:10px; align-items:flex-end">
          <div style="flex:1; min-width:240px">
            <label class="mini" for="crApiId">CR da API (NoMoreAngel)</label>
            <input id="crApiId" placeholder="cr-it-... oppure link NoMoreAngel" />
          </div>
          <button id="btnLoadCRApi" class="ghost" title="Carica e converte da NoMoreAngel (engOut)">Carica da API</button>
          <button id=\"btnLoadCRApiOgotcha\" class=\"ghost\" title=\"Prova a caricare il CR passando da OGotcha (se disponibile)\">Carica da OGotcha</button>
        </div>
<textarea id="crText" placeholder="Incolla il CR qui..."></textarea>
        <div class="row" style="margin-top:10px">
          <button id="btnParseCR">Analizza CR</button>
          <button id="btnCRDemo" class="ghost">Demo</button>
        </div>
        <div class="mini" style="margin-top:8px">
          Estrae: attaccanti, difensore, coordinate, loot, perdite, DF (float).
        </div>
      </div>

      <div class="card">
        <h2>Opzioni di spartizione</h2>
        <div class="row">
          <label class="pill"><input type="radio" name="mode" value="paritaria" checked> Paritaria</label>
          <label class="pill"><input type="radio" name="mode" value="equa"> Equa (peso flotta in campo)</label>
        </div>
        <div class="kpi" id="kpiCR"></div>

        <details style="margin-top:10px" open>
          <summary>Costi navi / difese (come foglio)</summary>
          <div class="mini" style="margin-top:8px">
            I calcoli usano questi costi base. Se il tuo universo ha costi diversi, dimmelo e li rendiamo editabili.
          </div>
          <div id="costsTable" style="margin-top:8px"></div>
        </details>
      </div>
    </div>
  </div>

  <div id="tab-rr" class="tab" style="display:none">
    <div class="grid">
      <div class="card">
        <h2>Carica RR tramite API ID</h2>
        <div class="row advanced">
          <div style="flex:2">
            <label class="mini">Proxy base URL</label>
            <input id="proxyBase" value="https://ogame-api-proxy.matiasquiroz87.workers.dev/?apiid=" />
          </div>
          <div>
            <label class="mini">Timeout (ms)</label>
            <input id="timeoutMs" value="12000" />
          </div>
        </div>
        <div style="margin-top:8px">
          <label class="mini">Inserisci uno o più RR apiid (uno per riga)</label>
          <textarea id="rrIds" placeholder="rr-it-269-...."></textarea>
        </div>
        <div class="row" style="margin-top:10px">
          <button id="btnLoadRR">Carica RR</button>
          <button id="btnClearRR" class="ghost">Pulisci</button>
        </div>
        <div class="mini" style="margin-top:8px">
          Il tool somma automaticamente le raccolte per giocatore (owner_name) e per risorsa.
        </div>
      </div>

      <div class="card">
        <h2>Raccolte lette</h2>
        <div id="rrTable"></div>
        <details style="margin-top:10px">
          <summary>Dettagli RR (debug)</summary>
          <pre id="rrRaw"></pre>
        </details>
      </div>
    </div>
  </div>

  <div id="tab-risultati" class="tab" style="display:none">
    <div class="card">
      <h2>Risultati (logica del foglio)</h2>
      <div class="mini">
        Formula (per risorsa): <b>quota = perdite_i + (gain_totale × peso_i) − raccolto_i</b><br/>
        dove <b>gain_totale = raccolto_totale − perdite_totali</b>. La somma delle quote = 0 (trasferimenti tra alleati).
      </div>
      <div style="margin-top:10px" id="resultsTables"></div>

      <details style="margin-top:12px" open>
        <summary>Trasporti finali suggeriti</summary>
        <div class="mini" style="margin-top:8px">
          Elenco di trasferimenti minimi tra chi deve inviare (negativo) e chi deve ricevere (positivo).
        </div>
        <div id="transports"></div>
      </details>
    </div>
  </div>

  <div id="tab-log" class="tab" style="display:none">
    <div class="card">
      <h2>Log</h2>
      <pre id="logBox"></pre>
    </div>
  </div>
</div>

<script>
const COSTS = {"Cargo leggero": [2000, 2000, 0], "Cargo Pesante": [6000, 6000, 0], "Caccia Leggero": [3000, 1000, 0], "Caccia Pesante": [6000, 4000, 0], "Incrociatore": [20000, 7000, 2000], "Nave da battaglia": [45000, 15000, 0], "Bombardiere": [50000, 25000, 15000], "Corazzata": [60000, 50000, 15000], "Incrociatore da Battaglia": [30000, 40000, 15000], "Reaper": [85000, 55000, 20000], "Pathfinder": [8000, 15000, 8000], "Riciclatrice": [10000, 6000, 2000], "Colonizzatrice": [10000, 20000, 10000], "Sonda spia": [0, 1000, 0], "Satellite Solare": [0, 2000, 500], "Crawler": [2000, 2000, 1000], "Morte Nera": [5000000, 4000000, 1000000], "Lanciamissili": [2000, 0, 0], "Laser leggero": [1500, 500, 0], "Laser pesante": [6000, 2000, 0], "Cannone Gauss": [20000, 15000, 2000], "Cannone ionico": [2000, 6000, 0], "Cannone al Plasma": [50000, 50000, 30000], "Cupola scudo piccola": [10000, 10000, 0], "Cupola scudo potenziata": [50000, 50000, 0]};

function fmt(n) {
  if (n === null || n === undefined || isNaN(n)) return '-';
  return Math.round(n).toLocaleString('it-IT');
}
function parseNum(str) {
  if (str === null || str === undefined) return 0;
  const s = String(str).replace(/\./g,'').replace(/,/g,'').replace(/\s+/g,'').trim();
  const n = Number(s);
  return isNaN(n) ? 0 : n;
}
const LOG = [];
function log(msg, level="info") {
  const t = new Date().toLocaleTimeString();
  const line = `[${t}] ${msg}`;
  LOG.push(line);
  const el = document.getElementById('logBox');
  if (el) el.textContent = LOG.join("\n");
}

function setTab(name) {
  document.querySelectorAll('.tabbtn').forEach(b => b.classList.toggle('active', b.dataset.tab===name));
  document.querySelectorAll('.tab').forEach(t => t.style.display = 'none');
  document.getElementById('tab-'+name).style.display = 'block';
}

document.querySelectorAll('.tabbtn').forEach(btn => btn.addEventListener('click', () => setTab(btn.dataset.tab)));

function renderCosts() {
  const rows = Object.entries(COSTS).map(([k,v]) => {
    const [m,c,d]=v;
    const g=m+c+d;
    return `<tr><td>${k}</td><td>${fmt(m)}</td><td>${fmt(c)}</td><td>${fmt(d)}</td><td>${fmt(g)}</td></tr>`;
  }).join('');
  document.getElementById('costsTable').innerHTML = `
    <table>
      <thead><tr><th>Unità</th><th>Metallo</th><th>Cristallo</th><th>Deuterio</th><th>Globale</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>`;
}
renderCosts();

// -------- CR PARSER (testo classico) --------
const STATE = {
  cr: null, // parsed CR
  rr: {}  // per player totals: {player: {m,c,d, list:[]}}
};

function parseCRText(text) {
  const out = {
    attackers: {}, // name -> {tag, initial{ship:count}, final{ship:count}}
    defenders: {},
    coords: null,
    loot: {m:0,c:0,d:0},
    df_float: {m:0,c:0,d:0},
    moonChance: null,
    lossesUnits: {att:0, def:0},
  };

  // coords + moon chance
  const coordM = text.match(/\b\[(\d+:\d+:\d+)\]|\b(\d+:\d+:\d+)\b/);
  if (coordM) out.coords = (coordM[1]||coordM[2]||null);

  const moonM = text.match(/possibilit[aà].*?luna.*?(\d+)%/i);
  if (moonM) out.moonChance = parseNum(moonM[1]);

  // losses units
  const attLost = text.match(/attaccante ha perso un totale di\s*([\d\.,]+)\s*unit/i);
  const defLost = text.match(/difensore ha perso un totale di\s*([\d\.,]+)\s*unit/i);
  if (attLost) out.lossesUnits.att = parseNum(attLost[1]);
  if (defLost) out.lossesUnits.def = parseNum(defLost[1]);

  // loot
  const lootM = text.match(/saccheggia:\s*([\d\.,]+)\s*Metallo,\s*([\d\.,]+)\s*Cristallo\s*e\s*([\d\.,]+)\s*Deuterio/i);
  if (lootM) {
    out.loot.m = parseNum(lootM[1]);
    out.loot.c = parseNum(lootM[2]);
    out.loot.d = parseNum(lootM[3]);
  }

  // debris float line (EN)
  const dfM = text.match(/now float\s*([\d\.,]+)\s*metal,\s*([\d\.,]+)\s*crystal\s*and\s*([\d\.,]+)\s*deuterium/i);
  if (dfM) {
    out.df_float.m = parseNum(dfM[1]);
    out.df_float.c = parseNum(dfM[2]);
    out.df_float.d = parseNum(dfM[3]);
  }

  // Split pre/post battle (robusto: "Dopo la battaglia..." può variare)
  let pre = text;
  let post = "";
  const idx = text.search(/\bDopo\s+la\s+battaglia\b/i);
  if (idx >= 0) {
    pre = text.slice(0, idx);
    post = text.slice(idx);
  }

  // Normalizza nomi navi/difese: alcune conversioni (es. NoMoreAngel)
  // possono restituire i nomi in inglese. Li riportiamo alle chiavi IT
  // usate dal tool (COSTS/tabelle), così le perdite vengono conteggiate.
  function normShipName(name){
    const key = (name || '').trim();
    return shipNameMapEN2IT[key] || key;
  }

  function parseSideBlocks(blockText, phase) {
    // phase: 'initial' or 'final'
    const lines = blockText.split(/\r?\n/);
    let current = null;
    let currentSide = null;
    for (let i=0;i<lines.length;i++) {
      const line = lines[i].trim();
      if (!line) continue;
      const h = line.match(/^(Attaccante|Difensore)\s+(.+?)\s+\[(.+?)\]\s*$/i);
      if (h) {
        currentSide = h[1].toLowerCase().startsWith('att') ? 'att' : 'def';
        const name = h[2].trim();
        const tag = h[3].trim();
        if (currentSide==='att') {
          if (!out.attackers[name]) out.attackers[name] = {tag, initial: {}, final: {}};
          out.attackers[name].tag = tag;
          current = out.attackers[name];
        } else {
          if (!out.defenders[name]) out.defenders[name] = {tag, initial: {}, final: {}};
          out.defenders[name].tag = tag;
          current = out.defenders[name];
        }
        continue;
      }
      if (!current) continue;
      if (line.startsWith('_')) continue;
      if (line.toLowerCase().includes('distrutto')) continue;

      // ship line: "Caccia Leggero 3.226.909 ( -xxx )"
      const m = line.match(/^(.+?)\s+([\d\.,]+)(?:\s*\(\s*-[\d\.,]+\s*\))?\s*$/);
      if (m) {
        const ship = normShipName(m[1]);
        const count = parseNum(m[2]);
        if (phase==='initial') current.initial[ship] = (current.initial[ship]||0) + count;
        else current.final[ship] = (current.final[ship]||0) + count;
      }
    }
  }

  parseSideBlocks(pre, 'initial');
  if (post) parseSideBlocks(post, 'final');

  // Ensure final exists: if missing post, copy initial
  Object.values(out.attackers).forEach(p => {
    if (!p.final || Object.keys(p.final).length===0) p.final = JSON.parse(JSON.stringify(p.initial));
  });

  return out;
}

function computeFromSheetLogic(cr, rrTotals, mode) {
  const players = Object.keys(cr.attackers);
  const n = players.length || 1;

  // 1) losses per player by ship diffs
  const losses = {};
  const fleetValue = {};
  players.forEach(name => {
    const p = cr.attackers[name];
    losses[name] = {m:0,c:0,d:0, units:0};
    fleetValue[name] = 0;
    // Fleet in campo (initial) value
    for (const [ship, cnt] of Object.entries(p.initial)) {
      const cost = COSTS[ship];
      if (cost) {
        const g = (cost[0]+cost[1]+cost[2]) * cnt;
        fleetValue[name] += g;
      }
    }
    // losses
    const ships = new Set([...Object.keys(p.initial), ...Object.keys(p.final)]);
    ships.forEach(ship => {
      const ini = p.initial[ship] || 0;
      const fin = p.final[ship] || 0;
      const lostCnt = Math.max(0, ini - fin);
      if (lostCnt<=0) return;
      losses[name].units += lostCnt;
      const cost = COSTS[ship];
      if (!cost) return; // ignore unknown ships
      losses[name].m += cost[0] * lostCnt;
      losses[name].c += cost[1] * lostCnt;
      losses[name].d += cost[2] * lostCnt;
    });
  });

  const totLoss = players.reduce((a,nm)=>({
    m:a.m+losses[nm].m, c:a.c+losses[nm].c, d:a.d+losses[nm].d
  }), {m:0,c:0,d:0});

  // 2) total recycled from RR
  const totRec = players.reduce((a,nm)=>{
    const r = rrTotals[nm] || {m:0,c:0,d:0};
    return {m:a.m+r.m, c:a.c+r.c, d:a.d+r.d};
  }, {m:0,c:0,d:0});

  // 3) gain = recycled - losses (per resource)
  const gain = {m: totRec.m - totLoss.m, c: totRec.c - totLoss.c, d: totRec.d - totLoss.d};

  // 4) weights
  const weights = {};
  if (mode === 'paritaria') {
    players.forEach(nm => weights[nm] = 1/n);
  } else {
    const totFleet = players.reduce((s,nm)=> s + (fleetValue[nm]||0), 0) || 1;
    players.forEach(nm => weights[nm] = (fleetValue[nm]||0)/totFleet);
  }

  // 5) quota (= due): losses + gain*weight - collected
  const quota = {};
  players.forEach(nm => {
    const r = rrTotals[nm] || {m:0,c:0,d:0};
    quota[nm] = {
      m: losses[nm].m + gain.m * weights[nm] - r.m,
      c: losses[nm].c + gain.c * weights[nm] - r.c,
      d: losses[nm].d + gain.d * weights[nm] - r.d,
      w: weights[nm],
      fleet: fleetValue[nm],
      lost: losses[nm],
      rec: r
    };
  });

  return {players, losses, fleetValue, weights, totLoss, totRec, gain, quota};
}

function buildTransfers(players, quota, resKey) {
  const recv = [];
  const send = [];
  players.forEach(p => {
    const v = quota[p][resKey];
    if (v > 0.5) recv.push([p, v]);
    else if (v < -0.5) send.push([p, -v]);
  });
  recv.sort((a,b)=>b[1]-a[1]);
  send.sort((a,b)=>b[1]-a[1]);
  const moves = [];
  let i=0,j=0;
  while (i<send.length && j<recv.length) {
    const [sp, sv] = send[i];
    const [rp, rv] = recv[j];
    const x = Math.min(sv, rv);
    if (x>0.5) moves.push({from: sp, to: rp, amount: x});
    send[i][1] -= x;
    recv[j][1] -= x;
    if (send[i][1] <= 0.5) i++;
    if (recv[j][1] <= 0.5) j++;
  }
  return moves;
}

function renderKPI(cr) {
  const el = document.getElementById('kpiCR');
  if (!cr) { el.innerHTML = ""; return; }
  const attackers = Object.keys(cr.attackers).length;
  const defenders = Object.keys(cr.defenders).length;
  el.innerHTML = `
    <div class="box"><div class="v">${cr.coords || '-'}</div><div class="l">Coordinate</div></div>
    <div class="box"><div class="v">${attackers} / ${defenders}</div><div class="l">Attaccanti / Difensori</div></div>
    <div class="box"><div class="v">${cr.moonChance!==null ? (cr.moonChance+'%') : '-'}</div><div class="l">Chance Luna</div></div>
    <div class="box"><div class="v">${fmt(cr.df_float.m)}</div><div class="l">DF float M</div></div>
    <div class="box"><div class="v">${fmt(cr.df_float.c)}</div><div class="l">DF float C</div></div>
    <div class="box"><div class="v">${fmt(cr.df_float.d)}</div><div class="l">DF float D</div></div>
  `;
}

function renderRRTable(rrTotals) {
  const entries = Object.entries(rrTotals);
  if (entries.length===0) {
    document.getElementById('rrTable').innerHTML = '<div class="mini">Nessun RR caricato.</div>';
    return;
  }
  const rows = entries.map(([p,v]) => `
    <tr><td>${p}</td><td>${fmt(v.m)}</td><td>${fmt(v.c)}</td><td>${fmt(v.d)}</td><td>${v.count||0}</td></tr>
  `).join('');
  document.getElementById('rrTable').innerHTML = `
    <table>
      <thead><tr><th>Giocatore</th><th>Metallo</th><th>Cristallo</th><th>Deuterio</th><th>RR</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>`;
}

function renderResults(computed) {
  const {players, totLoss, totRec, gain, quota} = computed;

  const header = `
    <div class="kpi">
      <div class="box"><div class="v">${fmt(totRec.m)} / ${fmt(totRec.c)} / ${fmt(totRec.d)}</div><div class="l">Riciclato totale (M/C/D)</div></div>
      <div class="box"><div class="v">${fmt(totLoss.m)} / ${fmt(totLoss.c)} / ${fmt(totLoss.d)}</div><div class="l">Perdite totali (M/C/D)</div></div>
      <div class="box"><div class="v">${fmt(gain.m)} / ${fmt(gain.c)} / ${fmt(gain.d)}</div><div class="l">Gain da dividere (M/C/D)</div></div>
    </div>`;

  const rows = players.map(p => {
    const q = quota[p];
    const mClass = q.m>=0 ? 'good':'bad';
    const cClass = q.c>=0 ? 'good':'bad';
    const dClass = q.d>=0 ? 'good':'bad';
    return `
      <tr>
        <td>${p} <span class="mini">[${(q.w*100).toFixed(2)}%]</span></td>
        <td>${fmt(q.lost.m)}</td><td>${fmt(q.lost.c)}</td><td>${fmt(q.lost.d)}</td>
        <td>${fmt(q.rec.m)}</td><td>${fmt(q.rec.c)}</td><td>${fmt(q.rec.d)}</td>
        <td class="${mClass}">${fmt(q.m)}</td>
        <td class="${cClass}">${fmt(q.c)}</td>
        <td class="${dClass}">${fmt(q.d)}</td>
      </tr>`;
  }).join('');

  const table = `
    <table style="margin-top:10px">
      <thead>
        <tr>
          <th>Giocatore</th>
          <th>Perse M</th><th>Perse C</th><th>Perse D</th>
          <th>Raccolto M</th><th>Raccolto C</th><th>Raccolto D</th>
          <th>Quota M</th><th>Quota C</th><th>Quota D</th>
        </tr>
      </thead>
      <tbody>${rows}</tbody>
    </table>
    <div class="mini" style="margin-top:8px">
      Quota positiva = deve ricevere. Quota negativa = deve inviare.
    </div>`;

  document.getElementById('resultsTables').innerHTML = header + table;

  // transports
  const mt = buildTransfers(players, quota, 'm');
  const ct = buildTransfers(players, quota, 'c');
  const dt = buildTransfers(players, quota, 'd');

  function renderMoveList(label, moves) {
    if (!moves.length) return `<div class="mini">Nessun trasferimento per ${label} (già bilanciato).</div>`;
    const r = moves.map(m => `<tr><td>${m.from}</td><td>${m.to}</td><td>${fmt(m.amount)}</td></tr>`).join('');
    return `
      <div style="margin-top:10px">
        <div class="mini" style="margin:6px 0"><b>${label}</b></div>
        <table>
          <thead><tr><th>Da</th><th>A</th><th>Quantità</th></tr></thead>
          <tbody>${r}</tbody>
        </table>
      </div>`;
  }
  document.getElementById('transports').innerHTML =
    renderMoveList('Metallo', mt) + renderMoveList('Cristallo', ct) + renderMoveList('Deuterio', dt);
}

function recomputeAndRender() {
  if (!STATE.cr) {
    log("⚠️ Nessun CR caricato.");
    return;
  }
  const mode = document.querySelector('input[name="mode"]:checked')?.value || 'paritaria';
  const rrTotals = STATE.rr || {};
  const computed = computeFromSheetLogic(STATE.cr, rrTotals, mode);
  renderResults(computed);
}

document.querySelectorAll('input[name="mode"]').forEach(r => r.addEventListener('change', () => {
  log("Modalità: " + document.querySelector('input[name="mode"]:checked').value);
  recomputeAndRender();
}));

document.getElementById('btnParseCR').addEventListener('click', () => {
  try {
    const text = document.getElementById('crText').value || '';
    const cr = parseCRText(text);
    STATE.cr = cr;
    renderKPI(cr);
    log(`✅ CR caricato. Attaccanti: ${Object.keys(cr.attackers).length} • Difensori: ${Object.keys(cr.defenders).length} • Coord: ${cr.coords||'-'}`);
    recomputeAndRender();
    setTab('risultati');
  } catch (e) {
    log("❌ Errore parsing CR: " + (e?.message || e));
    console.error(e);
    setTab('log');
  }
});

document.getElementById('btnCRDemo').addEventListener('click', () => {
  const demo = `Il 28-01-2026 --:--:--, le seguenti flotte si scontrano in combattimento:

Attaccante Abubu [U E]
________________________________________________
Cargo Pesante 1
Caccia Leggero 3.226.909
Caccia Pesante 177.230
Incrociatore 557.550
Nave da battaglia 151.773
Corazzata 89.802
Incrociatore da Battaglia 462.085
Reaper 129.700
Pathfinder 96.320
_________________________________________

Difensore Bartok [SoV]
________________________________________________
Cargo leggero 515.205
Cargo Pesante 96.004
Caccia Leggero 487.861
_________________________________________

Dopo la battaglia...

Attaccante Abubu [U E]
________________________________________________
Cargo Pesante 1 ( -0 )
Caccia Leggero 2.961.733 ( -265.176 )
Caccia Pesante 167.384 ( -9.846 )
Incrociatore 544.263 ( -13.287 )
Nave da battaglia 150.566 ( -1.207 )
Corazzata 89.649 ( -153 )
Incrociatore da Battaglia 459.127 ( -2.958 )
Reaper 129.496 ( -204 )
Pathfinder 93.760 ( -2.560 )
_________________________________________

Difensore Bartok [SoV]
________________________________________________
Distrutto!
_________________________________________

L'attaccante saccheggia:
471.166.157 Metallo, 125.714.491 Cristallo e 21.863.628 Deuterio

L'attaccante ha perso un totale di 6.842.469.000 unità.
Il difensore ha perso un totale di 66.020.471.000 unità.
At these space coordinates now float 8.451.301.052 metal, 6.135.502.953 crystal and 1.725.266.027 deuterium.
La possibilità che si formi una luna dai detriti era del 22%.`;
  document.getElementById('crText').value = demo;
  log("Demo CR inserito.");
});

// -------- RR LOADER (API) --------
function abortableFetch(url, timeoutMs) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeoutMs);
  return fetch(url, {signal: controller.signal}).finally(() => clearTimeout(id));
}

function extractPre(html) {
  const m = html.match(/<pre[^>]*>([\s\S]*?)<\/pre>/i);
  if (!m) return null;
  const txt = m[1]
    .replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&amp;/g,'&')
    .replace(/&#039;/g,"'").replace(/&quot;/g,'"');
  return txt;
}

function parseRRFromPre(pre) {
  // regex extraction from stdClass print_r
  const owner = (pre.match(/\[owner_name\]\s*=>\s*([^\r\n]+)/) || [])[1];
  if (!owner) return null;
  const m = parseNum((pre.match(/\[metal_retrieved\]\s*=>\s*([\d\.,]+)/) || [])[1]);
  const c = parseNum((pre.match(/\[crystal_retrieved\]\s*=>\s*([\d\.,]+)/) || [])[1]);
  const d = parseNum((pre.match(/\[deuterium_retrieved\]\s*=>\s*([\d\.,]+)/) || [])[1]);
  const coords = (pre.match(/\[coordinates\]\s*=>\s*([^\r\n]+)/) || [])[1] || '';
  const rrid = (pre.match(/\[rr_id\]\s*=>\s*([^\r\n]+)/) || [])[1] || '';
  return {owner: owner.trim(), m, c, d, coords: coords.trim(), rrid: rrid.trim()};
}

document.getElementById('btnLoadRR').addEventListener('click', async () => {
  const base = (document.getElementById('proxyBase').value || '').trim();
  const timeoutMs = parseNum(document.getElementById('timeoutMs').value) || 12000;
  const ids = (document.getElementById('rrIds').value || '').split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  if (!ids.length) {
    log("⚠️ Nessun RR apiid inserito.");
    return;
  }
  log(`Carico ${ids.length} RR...`);
  const rawLog = [];
  for (const id of ids) {
    const url = base + encodeURIComponent(id);
    try {
      const res = await abortableFetch(url, timeoutMs);
      const text = await res.text();
      rawLog.push(`--- ${id} status=${res.status} ok=${res.ok} url=${url} ---\n` + text.slice(0,1200));
      const pre = extractPre(text) || text;
      const parsed = parseRRFromPre(pre);
      if (!parsed) {
        log(`❌ RR non parsato: ${id} (owner_name non trovato)`);
        continue;
      }
      const p = parsed.owner;
      if (!STATE.rr[p]) STATE.rr[p] = {m:0,c:0,d:0,count:0, list:[]};
      STATE.rr[p].m += parsed.m;
      STATE.rr[p].c += parsed.c;
      STATE.rr[p].d += parsed.d;
      STATE.rr[p].count += 1;
      STATE.rr[p].list.push(parsed);
      log(`✅ RR: ${p} +${fmt(parsed.m)}M +${fmt(parsed.c)}C +${fmt(parsed.d)}D (${parsed.coords})`);
    } catch (e) {
      log(`❌ Errore fetch RR ${id}: ${e?.message || e}`);
    }
  }
  document.getElementById('rrRaw').textContent = rawLog.join("\n\n");
  renderRRTable(STATE.rr);
  recomputeAndRender();
  setTab('risultati');
});

// ----------------- CR da API (NoMoreAngel) -----------------
async function fetchTextWithFallback(url, timeoutMs=12000){
  // 1) direct
  try{
    const res = await abortableFetch(url, timeoutMs);
    if(!res.ok) throw new Error('HTTP '+res.status);
    return await res.text();
  }catch(e1){
    // 2) Jina AI text proxy (bypasses CORS on many sites)
    const jinaUrl = "https://r.jina.ai/https://" + url.replace(/^https:\/\//,'');
    const res = await abortableFetch(jinaUrl, timeoutMs);
    if(!res.ok) throw new Error('HTTP '+res.status);
    return await res.text();
  }
}

function normalizeHTMLFromJina(text){
  const idx = text.search(/<!DOCTYPE html>|<html[\s>]/i);
  if(idx >= 0) return text.slice(idx);
  return text;
}

function extractMarkdownWrapper(raw){
  // supporto output "Title/URL/Markdown Content:" (es. r.jina.ai)
  const m = String(raw||'').match(/Markdown Content:\s*([\s\S]*)$/i);
  return m ? m[1].trim() : null;
}

function parseInitialBlocksFromMarkdown(md){
  // ritorna array di blocchi {side:'attacker'|'defender', name, tag, coords, typeLine, countLine}
  const blocks = [];
  const reHeader = /(Attacker|Defender)\s+\[([0-9:]+)\]\s+([^\[]+?)\s+\[([^\]]+)\]/g;
  let m;
  while((m = reHeader.exec(md)) !== null){
    blocks.push({side: m[1].toLowerCase(), coords:m[2], name:m[3].trim(), tag:m[4].trim(), start:m.index, end: null});
  }
  for(let i=0;i<blocks.length;i++){
    blocks[i].end = (i+1<blocks.length) ? blocks[i+1].start : md.length;
    blocks[i].chunk = md.slice(blocks[i].start, blocks[i].end);
  }
  return blocks;
}

function parseTypeCountPairs(chunk){
  // estrae "Type ... Count ..." (iniziale) e ritorna mappa EN->count
  const out = {};
  const typeIdx = chunk.indexOf('Type');
  const countIdx = chunk.indexOf('Count', typeIdx>=0?typeIdx:0);
  if(typeIdx<0 || countIdx<0) return out;
  // prendiamo stringhe tra "Type" e "Count", e tra "Count" e "Weapon"/"Shield"/"Armor" o fine
  const afterType = chunk.slice(typeIdx + 4, countIdx).trim();
  const afterCountAll = chunk.slice(countIdx + 5);
  const stop = afterCountAll.search(/\bWeapon\b|\bShield\b|\bArmor\b|\bAttacker\b\s+\[|\bDefender\b\s+\[|####\s+Round/i);
  const afterCount = (stop>=0 ? afterCountAll.slice(0, stop) : afterCountAll).trim();
  // tokenizziamo: ship names sono parole con iniziale maiuscola + eventuale spazio (es "Light Fighter")
  // per semplicità: split by two+ spaces oppure numeri
  const shipNames = afterType.split(/\s{2,}/).join(' ').trim().split(/\s+(?=[A-Z])/).join(' ').split('  ').filter(Boolean); // fallback
  // meglio: estraiamo nomi da mappa conosciuta
  const known = Object.keys(shipNameMapEN2IT);
  const names = [];
  let rest = afterType;
  while(rest.length){
    let found = null;
    for(const k of known){
      if(rest.startsWith(k)){
        found = k; break;
      }
    }
    if(found){
      names.push(found);
      rest = rest.slice(found.length).trim();
    }else{
      // taglia una parola
      rest = rest.replace(/^[^\s]+\s*/,'').trim();
      if(!rest) break;
    }
  }
  const counts = afterCount.split(/\s+/).map(x=>parseNum(x)).filter(n=>n>0 || afterCount.includes('0'));
  for(let i=0;i<Math.min(names.length, counts.length);i++){
    out[names[i]] = counts[i];
  }
  return out;
}

function parseFinalFromRound3(md){
  // Round 3 contiene blocchi "Attacker NAME ... Type ... Count ... Lost ..."
  // Nella conversione NoMoreAngel lo stesso player può comparire più volte: qui SOMMIAMO.
  const out = { attackers:{}, defenders:{} };
  const round3 = md.split(/####\s*Round\s*3/i)[1];
  if(!round3) return out;

  const known = Object.keys(shipNameMapEN2IT).sort((a,b)=>b.length-a.length);

  function parseTypes(typeStr){
    const types = [];
    let rest = (typeStr||'').trim();
    while(rest.length){
      let found = null;
      for(const k of known){
        if(rest.startsWith(k)){ found=k; break; }
      }
      if(found){
        types.push(found);
        rest = rest.slice(found.length).trim();
      }else{
        rest = rest.replace(/^[^\s]+\s*/,'').trim();
      }
    }
    return types;
  }

  function add(side, name, typeStr, countStr){
    const types = parseTypes(typeStr);
    const counts = (countStr||'').trim().split(/\s+/).map(x=>parseNum(x)).filter(x=>Number.isFinite(x));
    const target = side==='attacker' ? out.attackers : out.defenders;
    if(!target[name]) target[name] = {};
    for(let i=0;i<Math.min(types.length, counts.length);i++){
      const t = types[i];
      const v = counts[i] || 0;
      target[name][t] = (target[name][t]||0) + v;
    }
  }

  const reAtk = /Attacker\s+([^\n]+?)\s+([\s\S]*?)\s+Count\s+([\s\S]*?)\s+Lost\s+([\s\S]*?)(?=(?:Attacker\s+|Defender\s+|####\s*Round\s*|$))/gi;
  let m;
  while((m = reAtk.exec(round3)) !== null){
    add('attacker', (m[1]||'').trim(), (m[2]||'').trim(), (m[3]||'').trim());
  }

  const reDef = /Defender\s+([^\n]+?)\s+([\s\S]*?)\s+Count\s+([\s\S]*?)\s+Lost\s+([\s\S]*?)(?=(?:Attacker\s+|Defender\s+|####\s*Round\s*|$))/gi;
  while((m = reDef.exec(round3)) !== null){
    add('defender', (m[1]||'').trim(), (m[2]||'').trim(), (m[3]||'').trim());
  }

  return out;
}

function buildItalianCRFromMarkdown(md){
  const gi = extractGeneralInfoFromText(md);
  const date = gi.date || '--:--:--';
  const coords = gi.coords || gi.combat_coordinates || '';
  const lines = [];
  lines.push(`Il ${date} --:--:--, le seguenti flotte si scontrano in combattimento:\n\n`);

  // INITIAL (raggruppa blocchi duplicati per lo stesso player)
  const blocks = parseInitialBlocksFromMarkdown(md);
  const attackersMap = {}; // key name||tag
  const defendersMap = {};

  function mergeInto(map, b){
    const key = `${b.name}||${b.tag}`;
    if(!map[key]) map[key] = {name:b.name, tag:b.tag, coords:b.coords, fleet:{}};
    map[key].coords = map[key].coords || b.coords;
    const part = parseTypeCountPairs(b.chunk||'');
    for(const [t,v] of Object.entries(part)){
      map[key].fleet[t] = (map[key].fleet[t]||0) + (v||0);
    }
  }

  blocks.forEach(b=>{
    if(b.side==='attacker') mergeInto(attackersMap, b);
    else if(b.side==='defender') mergeInto(defendersMap, b);
  });

  function emitFleet(title, b, fleetMap){
    const tag = b.tag ? ` [${b.tag}]` : '';
    lines.push(`${title} ${b.name}${tag}\n________________________________________________\n`);
    const orderEN = Object.keys(shipNameMapEN2IT); // ordine fisso
    let any=false;
    for(const en of orderEN){
      const n = fleetMap[en];
      if(n && n>0){
        any=true;
        const it = shipNameMapEN2IT[en] || en;
        lines.push(`${it} ${fmt(n)}`);
      }
    }
    if(!any) lines.push('Distrutto!');
    lines.push('_________________________________________\n');
  }

  Object.values(attackersMap).forEach(b=>emitFleet('Attaccante', b, b.fleet));
  Object.values(defendersMap).forEach(b=>emitFleet('Difensore', b, b.fleet));

  // DOPO LA BATTAGLIA (Round 3 "Count" è lo stato finale)
  lines.push(`\n\nDopo la battaglia...\n\n`);

  const finals = parseFinalFromRound3(md);

  for(const b of Object.values(attackersMap)){
    const fin = finals.attackers[b.name] || {};
    const out = {};
    const keys = new Set([...Object.keys(b.fleet), ...Object.keys(fin)]);
    for(const k of keys){
      const i = b.fleet[k] || 0;
      const f = fin[k] || 0;
      if(i===0 && f===0) continue;
      out[k] = {i, f, lost: Math.max(0, i - f)};
    }
    const tag = b.tag ? ` [${b.tag}]` : '';
    lines.push(`Attaccante ${b.name}${tag}\n________________________________________________\n`);
    const orderEN = Object.keys(shipNameMapEN2IT);
    for(const en of orderEN){
      if(!out[en]) continue;
      const it = shipNameMapEN2IT[en] || en;
      lines.push(`${it} ${fmt(out[en].f)} ( -${fmt(out[en].lost)} )`);
    }
    lines.push('_________________________________________\n');
  }

  for(const b of Object.values(defendersMap)){
    const fin = finals.defenders[b.name] || {};
    const anyLeft = Object.values(fin).some(v=>v>0);
    const tag = b.tag ? ` [${b.tag}]` : '';
    lines.push(`Difensore ${b.name}${tag}\n________________________________________________\n`);
    if(!anyLeft){
      lines.push('Distrutto!');
    }else{
      const orderEN = Object.keys(shipNameMapEN2IT);
      for(const en of orderEN){
        const f = fin[en] || 0;
        const i = b.fleet[en] || 0;
        if(i===0 && f===0) continue;
        const it = shipNameMapEN2IT[en] || en;
        lines.push(`${it} ${fmt(f)} ( -${fmt(Math.max(0,i-f))} )`);
      }
    }
    lines.push('_________________________________________\n');
  }

  if(gi.loot_metal || gi.loot_crystal || gi.loot_deuterium){
    lines.push(`\nL'attaccante saccheggia:\n${fmt(gi.loot_metal)} Metallo, ${fmt(gi.loot_crystal)} Cristallo e ${fmt(gi.loot_deuterium)} Deuterio\n`);
  }
  if(gi.debris_metal || gi.debris_crystal){
    lines.push(`\nAt these space coordinates now float ${fmt(gi.debris_metal)} metal, ${fmt(gi.debris_crystal)} crystal and ${fmt(gi.debris_deuterium||0)} deuterium.\n`);
  }
  if(gi.moon_chance){
    lines.push(`\nLa possibilità che si formi una luna dai detriti era del ${gi.moon_chance}%.`);
  }

  return lines.join('\n');
}


function extractCRTextFromAny(html, md){
  // prefer markdown wrapper (r.jina.ai) if present
  const wrap = md || extractMarkdownWrapper(html) || null;
  if(wrap){
    // se contiene già la forma italiana
    if(/Il\s+\d{2}-\d{2}-\d{4}/.test(wrap) && /Attaccante|Difensore/.test(wrap)) return wrap;
    // altrimenti proviamo a costruirla dalla struttura NoMoreAngel
    if(/General Information:/i.test(wrap) && /Combat Report:/i.test(wrap)){
      try { return buildItalianCRFromMarkdown(wrap); } catch(e){ log('buildItalianCRFromMarkdown error: '+(e?.message||e)); }
    }
  }
  // fallback vecchio
  return extractCRTextFromNMA(html);
}

function decodeHtmlEntities(html){
  if (html == null) return '';
  const txt = document.createElement('textarea');
  txt.innerHTML = html;
  return txt.value;
}

function extractMarkdownContent(raw){
  if(!raw) return '';
  const m = raw.match(/Markdown Content:\s*([\s\S]*)$/i);
  if(m) return m[1].trim();
  return raw;
}

function stripHtmlToText(rawHtml){
  const text = decodeHtmlEntities(
    (rawHtml||'')
      .replace(/<br\s*\/?>/gi, '\n')
      .replace(/<\/p>/gi, '\n')
      .replace(/<\/div>/gi, '\n')
      .replace(/<[^>]+>/g, '')
      .replace(/&nbsp;/g, ' ')
  );
  return text;
}

const shipNameMapEN2IT = {
  "Small Cargo":"Cargo leggero",
  "Large Cargo":"Cargo Pesante",
  "Light Fighter":"Caccia Leggero",
  "Heavy Fighter":"Caccia Pesante",
  "Cruiser":"Incrociatore",
  "Battleship":"Nave da battaglia",
  "Colony Ship":"Colonizzatrice",
  "Recycler":"Riciclatrice",
  "Espionage Probe":"Sonda spia",
  "Bomber":"Bombardiere",
  "Solar Satellite":"Satellite Solare",
  "Destroyer":"Corazzata",
  "Deathstar":"Morte Nera",
  "Battlecruiser":"Incrociatore da Battaglia",
  "Crawler":"Crawler",
  "Reaper":"Reaper",
  "Pathfinder":"Pathfinder",
  "Rocket Launcher":"Lanciamissili",
  "Light Laser":"Laser leggero",
  "Heavy Laser":"Laser pesante",
  "Gauss Cannon":"Cannone Gauss",
  "Ion Cannon":"Cannone ionico",
  "Plasma Turret":"Cannone al Plasma",
  "Small Shield Dome":"Cupola scudo piccola",
  "Large Shield Dome":"Cupola scudo potenziata",
};

function looksLikeNmaConvertedText(t){
  return /###\s*General Information:|###\s*Combat Report:|####\s*Initial:|Attacker\s*\[|Defender\s*\[/i.test(t||'');
}

function extractGeneralInfoFromConverted(text){
  const out = {};
  const date = (text.match(/Date:\s*([0-9\-]+)/i)||[])[1];
  const time = (text.match(/Time:\s*([0-9:]+)/i)||[])[1];
  const coords = (text.match(/Combat coordinates:\s*([0-9:]+)/i)||[])[1];
  const dm = (text.match(/Metal to debrisfield:\s*([\d\.\,]+)/i)||[])[1];
  const dc = (text.match(/Crystal to debrisfield:\s*([\d\.\,]+)/i)||[])[1];
  if(date) out.date = date;
  if(time) out.time = time;
  if(coords) out.coords = coords;
  if(dm) out.debrisMetal = parseNum(dm);
  if(dc) out.debrisCrystal = parseNum(dc);
  return out;
}

function parseTypesAndNums(typeStr, numStr){
  // typeStr: "Bomber Destroyer Reaper" or "Light Fighter Heavy Fighter Pathfinder"
  // numStr:  "20.906 102.324 117.084"
  typeStr = (typeStr||'').trim();
  numStr = (numStr||'').trim();
  if(!typeStr || !numStr) return [];
  const nums = numStr.split(/\s+/).map(parseNum).filter(n=>n!==null);
  // Ship names can contain spaces; we greedily match from the known EN list.
  const known = Object.keys(shipNameMapEN2IT).sort((a,b)=>b.length-a.length);
  const types = [];
  let rest = typeStr;
  while(rest.length){
    rest = rest.trim();
    let matched = null;
    for(const k of known){
      if(rest.startsWith(k)){
        matched = k;
        break;
      }
    }
    if(!matched){
      // fallback: take next word
      const w = rest.split(/\s+/)[0];
      matched = w;
    }
    types.push(matched);
    rest = rest.slice(matched.length);
  }
  const pairs = [];
  for(let i=0;i<Math.min(types.length, nums.length);i++){
    pairs.push([types[i], nums[i]]);
  }
  return pairs;
}

function addFleet(fleetObj, name, tag, typeEN, count){
  const it = shipNameMapEN2IT[typeEN] || typeEN;
  if(!fleetObj[name]) fleetObj[name] = {tag: tag||'', fleet: {}};
  fleetObj[name].fleet[it] = (fleetObj[name].fleet[it]||0) + (count||0);
}

function parseInitialFleetsFromConverted(text, cr){
  const startIdx = text.search(/####\s*Initial:/i);
  if(startIdx < 0) return;
  const slice = text.slice(startIdx);
  // Split into attacker chunks until "Defender [" (the big defender block is after attackers)
  const defenderPos = slice.search(/\bDefender\s*\[/i);
  const attackersPart = defenderPos >= 0 ? slice.slice(0, defenderPos) : slice;

  // Find each "Attacker [coords] Name [TAG]"
  const re = /Attacker\s*\[[0-9:]+\]\s*([^\[]+?)\s*\[([^\]]+)\][\s\S]*?(?=\bAttacker\s*\[|\Z)/gi;
  let m;
  while((m = re.exec(attackersPart))){
    const name = (m[1]||'').trim();
    const tag = (m[2]||'').trim();
    const chunk = m[0];
    const tc = chunk.match(/Type\s+([\s\S]*?)\s+Count\s+([\s\S]*?)(?:\s+Weapon|\s+Shield|\s+Armor|$)/i);
    if(!tc) continue;
    const pairs = parseTypesAndNums(tc[1], tc[2]);
    for(const [typeEN, count] of pairs){
      addFleet(cr.attackers, name, tag, typeEN, count);
    }
  }

  // Defender initial (single)
  const defRe = /Defender\s*\[[0-9:]+\]\s*([^\[]+?)\s*\[([^\]]+)\][\s\S]*?(?=####\s*Round|\Z)/i;
  const dm = slice.match(defRe);
  if(dm){
    const name = (dm[1]||'').trim();
    const tag = (dm[2]||'').trim();
    const chunk = dm[0];
    const tc = chunk.match(/Type\s+([\s\S]*?)\s+Count\s+([\s\S]*?)(?:\s+Weapon|\s+Shield|\s+Armor|$)/i);
    if(tc){
      const pairs = parseTypesAndNums(tc[1], tc[2]);
      for(const [typeEN, count] of pairs){
        addFleet(cr.defenders, name, tag, typeEN, count);
      }
    }
  }
}

function parseFinalFleetsFromLastRound(text, cr){
  // Find last "#### Round N" (we only need last round counts)
  const roundMatches = Array.from(text.matchAll(/####\s*Round\s+(\d+)/gi));
  if(!roundMatches.length) return;
  const last = roundMatches[roundMatches.length-1];
  const startIdx = last.index;
  const slice = text.slice(startIdx);

  // Attacker blocks in last round: "Attacker NAME ... Count ... Lost ..."
  const reAtk = /Attacker\s+([A-Za-z0-9_\-]+)\s+([\s\S]*?)(?=\bAttacker\s+[A-Za-z0-9_\-]+\s+|\bDefender\s+[A-Za-z0-9_\-]+\s+|\Z)/g;
  let m;
  while((m = reAtk.exec(slice))){
    const name = (m[1]||'').trim();
    const chunk = m[2]||'';
    const tc = chunk.match(/([\s\S]*?)\s+Count\s+([\s\S]*?)\s+Lost\s+([\s\S]*?)$/i);
    if(!tc) continue;
    const typeStr = tc[1];
    const countStr = tc[2];
    const pairs = parseTypesAndNums(typeStr, countStr);
    // Store as AFTER-BATTLE fleet (overwrite later)
    if(!cr.afterAttackers[name]) cr.afterAttackers[name] = {tag: cr.attackers[name]?.tag || '', fleet: {}};
    for(const [typeEN, count] of pairs){
      const it = shipNameMapEN2IT[typeEN] || typeEN;
      cr.afterAttackers[name].fleet[it] = (cr.afterAttackers[name].fleet[it]||0) + (count||0);
    }
  }

  // Defender block in last round: "Defender NAME ... Count ... Lost ..."
  const reDef = /Defender\s+([A-Za-z0-9_\-]+)\s+([\s\S]*?)(?=\bAttacker\s+|\bDefender\s+[A-Za-z0-9_\-]+\s+|\Z)/g;
  while((m = reDef.exec(slice))){
    const name = (m[1]||'').trim();
    const chunk = m[2]||'';
    const tc = chunk.match(/([\s\S]*?)\s+Count\s+([\s\S]*?)\s+Lost\s+([\s\S]*?)$/i);
    if(!tc) continue;
    const pairs = parseTypesAndNums(tc[1], tc[2]);
    if(!cr.afterDefenders[name]) cr.afterDefenders[name] = {tag: cr.defenders[name]?.tag || '', fleet: {}};
    for(const [typeEN, count] of pairs){
      const it = shipNameMapEN2IT[typeEN] || typeEN;
      cr.afterDefenders[name].fleet[it] = (cr.afterDefenders[name].fleet[it]||0) + (count||0);
    }
  }
}

function buildClassicCRTextFromConverted(cr){
  // Convert internal structure into the Italian CR-text format our parser already understands.
  const lines = [];
  const dt = cr.date ? cr.date : '--';
  lines.push(`Il ${dt} --:--:--, le seguenti flotte si scontrano in combattimento:\n`);
  for(const [name,obj] of Object.entries(cr.attackers)){
    lines.push(`\n\nAttaccante ${name} [${obj.tag||''}]`);
    lines.push(`\n________________________________________________\n`);
    for(const [ship,cnt] of Object.entries(obj.fleet)){
      if(cnt>0) lines.push(`${ship} ${fmt(cnt)}`);
    }
    lines.push(`\n_________________________________________`);
  }
  for(const [name,obj] of Object.entries(cr.defenders)){
    lines.push(`\n\nDifensore ${name} [${obj.tag||''}]`);
    lines.push(`\n________________________________________________\n`);
    for(const [ship,cnt] of Object.entries(obj.fleet)){
      if(cnt>0) lines.push(`${ship} ${fmt(cnt)}`);
    }
    lines.push(`\n_________________________________________`);
  }
  // After battle section (to compute losses)
  lines.push(`\n\nDopo la battaglia...\n`);
  for(const [name,obj] of Object.entries(cr.afterAttackers||{})){
    lines.push(`\nAttaccante ${name} [${obj.tag||cr.attackers[name]?.tag||''}]`);
    lines.push(`\n________________________________________________\n`);
    for(const [ship,cnt] of Object.entries(obj.fleet)){
      lines.push(`${ship} ${fmt(cnt)}`);
    }
    lines.push(`\n_________________________________________`);
  }
  for(const [name,obj] of Object.entries(cr.afterDefenders||{})){
    lines.push(`\nDifensore ${name} [${obj.tag||cr.defenders[name]?.tag||''}]`);
    lines.push(`\n________________________________________________\n`);
    // if all zero, mark destroyed
    const total = Object.values(obj.fleet).reduce((a,b)=>a+(b||0),0);
    if(total===0){
      lines.push(`Distrutto!`);
    } else {
      for(const [ship,cnt] of Object.entries(obj.fleet)){
        lines.push(`${ship} ${fmt(cnt)}`);
      }
    }
    lines.push(`\n_________________________________________`);
  }
  if(cr.debrisMetal || cr.debrisCrystal){
    lines.push(`\nAt these space coordinates now float ${fmt(cr.debrisMetal||0)} metal, ${fmt(cr.debrisCrystal||0)} crystal and 0 deuterium.`);
  }
  return lines.join('\n');
}

async function loadCRFromNoMoreAngel(apiId){
  const timeoutMs = parseNum(document.getElementById('timeoutMs')?.value) || 12000;
  const apiUrl = /^https?:\/\//i.test(apiId)
    ? apiId
    : `https://nomoreangel.de/api-reader/?apiid=${encodeURIComponent(apiId)}&engOut=on`;

  log(`CR API: richiesta NoMoreAngel: ${apiUrl}`);
  const raw = await fetchTextWithFallback(apiUrl, timeoutMs);
  const norm = normalizeHTMLFromJina(raw);
  const md = extractMarkdownContent(norm);
  const text = looksLikeNmaConvertedText(md) ? md : stripHtmlToText(norm);

  if(!looksLikeNmaConvertedText(text)) throw new Error("Risposta non riconosciuta (manca General Information / Combat Report).");

  const gi = extractGeneralInfoFromConverted(text);
  const cr = {
    date: gi.date || '',
    time: gi.time || '',
    coords: gi.coords || '',
    debrisMetal: gi.debrisMetal || 0,
    debrisCrystal: gi.debrisCrystal || 0,
    attackers: {},
    defenders: {},
    afterAttackers: {},
    afterDefenders: {},
  };

  parseInitialFleetsFromConverted(text, cr);
  parseFinalFleetsFromLastRound(text, cr);

  // Create a classic-like CR string and reuse our existing parser for the rest of the tool.
  const classic = buildClassicCRTextFromConverted(cr);
  return {classicText: classic, debugText: text, meta: cr};
}

async function loadCRFromOGotcha(apiId){
  // OGotcha non sempre espone una conversione diretta da apiid senza interazione;
  // qui proviamo alcune URL comuni e, se non troviamo il testo CR, chiediamo incolla manuale.
  const candidates = [
    `https://ogotcha.oplanet.eu/en/?apiid=${encodeURIComponent(apiId)}`,
    `https://ogotcha.oplanet.eu/en/?api=${encodeURIComponent(apiId)}`,
    `https://ogotcha.oplanet.eu/en/api-reader/?apiid=${encodeURIComponent(apiId)}`,
    `https://ogotcha.oplanet.eu/api-reader/?apiid=${encodeURIComponent(apiId)}`
  ];
  let lastErr = null;
  for(const url of candidates){
    try{
      log(`OGotcha: provo ${url}`);
      const htmlRaw = await fetchTextWithFallback(url, 12000);
      const html = normalizeHTMLFromJina(htmlRaw);
      const wrap = extractMarkdownWrapper(htmlRaw) || null;
      const crText = extractCRTextFromAny(html, wrap || htmlRaw);
      if(!crText) throw new Error('CR non trovato nella pagina');
      return {crText, sourceUrl:url, raw: htmlRaw};
    }catch(e){
      lastErr = e;
      log(`OGotcha: tentativo fallito (${e?.message||e})`);
    }
  }
  throw new Error(lastErr?.message || 'OGotcha: conversione non disponibile');
}

document.getElementById('btnLoadCRApi').addEventListener('click', async () => {
  const apiId = (document.getElementById('crApiId').value || '').trim();
  if (!apiId) { log("⚠️ Inserisci un API ID CR."); return; }
  try{
    const {classicText, debugText, meta} = await loadCRFromNoMoreAngel(apiId);
    document.getElementById('crText').value = classicText;
    // show raw converted response in CR raw box if exists
    const crRaw = document.getElementById('crRaw');
    if(crRaw) crRaw.textContent = (debugText||'').slice(0, 40000);
    log(`✅ CR convertito caricato. Attaccanti: ${Object.keys(meta.attackers).length} • Difensori: ${Object.keys(meta.defenders).length} • Coord: ${meta.coords||'-'}`);
    // auto-analyze
    const crParsed = parseCRText(classicText);
    STATE.cr = crParsed;
    renderKPI(crParsed);
    recomputeAndRender();
    setTab('risultati');
  }catch(e){
    log("❌ Errore CR API: " + (e?.message || e));
    console.error(e);
    setTab('log');
  }
});

document.getElementById('btnLoadCRApiOgotcha').addEventListener('click', async () => {
  const apiId = (document.getElementById('crApiId').value || '').trim();
  if (!apiId) { log("⚠️ Inserisci un API ID CR."); return; }
  log(`Carico CR da OGotcha (${apiId})...`);
  try{
    const {crText, sourceUrl} = await loadCRFromOGotcha(apiId);
    document.getElementById('crText').value = crText;
    log(`✅ CR caricato da OGotcha (${sourceUrl}).`);
    const cr = parseCRText(crText);
    STATE.cr = cr;
    renderKPI(cr);
    recomputeAndRender();
    setTab('risultati');
  }catch(e){
    log(`❌ Errore CR OGotcha: ${e?.message || e}`);
    setTab('log');
  }
});

document.getElementById('btnClearRR').addEventListener('click', () => {
  STATE.rr = {};
  document.getElementById('rrRaw').textContent = '';
  renderRRTable(STATE.rr);
  recomputeAndRender();
  log("RR puliti.");
});

// ----------------- Condivisione (link con stato) -----------------
function encodeShareState(obj){
  // base64(url-safe) di JSON UTF-8
  const json = JSON.stringify(obj);
  const b64 = btoa(unescape(encodeURIComponent(json)))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/g, '');
  return b64;
}
function decodeShareState(b64){
  const pad = '==='.slice((b64.length + 3) % 4);
  const s = (b64 + pad).replace(/-/g, '+').replace(/_/g, '/');
  const json = decodeURIComponent(escape(atob(s)));
  return JSON.parse(json);
}
function collectShareState(){
  return {
    v: 1,
    crText: (document.getElementById('crText').value || '').trim(),
    proxyBase: (document.getElementById('proxyBase').value || '').trim(),
    timeoutMs: parseNum(document.getElementById('timeoutMs').value) || 12000,
    rrIds: (document.getElementById('rrIds').value || '').trim(),
    // per comodità: se hai già caricato RR, includiamo anche il totale per player
    rrTotals: STATE.rr || {},
  };
}
function applyShareState(st){
  if (!st || typeof st !== 'object') return;
  if (typeof st.proxyBase === 'string' && st.proxyBase.trim()) document.getElementById('proxyBase').value = st.proxyBase.trim();
  if (st.timeoutMs) document.getElementById('timeoutMs').value = String(st.timeoutMs);
  if (typeof st.rrIds === 'string') document.getElementById('rrIds').value = st.rrIds;
  if (typeof st.crText === 'string') document.getElementById('crText').value = st.crText;

  // Se abbiamo già totals, possiamo renderizzarli subito senza rifetch.
  if (st.rrTotals && typeof st.rrTotals === 'object' && Object.keys(st.rrTotals).length){
    STATE.rr = st.rrTotals;
    renderRRTable(STATE.rr);
  }
  // Analizza CR (se presente)
  if ((document.getElementById('crText').value || '').trim()) {
    try { parseCRText(); } catch(e){ log('Errore analisi CR da link: ' + (e?.message||e)); }
  }
  recomputeAndRender();
}
function shareLink(){
  const st = collectShareState();
  const token = encodeShareState(st);
  const url = `${location.origin}${location.pathname}#s=${token}`;
  return url;
}
async function doShare(){
  const url = shareLink();
  const title = 'Spartizione Detriti OGame';
  const text = 'Link con CR/RR precompilati';
  try {
    if (navigator.share) {
      await navigator.share({title, text, url});
      log('✅ Link condiviso.');
      return;
    }
  } catch (e) {
    // se l'utente annulla, non è un errore grave
  }
  try {
    await navigator.clipboard.writeText(url);
    log('✅ Link copiato negli appunti.');
  } catch (e) {
    // fallback
    prompt('Copia questo link:', url);
    log('ℹ️ Link mostrato in prompt (clipboard non disponibile).');
  }
}

document.getElementById('btnShare').addEventListener('click', () => {
  doShare();
});

// Carica stato da hash (se presente)
(() => {
  const m = (location.hash || '').match(/#s=([A-Za-z0-9\-_]+)/);
  if (!m) return;
  try {
    const st = decodeShareState(m[1]);
    applyShareState(st);
    setTab('cr');
    log('🔗 Stato caricato dal link.');
  } catch (e) {
    log('⚠️ Hash di condivisione non valido: ' + (e?.message || e));
  }
})();

// Initial
log("Pronto. 1) Incolla CR (testo) e Analizza. 2) Carica RR (API) per sommare raccolte. 3) Vedi Risultati.");
</script>
</body>
</html>
