<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Spartizione Detriti OGame - CR (testo) + RR (API)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800&family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root {
    /* OGame-ish palette */
    --bg:#050a10;
    --panel:#0b1320;
    --panel2:#07101b;
    --text:#dbe7ff;
    --muted:#93a6c7;
    --line:rgba(120,160,220,.25);
    --accent:#4da3ff;      /* orange */
    --accent2:#2dd4ff;     /* cyan */
    --good:#39d98a;
    --bad:#ff5c5c;
    --warn:#ff5c5c;
    --font-ui: "Rajdhani", system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial;
    --font-title: "Orbitron", "Rajdhani", system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:var(--font-ui);color:var(--text);background:var(--bg);}
  body::before{
    content:"";
    position:fixed;
    inset:0;
    z-index:-1;
    background:
      radial-gradient(1200px 700px at 15% -10%, rgba(124,240,255,.10), transparent 55%),
      radial-gradient(900px 600px at 110% 10%, rgba(255,179,77,.10), transparent 55%),
      radial-gradient(2px 2px at 20% 30%, rgba(255,255,255,.9), transparent 60%),
      radial-gradient(1px 1px at 40% 60%, rgba(255,255,255,.75), transparent 60%),
      radial-gradient(1px 1px at 70% 20%, rgba(255,255,255,.7), transparent 60%),
      radial-gradient(1px 1px at 85% 80%, rgba(255,255,255,.65), transparent 60%),
      radial-gradient(1px 1px at 10% 85%, rgba(255,255,255,.6), transparent 60%),
      radial-gradient(1px 1px at 95% 45%, rgba(255,255,255,.55), transparent 60%),
      linear-gradient(180deg, rgba(15,25,40,.65), rgba(5,10,16,1));
    filter:saturate(1.05) contrast(1.05);
  }
  header{position:sticky;top:0;z-index:5;background:linear-gradient(180deg, rgba(7,12,18,.92), rgba(7,12,18,.65));backdrop-filter:blur(10px);border-bottom:1px solid var(--line);}
  .wrap{max-width:1100px;margin:0 auto;padding:14px 14px;}
  .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px;}
  .title{display:flex;align-items:center;gap:10px;min-width:0;}
  .actions{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end;}
  .badge{font-size:12px;color:var(--muted);border:1px solid var(--line);padding:4px 8px;border-radius:999px;background:rgba(16,26,46,.6)}
  h1{font-family:var(--font-title);font-size:16px;margin:0;letter-spacing:.8px;text-transform:uppercase}
  .tabs{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
  .tabbtn{border:1px solid var(--line);background:rgba(16,26,46,.6);color:var(--text);padding:8px 10px;border-radius:10px;cursor:pointer}
  .tabbtn.active{border-color:rgba(242,169,0,.8);box-shadow:0 0 0 2px rgba(242,169,0,.18) inset;background:rgba(242,169,0,.07)}
  .grid{display:grid;grid-template-columns:1fr;gap:12px;margin-top:14px}
  @media (min-width: 980px){ .grid{grid-template-columns: 1fr 1fr;} }
  .card{border:1px solid var(--line);background:linear-gradient(180deg, rgba(16,26,46,.8), rgba(14,23,40,.75));border-radius:16px;padding:12px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .card h2{margin:0 0 8px 0;font-size:14px;color:var(--text)}
  textarea,input{width:100%;background:rgba(8,12,20,.65);border:1px solid var(--line);color:var(--text);border-radius:12px;padding:10px;font-size:13px;outline:none}
  textarea{min-height:240px;resize:vertical;line-height:1.25}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .row > *{flex:1}
  button{border:1px solid rgba(88,166,255,.65);background:rgba(88,166,255,.15);color:var(--text);
    padding:9px 12px;border-radius:12px;cursor:pointer;font-weight:600}
  button:hover{background:rgba(88,166,255,.22)}
  .ghost{border-color:var(--line);background:rgba(16,26,46,.5);font-weight:600}
  .ghost:hover{background:rgba(16,26,46,.75)}
  .mini{font-size:12px;color:var(--muted)}
  .pill{display:inline-flex;gap:8px;align-items:center;border:1px solid var(--line);border-radius:999px;padding:6px 10px;background:rgba(16,26,46,.5)}
  .pill input{width:auto}
  .kpi{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px}
  .kpi .box{border:1px solid var(--line);background:rgba(8,12,20,.35);border-radius:12px;padding:10px}
  .kpi .box .v{font-size:14px;font-weight:800}
  .kpi .box .l{font-size:12px;color:var(--muted)}
  table{width:100%;border-collapse:collapse;overflow:hidden;border-radius:12px;border:1px solid var(--line);background:rgba(8,12,20,.35)}
  th,td{padding:8px 8px;border-bottom:1px solid rgba(34,52,85,.6);font-size:12px;text-align:right}
  th{text-align:right;color:var(--muted);font-weight:700;background:rgba(16,26,46,.55)}
  th:first-child, td:first-child{text-align:left}
  tr:last-child td{border-bottom:none}
  .good{color:var(--good)}
  .bad{color:var(--bad)}
  .warn{color:var(--warn)}
  details{border:1px solid var(--line);border-radius:12px;padding:10px;background:rgba(8,12,20,.25)}
  summary{cursor:pointer;color:var(--muted);font-weight:700}
  pre{margin:0;white-space:pre-wrap;word-break:break-word;font-size:12px;color:#cfe0ff}

.ico{width:16px;height:16px;vertical-align:-3px;margin-right:8px;fill:currentColor;opacity:.9}

.advanced{display:none}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1>Spartizione Detriti OGame</h1>
        <span class="badge">CR testo + RR API ‚Ä¢ logica foglio di calcolo</span>
      </div>
      <div class="actions">
        <button class="ghost" id="btnShare" type="button" title="Copia un link con la configurazione"><svg class="ico" viewBox="0 0 24 24" aria-hidden="true"><path d="M18 16a3 3 0 0 0-2.24 1.02L8.91 13.7a3.2 3.2 0 0 0 0-3.4l6.85-3.32A3 3 0 1 0 15 5a2.98 2.98 0 0 0 .07.63L8.22 8.95A3 3 0 1 0 9 12a2.98 2.98 0 0 0-.07-.63l6.85 3.32A3 3 0 1 0 18 16Z"/></svg>Condividi</button>
      </div>
    </div>
    <div class="tabs">
      <button class="tabbtn active" data-tab="cr">CR (testo)</button>
      <button class="tabbtn" data-tab="rr">RR (API via nomoreangel/proxy)</button>
      <button class="tabbtn" data-tab="risultati">Risultati</button>
      <button class="tabbtn" data-tab="log">Log</button>
    </div>
  </div>
</header>

<div class="wrap">
  <div id="tab-cr" class="tab">
    <div class="grid">
      <div class="card">
        <h2>Incolla qui il Combat Report (formato classico IT/EN)</h2>
        
        <div class="row" style="gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:10px;">
          <input id="crApiId" placeholder="API ID CR (es. cr-it-269-... oppure link api-reader)" style="flex:1; min-width:260px;">
          <button id="btnLoadCRApi" class="primary">Carica CR da API</button>
        </div>
<textarea id="crText" placeholder="Incolla il CR qui..."></textarea>
        <div class="row" style="margin-top:10px">
          <button id="btnParseCR">Analizza CR</button>
          <button id="btnCRDemo" class="ghost">Demo</button>
        </div>
        <div class="mini" style="margin-top:8px">
          Estrae: attaccanti, difensore, coordinate, loot, perdite, DF (float).
        </div>
      </div>

      <div class="card">
        <h2>Opzioni di spartizione</h2>
        <div class="row">
          <label class="pill"><input type="radio" name="mode" value="paritaria" checked> Paritaria</label>
          <label class="pill"><input type="radio" name="mode" value="equa"> Equa (peso flotta in campo)</label>
        </div>
        <div class="kpi" id="kpiCR"></div>

        <details style="margin-top:10px" open>
          <summary>Costi navi / difese (come foglio)</summary>
          <div class="mini" style="margin-top:8px">
            I calcoli usano questi costi base. Se il tuo universo ha costi diversi, dimmelo e li rendiamo editabili.
          </div>
          <div id="costsTable" style="margin-top:8px"></div>
        </details>
      </div>
    </div>
  </div>

  <div id="tab-rr" class="tab" style="display:none">
    <div class="grid">
      <div class="card">
        <h2>Carica RR tramite API ID</h2>
        <div class="row advanced">
          <div style="flex:2">
            <label class="mini">Proxy base URL</label>
            <input id="proxyBase" value="https://ogame-api-proxy.matiasquiroz87.workers.dev/?apiid=" />
          </div>
          <div>
            <label class="mini">Timeout (ms)</label>
            <input id="timeoutMs" value="12000" />
          </div>
        </div>
        <div style="margin-top:8px">
          <label class="mini">Inserisci uno o pi√π RR apiid (uno per riga)</label>
          <textarea id="rrIds" placeholder="rr-it-269-...."></textarea>
        </div>
        <div class="row" style="margin-top:10px">
          <button id="btnLoadRR">Carica RR</button>
          <button id="btnClearRR" class="ghost">Pulisci</button>
        </div>
        <div class="mini" style="margin-top:8px">
          Il tool somma automaticamente le raccolte per giocatore (owner_name) e per risorsa.
        </div>
      </div>

      <div class="card">
        <h2>Raccolte lette</h2>
        <div id="rrTable"></div>
        <details style="margin-top:10px">
          <summary>Dettagli RR (debug)</summary>
          <pre id="rrRaw"></pre>
        </details>
      </div>
    </div>
  </div>

  <div id="tab-risultati" class="tab" style="display:none">
    <div class="card">
      <h2>Risultati (logica del foglio)</h2>
      <div class="mini">
        Formula (per risorsa): <b>quota = perdite_i + (gain_totale √ó peso_i) ‚àí raccolto_i</b><br/>
        dove <b>gain_totale = raccolto_totale ‚àí perdite_totali</b>. La somma delle quote = 0 (trasferimenti tra alleati).
      </div>
      <div style="margin-top:10px" id="resultsTables"></div>

      <details style="margin-top:12px" open>
        <summary>Trasporti finali suggeriti</summary>
        <div class="mini" style="margin-top:8px">
          Elenco di trasferimenti minimi tra chi deve inviare (negativo) e chi deve ricevere (positivo).
        </div>
        <div id="transports"></div>
      </details>
    </div>
  </div>

  <div id="tab-log" class="tab" style="display:none">
    <div class="card">
      <h2>Log</h2>
      <pre id="logBox"></pre>
    </div>
  </div>
</div>

<script>
const DF_RATE = 0.30; // 30% anche Deuterio
const COSTS = {"Cargo leggero": [2000, 2000, 0], "Cargo Pesante": [6000, 6000, 0], "Caccia Leggero": [3000, 1000, 0], "Caccia Pesante": [6000, 4000, 0], "Incrociatore": [20000, 7000, 2000], "Nave da battaglia": [45000, 15000, 0], "Bombardiere": [50000, 25000, 15000], "Corazzata": [60000, 50000, 15000], "Incrociatore da Battaglia": [30000, 40000, 15000], "Reaper": [85000, 55000, 20000], "Pathfinder": [8000, 15000, 8000], "Riciclatrice": [10000, 6000, 2000], "Colonizzatrice": [10000, 20000, 10000], "Sonda spia": [0, 1000, 0], "Satellite Solare": [0, 2000, 500], "Crawler": [2000, 2000, 1000], "Morte Nera": [5000000, 4000000, 1000000], "Lanciamissili": [2000, 0, 0], "Laser leggero": [1500, 500, 0], "Laser pesante": [6000, 2000, 0], "Cannone Gauss": [20000, 15000, 2000], "Cannone ionico": [2000, 6000, 0], "Cannone al Plasma": [50000, 50000, 30000], "Cupola scudo piccola": [10000, 10000, 0], "Cupola scudo potenziata": [50000, 50000, 0]};
const DF_ALLOWED = new Set([
  "Cargo leggero",
  "Cargo Pesante",
  "Caccia Leggero",
  "Caccia Pesante",
  "Incrociatore",
  "Nave da battaglia",
  "Bombardiere",
  "Corazzata",
  "Incrociatore da Battaglia",
  "Reaper",
  "Pathfinder",
  "Colonizzatrice",
  "Riciclatrice",
  "Sonda spia",
  "Crawler",
  "Satellite Solare"
]);

function fmt(n) {
  if (n === null || n === undefined || isNaN(n)) return '-';
  return Math.round(n).toLocaleString('it-IT');
}
function parseNum(str) {
  if (str === null || str === undefined) return 0;
  const s = String(str).replace(/\./g,'').replace(/,/g,'').replace(/\s+/g,'').trim();
  const n = Number(s);
  return isNaN(n) ? 0 : n;
}
const LOG = [];
function log(msg, level="info") {
  const t = new Date().toLocaleTimeString();
  const line = `[${t}] ${msg}`;
  LOG.push(line);
  const el = document.getElementById('logBox');
  if (el) el.textContent = LOG.join("\n");
}

function setTab(name) {
  document.querySelectorAll('.tabbtn').forEach(b => b.classList.toggle('active', b.dataset.tab===name));
  document.querySelectorAll('.tab').forEach(t => t.style.display = 'none');
  document.getElementById('tab-'+name).style.display = 'block';
}

document.querySelectorAll('.tabbtn').forEach(btn => btn.addEventListener('click', () => setTab(btn.dataset.tab)));

function renderCosts() {
  const rows = Object.entries(COSTS).map(([k,v]) => {
    const [m,c,d]=v;
    const g=m+c+d;
    return `<tr><td>${k}</td><td>${fmt(m)}</td><td>${fmt(c)}</td><td>${fmt(d)}</td><td>${fmt(g)}</td></tr>`;
  }).join('');
  document.getElementById('costsTable').innerHTML = `
    <table>
      <thead><tr><th>Unit√†</th><th>Metallo</th><th>Cristallo</th><th>Deuterio</th><th>Globale</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>`;
}
renderCosts();

// -------- CR PARSER (testo classico) --------
const STATE = {
  cr: null, // parsed CR
  rr: {}  // per player totals: {player: {m,c,d, list:[]}}
};

function parseCRText(text) {
  const out = {
    attackers: {}, // name -> {tag, initial{ship:count}, final{ship:count}}
    defenders: {},
    coords: null,
    loot: {m:0,c:0,d:0},
    df_float: {m:0,c:0,d:0},
    moonChance: null,
    lossesUnits: {att:0, def:0},
  };

  // coords + moon chance
  const coordM = text.match(/\b\[(\d+:\d+:\d+)\]|\b(\d+:\d+:\d+)\b/);
  if (coordM) out.coords = (coordM[1]||coordM[2]||null);

  const moonM = text.match(/possibilit[a√†].*?luna.*?(\d+)%/i);
  if (moonM) out.moonChance = parseNum(moonM[1]);

  // losses units
  const attLost = text.match(/attaccante ha perso un totale di\s*([\d\.,]+)\s*unit/i);
  const defLost = text.match(/difensore ha perso un totale di\s*([\d\.,]+)\s*unit/i);
  if (attLost) out.lossesUnits.att = parseNum(attLost[1]);
  if (defLost) out.lossesUnits.def = parseNum(defLost[1]);

  // loot
  const lootM = text.match(/saccheggia:\s*([\d\.,]+)\s*Metallo,\s*([\d\.,]+)\s*Cristallo\s*e\s*([\d\.,]+)\s*Deuterio/i);
  if (lootM) {
    out.loot.m = parseNum(lootM[1]);
    out.loot.c = parseNum(lootM[2]);
    out.loot.d = parseNum(lootM[3]);
  }

  // debris float line (EN)
  const dfM = text.match(/now float\s*([\d\.,]+)\s*metal,\s*([\d\.,]+)\s*crystal\s*and\s*([\d\.,]+)\s*deuterium/i);
  if (dfM) {
    out.df_float.m = parseNum(dfM[1]);
    out.df_float.c = parseNum(dfM[2]);
    out.df_float.d = parseNum(dfM[3]);
  }

  // Split pre/post battle (robusto: "Dopo la battaglia..." pu√≤ variare)
  let pre = text;
  let post = "";
  const idx = text.search(/\bDopo\s+la\s+battaglia\b/i);
  if (idx >= 0) {
    pre = text.slice(0, idx);
    post = text.slice(idx);
  }

  function parseSideBlocks(blockText, phase) {
    // phase: 'initial' or 'final'
    const lines = blockText.split(/\r?\n/);
    let current = null;
    let currentSide = null;
    for (let i=0;i<lines.length;i++) {
      const line = lines[i].trim();
      if (!line) continue;
      const h = line.match(/^(Attaccante|Difensore)\s+(.+?)\s+\[(.+?)\]\s*$/i);
      if (h) {
        currentSide = h[1].toLowerCase().startsWith('att') ? 'att' : 'def';
        const name = h[2].trim();
        const tag = h[3].trim();
        if (currentSide==='att') {
          if (!out.attackers[name]) out.attackers[name] = {tag, initial: {}, final: {}};
          out.attackers[name].tag = tag;
          current = out.attackers[name];
        } else {
          if (!out.defenders[name]) out.defenders[name] = {tag, initial: {}, final: {}};
          out.defenders[name].tag = tag;
          current = out.defenders[name];
        }
        continue;
      }
      if (!current) continue;
      if (line.startsWith('_')) continue;
      if (line.toLowerCase().includes('distrutto')) continue;

      // ship line: "Caccia Leggero 3.226.909 ( -xxx )"
      const m = line.match(/^(.+?)\s+([\d\.,]+)(?:\s*\(\s*-[\d\.,]+\s*\))?\s*$/);
      if (m) {
        const ship = m[1].trim();
        const count = parseNum(m[2]);
        if (phase==='initial') current.initial[ship] = (current.initial[ship]||0) + count;
        else current.final[ship] = (current.final[ship]||0) + count;
      }
    }
  }

  parseSideBlocks(pre, 'initial');
  if (post) parseSideBlocks(post, 'final');

  // Ensure final exists: if missing post, copy initial
  Object.values(out.attackers).forEach(p => {
    if (!p.final || Object.keys(p.final).length===0) p.final = JSON.parse(JSON.stringify(p.initial));
  });

  
  // calcolo DF da perdite (M/C e anche D al 30%)
  out.df_calc = computeDebrisFromCR(out);

  return out;
}

function computeDebrisFromCR(cr){
  // Totale detriti stimato dalle perdite di attaccanti + difensori
  // DF_RATE applicato a metallo / cristallo / deuterio
  const sum = { m: 0, c: 0, d: 0 };
  if (!cr) return sum;

  function addLossesFromSide(sideObj){
    for (const p of Object.values(sideObj || {})) {
      const ini = p.initial || {};
      const fin = (p.final && Object.keys(p.final).length) ? p.final : {};
      const ships = new Set([...Object.keys(ini), ...Object.keys(fin)]);

      for (const ship of ships) {
        const a0 = ini[ship] || 0;
        const a1 = fin[ship] || 0;
        const lost = Math.max(0, a0 - a1);
        if (!lost) continue;

        const cost = COSTS[ship];
        if (!cost) continue;

        // ‚ùå difese NON fanno DF (eccetto crawler e satelliti)
        if (!DF_ALLOWED.has(ship)) continue;

        sum.m += cost[0] * lost * DF_RATE;
        sum.c += cost[1] * lost * DF_RATE;
        sum.d += cost[2] * lost * DF_RATE;
      }
    }
  }

  addLossesFromSide(cr.attackers);
  addLossesFromSide(cr.defenders);

  return sum;
}

function computeFromSheetLogic(cr, rrTotals, mode) {
  const players = Object.keys(cr.attackers);
  const n = players.length || 1;

  // 1) losses per player by ship diffs
  const losses = {};
  const fleetValue = {};
  players.forEach(name => {
    const p = cr.attackers[name];
    losses[name] = {m:0,c:0,d:0, units:0};
    fleetValue[name] = 0;
    // Fleet in campo (initial) value
    for (const [ship, cnt] of Object.entries(p.initial)) {
      const cost = COSTS[ship];
      if (cost) {
        const g = (cost[0]+cost[1]+cost[2]) * cnt;
        fleetValue[name] += g;
      }
    }
    // losses
    const ships = new Set([...Object.keys(p.initial), ...Object.keys(p.final)]);
    ships.forEach(ship => {
      const ini = p.initial[ship] || 0;
      const fin = p.final[ship] || 0;
      const lostCnt = Math.max(0, ini - fin);
      if (lostCnt<=0) return;
      losses[name].units += lostCnt;
      const cost = COSTS[ship];
      if (!cost) return; // ignore unknown ships
      losses[name].m += cost[0] * lostCnt;
      losses[name].c += cost[1] * lostCnt;
      losses[name].d += cost[2] * lostCnt;
    });
  });

  const totLoss = players.reduce((a,nm)=>({
    m:a.m+losses[nm].m, c:a.c+losses[nm].c, d:a.d+losses[nm].d
  }), {m:0,c:0,d:0});

  // 2) total recycled from RR
  const totRec = players.reduce((a,nm)=>{
    const r = rrTotals[nm] || {m:0,c:0,d:0};
    return {m:a.m+r.m, c:a.c+r.c, d:a.d+r.d};
  }, {m:0,c:0,d:0});

  // 3) gain = recycled - losses (per resource)
  const gain = {m: totRec.m - totLoss.m, c: totRec.c - totLoss.c, d: totRec.d - totLoss.d};

  // 4) weights
  const weights = {};
  if (mode === 'paritaria') {
    players.forEach(nm => weights[nm] = 1/n);
  } else {
    const totFleet = players.reduce((s,nm)=> s + (fleetValue[nm]||0), 0) || 1;
    players.forEach(nm => weights[nm] = (fleetValue[nm]||0)/totFleet);
  }

  // 5) quota (= due): losses + gain*weight - collected
  const quota = {};
  players.forEach(nm => {
    const r = rrTotals[nm] || {m:0,c:0,d:0};
    quota[nm] = {
      m: losses[nm].m + gain.m * weights[nm] - r.m,
      c: losses[nm].c + gain.c * weights[nm] - r.c,
      d: losses[nm].d + gain.d * weights[nm] - r.d,
      w: weights[nm],
      fleet: fleetValue[nm],
      lost: losses[nm],
      rec: r
    };
  });

  return {players, losses, fleetValue, weights, totLoss, totRec, gain, quota};
}

function buildTransfers(players, quota, resKey) {
  const recv = [];
  const send = [];
  players.forEach(p => {
    const v = quota[p][resKey];
    if (v > 0.5) recv.push([p, v]);
    else if (v < -0.5) send.push([p, -v]);
  });
  recv.sort((a,b)=>b[1]-a[1]);
  send.sort((a,b)=>b[1]-a[1]);
  const moves = [];
  let i=0,j=0;
  while (i<send.length && j<recv.length) {
    const [sp, sv] = send[i];
    const [rp, rv] = recv[j];
    const x = Math.min(sv, rv);
    if (x>0.5) moves.push({from: sp, to: rp, amount: x});
    send[i][1] -= x;
    recv[j][1] -= x;
    if (send[i][1] <= 0.5) i++;
    if (recv[j][1] <= 0.5) j++;
  }
  return moves;
}

function renderKPI(cr) {
  const el = document.getElementById('kpiCR');
  if (!cr) { el.innerHTML = ""; return; }
  const attackers = Object.keys(cr.attackers).length;
  const defenders = Object.keys(cr.defenders).length;
  el.innerHTML = `
    <div class="box"><div class="v">${cr.coords || '-'}</div><div class="l">Coordinate</div></div>
    <div class="box"><div class="v">${attackers} / ${defenders}</div><div class="l">Attaccanti / Difensori</div></div>
    <div class="box"><div class="v">${cr.moonChance!==null ? (cr.moonChance+'%') : '-'}</div><div class="l">Chance Luna</div></div>
    <div class="box"><div class="v">${fmt(cr.df_float.m)}</div><div class="l">DF float M</div></div>
    <div class="box"><div class="v">${fmt(cr.df_float.c)}</div><div class="l">DF float C</div></div>
    <div class="box"><div class="v">${fmt(cr.df_float.d)}</div><div class="l">DF float D</div></div>
  
${(() => {
  const df = computeDebrisFromCR(cr);
  return `
  <div class="box"><div class="v">${fmt(df.m)}</div><div class="l">DF calcolato M (30%)</div></div>
  <div class="box"><div class="v">${fmt(df.c)}</div><div class="l">DF calcolato C (30%)</div></div>
  <div class="box"><div class="v">${fmt(df.d)}</div><div class="l">DF calcolato D (30%)</div></div>
  `;
})()}
`;
}
  const dfNew = computeDebrisFromCR(STATE.cr);
const dfLeft = STATE.cr?.df_float || {m:0,c:0,d:0};

const dfSucked = {
  m: dfNew.m - dfLeft.m,
  c: dfNew.c - dfLeft.c,
  d: dfNew.d - dfLeft.d
};


function renderRRTable(rrTotals) {
  const entries = Object.entries(rrTotals);
  if (entries.length===0) {
    document.getElementById('rrTable').innerHTML = '<div class="mini">Nessun RR caricato.</div>';
    return;
  }
  const rows = entries.map(([p,v]) => `
    <tr><td>${p}</td><td>${fmt(v.m)}</td><td>${fmt(v.c)}</td><td>${fmt(v.d)}</td><td>${v.count||0}</td></tr>
  `).join('');
  document.getElementById('rrTable').innerHTML = `
    <table>
      <thead><tr><th>Giocatore</th><th>Metallo</th><th>Cristallo</th><th>Deuterio</th><th>RR</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>`;
}

function renderResults(computed) {
  const {players, totLoss, totRec, gain, quota} = computed;

  const header = `
    <div class="kpi">
      <div class="box"><div class="v">${fmt(totRec.m)} / ${fmt(totRec.c)} / ${fmt(totRec.d)}</div><div class="l">Riciclato totale (M/C/D)</div></div>
      <div class="box"><div class="v">${fmt(totLoss.m)} / ${fmt(totLoss.c)} / ${fmt(totLoss.d)}</div><div class="l">Perdite totali (M/C/D)</div></div>
      <div class="box"><div class="v">${fmt(gain.m)} / ${fmt(gain.c)} / ${fmt(gain.d)}</div><div class="l">Gain da dividere (M/C/D)</div></div>
    

<div class="box"><div class="v">${(() => { const df = computeDebrisFromCR(STATE.cr); return `${fmt(df.m)} / ${fmt(df.c)} / ${fmt(df.d)}`; })()}</div><div class="l">DF calcolato (30%) M/C/D</div></div>
</div>`;

  const rows = players.map(p => {
    const q = quota[p];
    const mClass = q.m>=0 ? 'good':'bad';
    const cClass = q.c>=0 ? 'good':'bad';
    const dClass = q.d>=0 ? 'good':'bad';
    return `
      <tr>
        <td>${p} <span class="mini">[${(q.w*100).toFixed(2)}%]</span></td>
        <td>${fmt(q.lost.m)}</td><td>${fmt(q.lost.c)}</td><td>${fmt(q.lost.d)}</td>
        <td>${fmt(q.rec.m)}</td><td>${fmt(q.rec.c)}</td><td>${fmt(q.rec.d)}</td>
        <td class="${mClass}">${fmt(q.m)}</td>
        <td class="${cClass}">${fmt(q.c)}</td>
        <td class="${dClass}">${fmt(q.d)}</td>
      </tr>`;
  }).join('');

  const table = `
    <table style="margin-top:10px">
      <thead>
        <tr>
          <th>Giocatore</th>
          <th>Perse M</th><th>Perse C</th><th>Perse D</th>
          <th>Raccolto M</th><th>Raccolto C</th><th>Raccolto D</th>
          <th>Quota M</th><th>Quota C</th><th>Quota D</th>
        </tr>
      </thead>
      <tbody>${rows}</tbody>
    </table>
    <div class="mini" style="margin-top:8px">
      Quota positiva = deve ricevere. Quota negativa = deve inviare.
    </div>`;

  document.getElementById('resultsTables').innerHTML = header + table;

  // transports
  const mt = buildTransfers(players, quota, 'm');
  const ct = buildTransfers(players, quota, 'c');
  const dt = buildTransfers(players, quota, 'd');

  function renderMoveList(label, moves) {
    if (!moves.length) return `<div class="mini">Nessun trasferimento per ${label} (gi√† bilanciato).</div>`;
    const r = moves.map(m => `<tr><td>${m.from}</td><td>${m.to}</td><td>${fmt(m.amount)}</td></tr>`).join('');
    return `
      <div style="margin-top:10px">
        <div class="mini" style="margin:6px 0"><b>${label}</b></div>
        <table>
          <thead><tr><th>Da</th><th>A</th><th>Quantit√†</th></tr></thead>
          <tbody>${r}</tbody>
        </table>
      </div>`;
  }
  document.getElementById('transports').innerHTML =
    renderMoveList('Metallo', mt) + renderMoveList('Cristallo', ct) + renderMoveList('Deuterio', dt);
}

function recomputeAndRender() {
  if (!STATE.cr) {
    log("‚ö†Ô∏è Nessun CR caricato.");
    return;
  }
  const mode = document.querySelector('input[name="mode"]:checked')?.value || 'paritaria';
  const rrTotals = STATE.rr || {};
  const computed = computeFromSheetLogic(STATE.cr, rrTotals, mode);
  renderResults(computed);
}

document.querySelectorAll('input[name="mode"]').forEach(r => r.addEventListener('change', () => {
  log("Modalit√†: " + document.querySelector('input[name="mode"]:checked').value);
  recomputeAndRender();
}));

document.getElementById('btnParseCR').addEventListener('click', () => {
  try {
    const text = document.getElementById('crText').value || '';
    const cr = parseCRText(text);
    STATE.cr = cr;
    renderKPI(cr);
    log(`‚úÖ CR caricato. Attaccanti: ${Object.keys(cr.attackers).length} ‚Ä¢ Difensori: ${Object.keys(cr.defenders).length} ‚Ä¢ Coord: ${cr.coords||'-'}`);
    recomputeAndRender();
    setTab('risultati');
  } catch (e) {
    log("‚ùå Errore parsing CR: " + (e?.message || e));
    console.error(e);
    setTab('log');
  }
});

document.getElementById('btnCRDemo').addEventListener('click', () => {
  const demo = `Il 28-01-2026 --:--:--, le seguenti flotte si scontrano in combattimento:

Attaccante Abubu [U E]
________________________________________________
Cargo Pesante 1
Caccia Leggero 3.226.909
Caccia Pesante 177.230
Incrociatore 557.550
Nave da battaglia 151.773
Corazzata 89.802
Incrociatore da Battaglia 462.085
Reaper 129.700
Pathfinder 96.320
_________________________________________

Difensore Bartok [SoV]
________________________________________________
Cargo leggero 515.205
Cargo Pesante 96.004
Caccia Leggero 487.861
_________________________________________

Dopo la battaglia...

Attaccante Abubu [U E]
________________________________________________
Cargo Pesante 1 ( -0 )
Caccia Leggero 2.961.733 ( -265.176 )
Caccia Pesante 167.384 ( -9.846 )
Incrociatore 544.263 ( -13.287 )
Nave da battaglia 150.566 ( -1.207 )
Corazzata 89.649 ( -153 )
Incrociatore da Battaglia 459.127 ( -2.958 )
Reaper 129.496 ( -204 )
Pathfinder 93.760 ( -2.560 )
_________________________________________

Difensore Bartok [SoV]
________________________________________________
Distrutto!
_________________________________________

L'attaccante saccheggia:
471.166.157 Metallo, 125.714.491 Cristallo e 21.863.628 Deuterio

L'attaccante ha perso un totale di 6.842.469.000 unit√†.
Il difensore ha perso un totale di 66.020.471.000 unit√†.
At these space coordinates now float 8.451.301.052 metal, 6.135.502.953 crystal and 1.725.266.027 deuterium.
La possibilit√† che si formi una luna dai detriti era del 22%.`;
  document.getElementById('crText').value = demo;
  log("Demo CR inserito.");
});

// -------- RR LOADER (API) --------
function abortableFetch(url, timeoutMs) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeoutMs);
  return fetch(url, {signal: controller.signal}).finally(() => clearTimeout(id));
}

// ----------------- CR API (NoMoreAngel api-reader) -----------------
function decodeEntities(html){
  const ta = document.createElement('textarea');
  ta.innerHTML = html || '';
  return ta.value;
}

async function fetchTextWithFallback(url, timeoutMs=12000){
  // 1) direct
  try{
    const res = await abortableFetch(url, timeoutMs);
    if(!res.ok) throw new Error('HTTP ' + res.status);
    return await res.text();
  }catch(e1){
    // 2) Jina AI text proxy (bypasses CORS on many sites)
    const clean = String(url).replace(/^https?:\/\//i,'');
    const jinaUrl = "https://r.jina.ai/http://" + clean;
    const res2 = await abortableFetch(jinaUrl, timeoutMs);
    if(!res2.ok) throw new Error('HTTP ' + res2.status);
    return await res2.text();
  }
}

const shipNameMapEN2IT = {
  "Small Cargo":"Cargo leggero",
  "Large Cargo":"Cargo Pesante",
  "Light Fighter":"Caccia Leggero",
  "Heavy Fighter":"Caccia Pesante",
  "Cruiser":"Incrociatore",
  "Battleship":"Nave da battaglia",
  "Colony Ship":"Colonizzatrice",
  "Recycler":"Riciclatrice",
  "Espionage Probe":"Sonda spia",
  "Bomber":"Bombardiere",
  "Solar Satellite":"Satellite Solare",
  "Destroyer":"Corazzata",
  "Deathstar":"Morte Nera",
  "Battlecruiser":"Incrociatore da Battaglia",
  "Crawler":"Crawler",
  "Reaper":"Reaper",
  "Pathfinder":"Pathfinder",
  "Rocket Launcher":"Lanciamissili",
  "Light Laser":"Laser leggero",
  "Heavy Laser":"Laser pesante",
  "Gauss Cannon":"Cannone Gauss",
  "Ion Cannon":"Cannone ionico",
  "Plasma Turret":"Cannone al Plasma",
  "Small Shield Dome":"Cupola scudo piccola",
  "Large Shield Dome":"Cupola scudo potenziata"
};

const knownShipNamesEN = Object.keys(shipNameMapEN2IT).sort((a,b)=>b.length-a.length);

function mapShipToIT(name){
  const n = (name || '').trim();
  return shipNameMapEN2IT[n] || n;
}

function matchKnownShipsEN(text){
  const out = [];
  const src = text || '';
  const esc = knownShipNamesEN.map(s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
  const re = new RegExp(`\\b(${esc.join('|')})\\b`, 'g');
  let m;
  while((m = re.exec(src)) !== null){
    out.push(m[1]);
  }
  return out;
}

function extractNums(text){
  return (String(text||'').match(/[\d\.,]+/g) || []);
}

function parseNmaApiReaderToClassic(raw){
  if(!raw) return null;

  let t = raw;
  const mdIdx = t.indexOf('Markdown Content:');
  if(mdIdx >= 0) t = t.slice(mdIdx + 'Markdown Content:'.length);

  const date = ((t.match(/Date:\s*([0-9]{2}-[0-9]{2}-[0-9]{4})/i) || [])[1]) || '--:--:--';
  const time = ((t.match(/Time:\s*([0-9]{2}:[0-9]{2}:[0-9]{2})/i) || [])[1]) || '--:--:--';

  const idxInit = t.search(/####\s*Initial\s*:/i);
  if(idxInit < 0) return null;

  // max 6 turns
  let maxRound = 0;
  const roundRe = /####\s*Round\s+(\d+)/gi;
  let rm;
  while((rm = roundRe.exec(t)) !== null){
    const r = parseInt(rm[1],10);
    if(!isNaN(r)) maxRound = Math.min(6, Math.max(maxRound, r));
  }
  if(maxRound < 1) maxRound = 1;

  const idxR1 = t.search(/####\s*Round\s+1/i);
  const initEnd = idxR1 >= 0 ? idxR1 : t.length;
  const initTxt = t.slice(idxInit, initEnd);

  const initial = { attackers:{}, defenders:{} };
  const nameToTag = {};

  const initEntityRe = /(Attacker|Defender)\s+\[[0-9:]+\]\s+([^\[]+?)\s+\[([^\]]+)\][\s\S]*?Type\s+([\s\S]*?)\s+Count\s+([\s\S]*?)(?=Weapon\s*:|Weapon\s|Shield\s*:|Shield\s|Armor\s*:|Armor\s|Attacker\s+\[|Defender\s+\[|$)/gi;
  let em;
  while((em = initEntityRe.exec(initTxt)) !== null){
    const side = em[1].toLowerCase();
    const name = (em[2]||'').trim();
    const tag = (em[3]||'').trim();
    const key = `${name} [${tag}]`;
    const typePart = em[4] || '';
    const countPart = em[5] || '';
    const shipsEN = matchKnownShipsEN(typePart);
    const nums = extractNums(countPart).map(parseNum);
    if(!shipsEN.length || !nums.length) continue;
    const target = side === 'attacker' ? initial.attackers : initial.defenders;
    if(!target[key]) target[key] = {};
    nameToTag[name] = tag;
    for(let i=0;i<Math.min(shipsEN.length, nums.length);i++){
      const itName = mapShipToIT(shipsEN[i]);
      target[key][itName] = (target[key][itName]||0) + nums[i];
    }
  }

  const idxRound = t.search(new RegExp(`####\\s*Round\\s+${maxRound}\\b`, 'i'));
  if(idxRound < 0) return null;
  const afterRound = t.slice(idxRound);
  const nextAfter = afterRound.slice(12).search(/####\s*Round\s+\d+/i);
  const endRound = nextAfter >= 0 ? (12 + nextAfter) : afterRound.length;
  const roundTxt = afterRound.slice(0, endRound);

  const final = { attackers:{}, defenders:{} };

  const chunkRe = /Attacker\s+([A-Za-z0-9_√Ä-√ø]+)\s+([\s\S]*?)(?=Attacker\s+[A-Za-z0-9_√Ä-√ø]+|Defender\s+|$)/g;
  let cm;
  while((cm = chunkRe.exec(roundTxt)) !== null){
    const shortName = (cm[1]||'').trim();
    const body = (cm[2]||'');
    const idxCount = body.search(/\bCount\b/i);
    if(idxCount < 0) continue;
    const beforeCount = body.slice(0, idxCount);
    const afterCount = body.slice(idxCount);
    const idxLost = afterCount.search(/\bLost\b/i);
    const countsPart = idxLost >= 0 ? afterCount.slice(0, idxLost) : afterCount;
    const shipsEN = matchKnownShipsEN(beforeCount);
    const nums = extractNums(countsPart).map(parseNum);
    if(!shipsEN.length || !nums.length) continue;
    const tag = nameToTag[shortName];
    const key = tag ? `${shortName} [${tag}]` : shortName;
    if(!final.attackers[key]) final.attackers[key] = {};
    for(let i=0;i<Math.min(shipsEN.length, nums.length);i++){
      const itName = mapShipToIT(shipsEN[i]);
      final.attackers[key][itName] = (final.attackers[key][itName]||0) + nums[i];
    }
  }

  const defChunkRe = /Defender\s+([A-Za-z0-9_√Ä-√ø]+)\s+([\s\S]*?)(?=Attacker\s+|$)/g;
  let dm;
  while((dm = defChunkRe.exec(roundTxt)) !== null){
    const shortName = (dm[1]||'').trim();
    const body = (dm[2]||'');
    const idxCount = body.search(/\bCount\b/i);
    if(idxCount < 0) continue;
    const beforeCount = body.slice(0, idxCount);
    const afterCount = body.slice(idxCount);
    const idxLost = afterCount.search(/\bLost\b/i);
    const countsPart = idxLost >= 0 ? afterCount.slice(0, idxLost) : afterCount;
    const shipsEN = matchKnownShipsEN(beforeCount);
    const nums = extractNums(countsPart).map(parseNum);
    const tag = nameToTag[shortName];
    const key = tag ? `${shortName} [${tag}]` : shortName;
    if(!final.defenders[key]) final.defenders[key] = {};
    for(let i=0;i<Math.min(shipsEN.length, nums.length);i++){
      const itName = mapShipToIT(shipsEN[i]);
      final.defenders[key][itName] = (final.defenders[key][itName]||0) + nums[i];
    }
  }

  // Build classic IT CR (initial + after battle)
  const lines = [];
  lines.push(`Il ${date} ${time}, le seguenti flotte si scontrano in combattimento:`);
  lines.push('');
  const atkKeys = Object.keys(initial.attackers);
  for(const k of atkKeys){
    lines.push('');
    lines.push(`Attaccante ${k}`);
    lines.push('________________________________________________');
    lines.push('');
    for(const [ship,qty] of Object.entries(initial.attackers[k]).sort((a,b)=>a[0].localeCompare(b[0],'it'))){
      lines.push(`${ship} ${fmt(qty)}`.replace(/\./g,'.'));
    }
    lines.push('_________________________________________');
    lines.push('');
  }
  const defKeys = Object.keys(initial.defenders);
  for(const k of defKeys){
    lines.push('');
    lines.push(`Difensore ${k}`);
    lines.push('________________________________________________');
    lines.push('');
    for(const [ship,qty] of Object.entries(initial.defenders[k]).sort((a,b)=>a[0].localeCompare(b[0],'it'))){
      lines.push(`${ship} ${fmt(qty)}`.replace(/\./g,'.'));
    }
    lines.push('_________________________________________');
    lines.push('');
  }

  lines.push('');
  lines.push('Dopo la battaglia...');
  lines.push('');

  for(const k of atkKeys){
    lines.push('');
    lines.push(`Attaccante ${k}`);
    lines.push('________________________________________________');
    lines.push('');
    const initShips = initial.attackers[k] || {};
    const finShips = final.attackers[k] || {};
    const shipSet = new Set([...Object.keys(initShips), ...Object.keys(finShips)]);
    for(const ship of Array.from(shipSet).sort((a,b)=>a.localeCompare(b,'it'))){
      const a0 = initShips[ship] || 0;
      const a1 = finShips[ship] || 0;
      const lost = Math.max(0, a0 - a1);
      lines.push(`${ship} ${fmt(a1)} ( -${fmt(lost)} )`);
    }
    lines.push('_________________________________________');
    lines.push('');
  }

  for(const k of defKeys){
    lines.push('');
    lines.push(`Difensore ${k}`);
    lines.push('________________________________________________');
    lines.push('');
    lines.push('Distrutto!');
    lines.push('_________________________________________');
    lines.push('');
  }

  // keep loot + debris if present
  const lootM = (t.match(/Metal loot:\s*([\d\.,]+)/i) || [])[1];
  const lootC = (t.match(/Crystal loot:\s*([\d\.,]+)/i) || [])[1];
  const lootD = (t.match(/Deuterium loot:\s*([\d\.,]+)/i) || [])[1];
  if(lootM || lootC || lootD){
    lines.push('');
    lines.push("L'attaccante saccheggia:");
    lines.push(`${lootM||'0'} Metallo, ${lootC||'0'} Cristallo e ${lootD||'0'} Deuterio`);
  }
  const dfM = (t.match(/Metal to debrisfield:\s*([\d\.,]+)/i) || [])[1];
  const dfC = (t.match(/Crystal to debrisfield:\s*([\d\.,]+)/i) || [])[1];
  const dfD = (t.match(/Deuterium to debrisfield:\s*([\d\.,]+)/i) || [])[1];
  if(dfM || dfC || dfD){
    lines.push('');
    lines.push(`At these space coordinates now float ${dfM||'0'} metal, ${dfC||'0'} crystal and ${dfD||'0'} deuterium.`);
  }

  return lines.join('\n');
}

document.getElementById('btnLoadCRApi')?.addEventListener('click', async () => {
  const apiId = (document.getElementById('crApiId')?.value || '').trim();
  if(!apiId){
    log("‚ö†Ô∏è Inserisci un API ID CR.");
    return;
  }
  const timeoutMs = parseNum(document.getElementById('timeoutMs')?.value) || 15000;
  const url = /^https?:\/\//i.test(apiId)
    ? apiId
    : `https://nomoreangel.de/api-reader/?apiid=${encodeURIComponent(apiId)}&engOut=on`;

  log(`CR API: richiesta NoMoreAngel per ${apiId}...`);
  try{
    const raw = await fetchTextWithFallback(url, timeoutMs);
    const classic = parseNmaApiReaderToClassic(raw);
    if(!classic){
      log("‚ùå CR API: non sono riuscito a convertire la pagina (manca sezione Initial/Round). Incolla manualmente il CR.");
      setTab('log');
      return;
    }
    document.getElementById('crText').value = classic;
    log("‚úÖ CR convertito (NoMoreAngel) incollato nel box. Ora analizzo...");
    document.getElementById('btnParseCR')?.click();
    setTab('risultati');
  }catch(e){
    log("‚ùå Errore fetch CR API: " + (e?.message || e));
    setTab('log');
  }
});
// ------------------------------------------------------------------


function extractPre(html) {
  const m = html.match(/<pre[^>]*>([\s\S]*?)<\/pre>/i);
  if (!m) return null;
  const txt = m[1]
    .replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&amp;/g,'&')
    .replace(/&#039;/g,"'").replace(/&quot;/g,'"');
  return txt;
}

function parseRRFromPre(pre) {
  // regex extraction from stdClass print_r
  const owner = (pre.match(/\[owner_name\]\s*=>\s*([^\r\n]+)/) || [])[1];
  if (!owner) return null;
  const m = parseNum((pre.match(/\[metal_retrieved\]\s*=>\s*([\d\.,]+)/) || [])[1]);
  const c = parseNum((pre.match(/\[crystal_retrieved\]\s*=>\s*([\d\.,]+)/) || [])[1]);
  const d = parseNum((pre.match(/\[deuterium_retrieved\]\s*=>\s*([\d\.,]+)/) || [])[1]);
  const coords = (pre.match(/\[coordinates\]\s*=>\s*([^\r\n]+)/) || [])[1] || '';
  const rrid = (pre.match(/\[rr_id\]\s*=>\s*([^\r\n]+)/) || [])[1] || '';
  return {owner: owner.trim(), m, c, d, coords: coords.trim(), rrid: rrid.trim()};
}

document.getElementById('btnLoadRR').addEventListener('click', async () => {
  const base = (document.getElementById('proxyBase').value || '').trim();
  const timeoutMs = parseNum(document.getElementById('timeoutMs').value) || 12000;
  const ids = (document.getElementById('rrIds').value || '').split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  if (!ids.length) {
    log("‚ö†Ô∏è Nessun RR apiid inserito.");
    return;
  }
  log(`Carico ${ids.length} RR...`);
  const rawLog = [];
  for (const id of ids) {
    const url = base + encodeURIComponent(id);
    try {
      const res = await abortableFetch(url, timeoutMs);
      const text = await res.text();
      rawLog.push(`--- ${id} status=${res.status} ok=${res.ok} url=${url} ---\n` + text.slice(0,1200));
      const pre = extractPre(text) || text;
      const parsed = parseRRFromPre(pre);
      if (!parsed) {
        log(`‚ùå RR non parsato: ${id} (owner_name non trovato)`);
        continue;
      }
      const p = parsed.owner;
      if (!STATE.rr[p]) STATE.rr[p] = {m:0,c:0,d:0,count:0, list:[]};
      STATE.rr[p].m += parsed.m;
      STATE.rr[p].c += parsed.c;
      STATE.rr[p].d += parsed.d;
      STATE.rr[p].count += 1;
      STATE.rr[p].list.push(parsed);
      log(`‚úÖ RR: ${p} +${fmt(parsed.m)}M +${fmt(parsed.c)}C +${fmt(parsed.d)}D (${parsed.coords})`);
    } catch (e) {
      log(`‚ùå Errore fetch RR ${id}: ${e?.message || e}`);
    }
  }
  document.getElementById('rrRaw').textContent = rawLog.join("\n\n");
  renderRRTable(STATE.rr);
  recomputeAndRender();
  setTab('risultati');
});

document.getElementById('btnClearRR').addEventListener('click', () => {
  STATE.rr = {};
  document.getElementById('rrRaw').textContent = '';
  renderRRTable(STATE.rr);
  recomputeAndRender();
  log("RR puliti.");
});

// ----------------- Condivisione (link con stato) -----------------
function encodeShareState(obj){
  // base64(url-safe) di JSON UTF-8
  const json = JSON.stringify(obj);
  const b64 = btoa(unescape(encodeURIComponent(json)))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/g, '');
  return b64;
}
function decodeShareState(b64){
  const pad = '==='.slice((b64.length + 3) % 4);
  const s = (b64 + pad).replace(/-/g, '+').replace(/_/g, '/');
  const json = decodeURIComponent(escape(atob(s)));
  return JSON.parse(json);
}
function collectShareState(){
  return {
    v: 1,
    crText: (document.getElementById('crText').value || '').trim(),
    proxyBase: (document.getElementById('proxyBase').value || '').trim(),
    timeoutMs: parseNum(document.getElementById('timeoutMs').value) || 12000,
    rrIds: (document.getElementById('rrIds').value || '').trim(),
    // per comodit√†: se hai gi√† caricato RR, includiamo anche il totale per player
    rrTotals: STATE.rr || {},
  };
}
function applyShareState(st){
  if (!st || typeof st !== 'object') return;
  if (typeof st.proxyBase === 'string' && st.proxyBase.trim()) document.getElementById('proxyBase').value = st.proxyBase.trim();
  if (st.timeoutMs) document.getElementById('timeoutMs').value = String(st.timeoutMs);
  if (typeof st.rrIds === 'string') document.getElementById('rrIds').value = st.rrIds;
  if (typeof st.crText === 'string') document.getElementById('crText').value = st.crText;

  // Se abbiamo gi√† totals, possiamo renderizzarli subito senza rifetch.
  if (st.rrTotals && typeof st.rrTotals === 'object' && Object.keys(st.rrTotals).length){
    STATE.rr = st.rrTotals;
    renderRRTable(STATE.rr);
  }
  // Analizza CR (se presente)
  if ((document.getElementById('crText').value || '').trim()) {
    try { document.getElementById('btnParseCR')?.click(); } catch(e){ log('Errore analisi CR da link: ' + (e?.message||e)); }
  }
  recomputeAndRender();
}
function shareLink(){
  const st = collectShareState();
  const token = encodeShareState(st);
  const url = `${location.origin}${location.pathname}#s=${token}`;
  return url;
}
async function doShare(){
  const url = shareLink();
  const title = 'Spartizione Detriti OGame';
  const text = 'Link con CR/RR precompilati';
  try {
    if (navigator.share) {
      await navigator.share({title, text, url});
      log('‚úÖ Link condiviso.');
      return;
    }
  } catch (e) {
    // se l'utente annulla, non √® un errore grave
  }
  try {
    await navigator.clipboard.writeText(url);
    log('‚úÖ Link copiato negli appunti.');
  } catch (e) {
    // fallback
    prompt('Copia questo link:', url);
    log('‚ÑπÔ∏è Link mostrato in prompt (clipboard non disponibile).');
  }
}

document.getElementById('btnShare').addEventListener('click', () => {
  doShare();
});

// Carica stato da hash (se presente)
(() => {
  const m = (location.hash || '').match(/#s=([A-Za-z0-9\-_]+)/);
  if (!m) return;
  try {
    const st = decodeShareState(m[1]);
    applyShareState(st);
    setTab('cr');
    log('üîó Stato caricato dal link.');
  } catch (e) {
    log('‚ö†Ô∏è Hash di condivisione non valido: ' + (e?.message || e));
  }
})();

// Initial
log("Pronto. 1) Incolla CR (testo) e Analizza. 2) Carica RR (API) per sommare raccolte. 3) Vedi Risultati.");
</script>
</body>
</html>
