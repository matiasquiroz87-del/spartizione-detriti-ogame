<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Spartizione Detriti OGame - CR (API) + RR (API)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800&family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#050a10;
    --text:#dbe7ff;
    --muted:#93a6c7;
    --line:rgba(120,160,220,.25);
    --good:#39d98a;
    --bad:#ff5c5c;
    --font-ui:"Rajdhani", system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial;
    --font-title:"Orbitron","Rajdhani", system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial;
    --header-h:72px; /* fallback, poi lo settiamo via JS */
  }

  *{box-sizing:border-box}
  body{margin:0;font-family:var(--font-ui);color:var(--text);background:var(--bg);}

  body::before{
    content:"";position:fixed;inset:0;z-index:-1;
    background:
      radial-gradient(1200px 700px at 15% -10%, rgba(124,240,255,.10), transparent 55%),
      radial-gradient(900px 600px at 110% 10%, rgba(255,179,77,.10), transparent 55%),
      radial-gradient(2px 2px at 20% 30%, rgba(255,255,255,.9), transparent 60%),
      radial-gradient(1px 1px at 40% 60%, rgba(255,255,255,.75), transparent 60%),
      radial-gradient(1px 1px at 70% 20%, rgba(255,255,255,.7), transparent 60%),
      radial-gradient(1px 1px at 85% 80%, rgba(255,255,255,.65), transparent 60%),
      radial-gradient(1px 1px at 10% 85%, rgba(255,255,255,.6), transparent 60%),
      radial-gradient(1px 1px at 95% 45%, rgba(255,255,255,.55), transparent 60%),
      linear-gradient(180deg, rgba(15,25,40,.65), rgba(5,10,16,1));
    filter:saturate(1.05) contrast(1.05);
  }

  header{
    position:sticky;top:0;z-index:10;
    background:linear-gradient(180deg, rgba(7,12,18,.92), rgba(7,12,18,.65));
    backdrop-filter:blur(10px);
    border-bottom:1px solid var(--line);
  }

  .wrap{max-width:1100px;margin:0 auto;padding:14px;}
  .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px;}
  .title{display:flex;align-items:center;gap:10px;min-width:0;}
  .actions{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end;}

  h1{
    font-family:var(--font-title);
    font-size:16px;margin:0;
    letter-spacing:.8px;text-transform:uppercase
  }

  .badge{
    font-size:12px;color:var(--muted);
    border:1px solid var(--line);
    padding:4px 8px;border-radius:999px;
    background:rgba(16,26,46,.6)
  }

  .grid{
    display:grid;
    grid-template-columns:1fr;
    gap:12px;
  }
  @media (min-width: 980px){
    .grid{grid-template-columns:1fr 1fr;}
  }

  .card{
    border:1px solid var(--line);
    background:linear-gradient(180deg, rgba(16,26,46,.8), rgba(14,23,40,.75));
    border-radius:16px;
    padding:12px;
    box-shadow:0 10px 30px rgba(0,0,0,.25);
  }

  .min-title{
    font-family:var(--font-title);
    letter-spacing:.8px;
    text-transform:uppercase;
    margin:0 0 8px 0;
    font-size:14px;
  }

  textarea,input{
    width:100%;
    background:rgba(8,12,20,.65);
    border:1px solid var(--line);
    color:var(--text);
    border-radius:12px;
    padding:10px;
    font-size:13px;
    outline:none
  }
  textarea{min-height:240px;resize:vertical;line-height:1.25}

  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .row > *{flex:1}

  button{
    border:1px solid rgba(88,166,255,.65);
    background:rgba(88,166,255,.15);
    color:var(--text);
    padding:9px 12px;border-radius:12px;
    cursor:pointer;font-weight:600
  }
  button:hover{background:rgba(88,166,255,.22)}

  .ghost{
    border-color:var(--line);
    background:rgba(16,26,46,.5);
    font-weight:600
  }
  .ghost:hover{background:rgba(16,26,46,.75)}

  .mini{font-size:12px;color:var(--muted)}
  .pill{
    display:inline-flex;gap:8px;align-items:center;
    border:1px solid var(--line);
    border-radius:999px;
    padding:6px 10px;
    background:rgba(16,26,46,.5)
  }
  .pill input{width:auto}

  .kpi{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px}
  .kpi .box{border:1px solid var(--line);background:rgba(8,12,20,.35);border-radius:12px;padding:10px}
  .kpi .box .v{font-size:14px;font-weight:800}
  .kpi .box .l{font-size:12px;color:var(--muted)}

  table{
    width:100%;
    border-collapse:collapse;
    overflow:hidden;border-radius:12px;
    border:1px solid var(--line);
    background:rgba(8,12,20,.35)
  }
  th,td{
    padding:8px 8px;
    border-bottom:1px solid rgba(34,52,85,.6);
    font-size:12px;
    text-align:right
  }
  th{
    color:var(--muted);
    font-weight:700;
    background:rgba(16,26,46,.55)
  }
  th:first-child, td:first-child{text-align:left}
  tr:last-child td{border-bottom:none}

  .good{color:var(--good)}
  .bad{color:var(--bad)}

  details{
    border:1px solid var(--line);
    border-radius:12px;
    padding:10px;
    background:rgba(8,12,20,.25)
  }
  summary{cursor:pointer;color:var(--muted);font-weight:700}
  pre{margin:0;white-space:pre-wrap;word-break:break-word;font-size:12px;color:#cfe0ff}

  .ico{width:16px;height:16px;vertical-align:-3px;margin-right:8px;fill:currentColor;opacity:.9}

  /* STAGES */
  .stage{transition:opacity .28s ease, transform .28s ease}
  .stage.hidden{display:none}
  .stage.fadeout{opacity:0;transform:translateY(6px);pointer-events:none}
  .stage.fadein{opacity:0;transform:translateY(6px)}
  .stage.fadein.show{opacity:1;transform:none}

  /* CR textarea nascosto */
  .cr-hidden{display:none !important;}

  /* LOG tab */
  .logTab{
    margin-top:12px;
    border:1px solid var(--line);
    border-radius:12px;
    background:rgba(8,12,20,.25);
    overflow:hidden;
  }
  .logTab summary{
    padding:10px 12px;
    font-family:var(--font-title);
    letter-spacing:.8px;
    text-transform:uppercase;
    font-size:13px;
    background:rgba(16,26,46,.55);
    user-select:none;
  }
  .logBoxWrap{padding:10px 12px}
  #logBox{min-height:180px}

  /* STAGE 1: sempre centrato e 1 colonna */
  #stage1{
    min-height:calc(100vh - var(--header-h));
    display:flex;
    align-items:center;
    justify-content:center;
    padding:24px 0;
  }
  #stage1 .grid{
    grid-template-columns:1fr !important;
    width:100%;
    max-width:860px;
    margin:0 auto;
    justify-items:center;
  }
  #stage1 .card{
    width:100%;
    max-width:860px;
  }

  /* STAGE 2: sempre ‚Äúin alto‚Äù sotto header */
  #stage2{
    min-height:calc(100vh - var(--header-h));
    padding-top:14px; /* subito sotto header, senza mega vuoto */
  }

  @media (max-height: 700px){
    #stage1{align-items:flex-start;}
  }
</style>
</head>

<body>
<header id="appHeader">
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1>Spartizione Detriti OGame</h1>
        <span class="badge">CR API + RR API ‚Ä¢ logica foglio di calcolo</span>
      </div>
      <div class="actions">
        <button class="ghost" id="btnShare" type="button" title="Copia un link con la configurazione">
          <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M18 16a3 3 0 0 0-2.24 1.02L8.91 13.7a3.2 3.2 0 0 0 0-3.4l6.85-3.32A3 3 0 1 0 15 5a2.98 2.98 0 0 0 .07.63L8.22 8.95A3 3 0 1 0 9 12a2.98 2.98 0 0 0-.07-.63l6.85 3.32A3 3 0 1 0 18 16Z"/>
          </svg>
          Condividi
        </button>
      </div>
    </div>
  </div>
</header>

<div class="wrap">

  <!-- STAGE 1 -->
  <div id="stage1" class="stage">
    <div class="grid">
      <div class="card">
        <h2 class="min-title">CR</h2>

        <div class="row" style="gap:8px; align-items:center; margin-bottom:10px;">
          <input id="crApiId" placeholder="API ID CR (es. cr-it-... oppure link api-reader)" style="flex:1; min-width:260px;">
          <button id="btnLoadCRApi" type="button">Carica CR da API</button>
        </div>

        <!-- CR nascosto (serve alla logica) -->
        <textarea id="crText" class="cr-hidden" aria-hidden="true"></textarea>

        <div class="mini" style="margin-top:8px">
          Premi ‚ÄúCarica CR da API‚Äù: il CR viene convertito e analizzato automaticamente.
        </div>

        <details class="logTab" id="logDetails">
          <summary>Log</summary>
          <div class="logBoxWrap">
            <pre id="logBox"></pre>
          </div>
        </details>

      </div>
    </div>
  </div>

  <!-- STAGE 2 -->
  <div id="stage2" class="stage hidden fadein">
    <div class="grid" style="margin-top:14px">
      <div class="card">
        <h2 class="min-title">RR + Spartizione</h2>

        <input id="proxyBase" type="hidden" value="https://ogame-api-proxy.matiasquiroz87.workers.dev/?apiid=" />
        <input id="timeoutMs" type="hidden" value="12000" />

        <div style="margin-top:8px">
          <label class="mini">Inserisci uno o pi√π RR apiid (uno per riga)</label>
          <textarea id="rrIds" placeholder="rr-it-269-...."></textarea>
        </div>

        <div class="row" style="margin-top:10px">
          <button id="btnLoadRR" type="button">Carica RR</button>
          <button id="btnClearRR" class="ghost" type="button">Pulisci</button>
        </div>

        <div class="row" style="margin-top:10px">
          <label class="pill"><input type="radio" name="mode" value="paritaria" checked> Paritaria</label>
          <label class="pill"><input type="radio" name="mode" value="equa"> Equa (peso flotta in campo)</label>
        </div>

        <div class="kpi" id="kpiCR"></div>

        <details style="margin-top:10px">
          <summary>Raccolte lette (RR)</summary>
          <div id="rrTable" style="margin-top:8px"></div>
          <details style="margin-top:10px">
            <summary>Dettagli RR (debug)</summary>
            <pre id="rrRaw"></pre>
          </details>
        </details>

        <div class="row" style="margin-top:10px">
          <button id="btnBack" class="ghost" type="button">‚Üê Torna al CR</button>
        </div>
      </div>

      <div class="card">
        <h2 class="min-title">Risultati</h2>
        <div style="margin-top:10px" id="resultsTables"></div>

        <details style="margin-top:12px" open>
          <summary>Trasporti finali suggeriti</summary>
          <div class="mini" style="margin-top:8px">
            Elenco di trasferimenti minimi tra chi deve inviare (negativo) e chi deve ricevere (positivo).
          </div>
          <div id="transports"></div>
        </details>
      </div>
    </div>
  </div>

</div>

<script>
/* ===================== HEADER HEIGHT -> CSS VAR ===================== */
function updateHeaderHeight(){
  const h = document.getElementById('appHeader')?.offsetHeight || 72;
  document.documentElement.style.setProperty('--header-h', h + 'px');
}
window.addEventListener('resize', updateHeaderHeight);
updateHeaderHeight();

/* ===================== CONFIG ===================== */
const DF_RATE = 0.30;
const COSTS = {"Cargo leggero":[2000,2000,0],"Cargo Pesante":[6000,6000,0],"Caccia Leggero":[3000,1000,0],"Caccia Pesante":[6000,4000,0],"Incrociatore":[20000,7000,2000],"Nave da battaglia":[45000,15000,0],"Bombardiere":[50000,25000,15000],"Corazzata":[60000,50000,15000],"Incrociatore da Battaglia":[30000,40000,15000],"Reaper":[85000,55000,20000],"Pathfinder":[8000,15000,8000],"Riciclatrice":[10000,6000,2000],"Colonizzatrice":[10000,20000,10000],"Sonda spia":[0,1000,0],"Satellite Solare":[0,2000,500],"Crawler":[2000,2000,1000],"Morte Nera":[5000000,4000000,1000000],"Lanciamissili":[2000,0,0],"Laser leggero":[1500,500,0],"Laser pesante":[6000,2000,0],"Cannone Gauss":[20000,15000,2000],"Cannone ionico":[2000,6000,0],"Cannone al Plasma":[50000,50000,30000],"Cupola scudo piccola":[10000,10000,0],"Cupola scudo potenziata":[50000,50000,0]};
const DF_ALLOWED = new Set(["Cargo leggero","Cargo Pesante","Caccia Leggero","Caccia Pesante","Incrociatore","Nave da battaglia","Bombardiere","Corazzata","Incrociatore da Battaglia","Morte Nera","Reaper","Pathfinder","Colonizzatrice","Riciclatrice","Sonda spia","Crawler","Satellite Solare"]);

/* ===================== UTILS ===================== */
function fmt(n){ if(n===null||n===undefined||isNaN(n)) return "-"; return Math.round(n).toLocaleString("it-IT"); }
function parseNum(str){
  if(str===null||str===undefined) return 0;
  const s = String(str).replace(/\./g,"").replace(/,/g,"").replace(/\s+/g,"").trim();
  const n = Number(s);
  return isNaN(n)?0:n;
}
const LOG=[];
function log(msg){
  const t = new Date().toLocaleTimeString();
  const line = `[${t}] ${msg}`;
  LOG.push(line);
  const el = document.getElementById("logBox");
  if(el) el.textContent = LOG.join("\n");
}

/* ===================== STAGES ===================== */
function showStage(id){
  const s1 = document.getElementById('stage1');
  const s2 = document.getElementById('stage2');
  if(!s1 || !s2) return;

  // IMPORTANTISSIMO: quando cambi stage, vai sempre in alto
  window.scrollTo({top: 0, left: 0, behavior: "auto"});

  if(id===1){
    s2.classList.remove('show');
    s2.classList.add('hidden');
    s1.classList.remove('hidden','fadeout');
    return;
  }

  s1.classList.add('fadeout');
  setTimeout(()=>{
    s1.classList.add('hidden');
    s2.classList.remove('hidden');
    requestAnimationFrame(()=>s2.classList.add('show'));
  },260);
}

/* ===================== STATE ===================== */
const STATE = { cr:null, rr:{} };

/* ===================== CR PARSER ===================== */
function parseCRText(text){
  const out = { attackers:{}, defenders:{}, coords:null, loot:{m:0,c:0,d:0}, df_float:{m:0,c:0,d:0}, moonChance:null, lossesUnits:{att:0,def:0} };

  const coordM = text.match(/\b\[(\d+:\d+:\d+)\]|\b(\d+:\d+:\d+)\b/);
  if(coordM) out.coords = (coordM[1]||coordM[2]||null);

  const moonM = text.match(/possibilit[a√†].*?luna.*?(\d+)%/i);
  if(moonM) out.moonChance = parseNum(moonM[1]);

  const lootM = text.match(/saccheggia:\s*([\d\.,]+)\s*Metallo,\s*([\d\.,]+)\s*Cristallo\s*e\s*([\d\.,]+)\s*Deuterio/i);
  if(lootM){ out.loot.m=parseNum(lootM[1]); out.loot.c=parseNum(lootM[2]); out.loot.d=parseNum(lootM[3]); }

  const dfLine = text.match(/(At these space coordinates now float|Alle coordinate.*fluttuano|A queste coordinate.*fluttuano)[\s\S]*?([\d\.,]+)[\s\S]*?([\d\.,]+)[\s\S]*?([\d\.,]+)/i);
  if(dfLine){
    out.df_float.m=parseNum(dfLine[2]); out.df_float.c=parseNum(dfLine[3]); out.df_float.d=parseNum(dfLine[4]);
  }

  let pre=text, post="";
  const idx=text.search(/\bDopo\s+la\s+battaglia\b/i);
  if(idx>=0){ pre=text.slice(0,idx); post=text.slice(idx); }

  function parseSideBlocks(blockText, phase){
    const lines=blockText.split(/\r?\n/);
    let current=null;

    for(const raw of lines){
      const line=raw.trim();
      if(!line) continue;

      const h=line.match(/^(Attaccante|Difensore)\s+(.+?)\s+\[(.+?)\]\s*$/i);
      if(h){
        const side=h[1].toLowerCase().startsWith("att")?"att":"def";
        const name=h[2].trim(), tag=h[3].trim();
        if(side==="att"){
          if(!out.attackers[name]) out.attackers[name]={tag,initial:{},final:{}};
          out.attackers[name].tag=tag; current=out.attackers[name];
        }else{
          if(!out.defenders[name]) out.defenders[name]={tag,initial:{},final:{}};
          out.defenders[name].tag=tag; current=out.defenders[name];
        }
        continue;
      }

      if(!current) continue;
      if(line.startsWith("_")) continue;
      if(line.toLowerCase().includes("distrutto")) continue;

      const m=line.match(/^(.+?)\s+([\d\.,]+)(?:\s*\(\s*-[\d\.,]+\s*\))?\s*$/);
      if(m){
        const ship=m[1].trim();
        const count=parseNum(m[2]);
        if(phase==="initial") current.initial[ship]=(current.initial[ship]||0)+count;
        else current.final[ship]=(current.final[ship]||0)+count;
      }
    }
  }

  parseSideBlocks(pre,"initial");
  if(post) parseSideBlocks(post,"final");

  Object.values(out.attackers).forEach(p=>{
    if(!p.final || Object.keys(p.final).length===0) p.final=JSON.parse(JSON.stringify(p.initial));
  });

  out.df_calc = computeDebrisFromCR(out);
  return out;
}

function computeDebrisFromCR(cr){
  const sum={m:0,c:0,d:0};
  function add(sideObj){
    for(const p of Object.values(sideObj||{})){
      const ini=p.initial||{};
      const fin=(p.final && Object.keys(p.final).length)?p.final:{};
      const ships=new Set([...Object.keys(ini),...Object.keys(fin)]);
      for(const ship of ships){
        const lost=Math.max(0,(ini[ship]||0)-(fin[ship]||0));
        if(!lost) continue;
        const cost=COSTS[ship];
        if(!cost) continue;
        if(!DF_ALLOWED.has(ship)) continue;
        sum.m += cost[0]*lost*DF_RATE;
        sum.c += cost[1]*lost*DF_RATE;
        sum.d += cost[2]*lost*DF_RATE;
      }
    }
  }
  add(cr.attackers); add(cr.defenders);
  return sum;
}

/* ===================== SHEET LOGIC ===================== */
function computeFromSheetLogic(cr, rrTotals, mode){
  const players=Object.keys(cr.attackers);
  const n=players.length||1;

  const losses={}, fleetValue={};
  players.forEach(name=>{
    const p=cr.attackers[name];
    losses[name]={m:0,c:0,d:0,units:0};
    fleetValue[name]=0;

    for(const [ship,cnt] of Object.entries(p.initial)){
      const cost=COSTS[ship];
      if(cost) fleetValue[name]+=(cost[0]+cost[1]+cost[2])*cnt;
    }

    const ships=new Set([...Object.keys(p.initial),...Object.keys(p.final)]);
    for(const ship of ships){
      const lostCnt=Math.max(0,(p.initial[ship]||0)-(p.final[ship]||0));
      if(lostCnt<=0) continue;
      const cost=COSTS[ship];
      if(!cost) continue;
      losses[name].m+=cost[0]*lostCnt;
      losses[name].c+=cost[1]*lostCnt;
      losses[name].d+=cost[2]*lostCnt;
    }
  });

  const totLoss=players.reduce((a,nm)=>({m:a.m+losses[nm].m,c:a.c+losses[nm].c,d:a.d+losses[nm].d}),{m:0,c:0,d:0});
  const totRec=players.reduce((a,nm)=>{const r=rrTotals[nm]||{m:0,c:0,d:0};return {m:a.m+r.m,c:a.c+r.c,d:a.d+r.d};},{m:0,c:0,d:0});
  const gain={m:totRec.m-totLoss.m,c:totRec.c-totLoss.c,d:totRec.d-totLoss.d};

  const weights={};
  if(mode==="paritaria"){ players.forEach(nm=>weights[nm]=1/n); }
  else{
    const totFleet=players.reduce((s,nm)=>s+(fleetValue[nm]||0),0)||1;
    players.forEach(nm=>weights[nm]=(fleetValue[nm]||0)/totFleet);
  }

  const quota={};
  players.forEach(nm=>{
    const r=rrTotals[nm]||{m:0,c:0,d:0};
    quota[nm]={
      m:losses[nm].m + gain.m*weights[nm] - r.m,
      c:losses[nm].c + gain.c*weights[nm] - r.c,
      d:losses[nm].d + gain.d*weights[nm] - r.d,
      w:weights[nm],
      lost:losses[nm],
      rec:r
    };
  });

  return {players,totLoss,totRec,gain,quota};
}

function buildTransfers(players, quota, resKey){
  const recv=[], send=[];
  players.forEach(p=>{
    const v=quota[p][resKey];
    if(v>0.5) recv.push([p,v]);
    else if(v<-0.5) send.push([p,-v]);
  });
  recv.sort((a,b)=>b[1]-a[1]); send.sort((a,b)=>b[1]-a[1]);
  const moves=[]; let i=0,j=0;
  while(i<send.length && j<recv.length){
    const [sp,sv]=send[i], [rp,rv]=recv[j];
    const x=Math.min(sv,rv);
    if(x>0.5) moves.push({from:sp,to:rp,amount:x});
    send[i][1]-=x; recv[j][1]-=x;
    if(send[i][1]<=0.5) i++;
    if(recv[j][1]<=0.5) j++;
  }
  return moves;
}

/* ===================== RENDER ===================== */
function renderKPI(cr){
  const el=document.getElementById("kpiCR");
  if(!el) return;
  if(!cr){ el.innerHTML=""; return; }

  const dfNew=computeDebrisFromCR(cr);
  const rrTotals=STATE.rr||{};
  const rr=Object.values(rrTotals).reduce((a,v)=>({m:a.m+(v.m||0),c:a.c+(v.c||0),d:a.d+(v.d||0)}),{m:0,c:0,d:0});
  const dfLeft={m:dfNew.m-rr.m, c:dfNew.c-rr.c, d:dfNew.d-rr.d};

  el.innerHTML=`
    <div class="box"><div class="v">${fmt(dfNew.m)}</div><div class="l">DF totale M (30%)</div></div>
    <div class="box"><div class="v">${fmt(dfNew.c)}</div><div class="l">DF totale C (30%)</div></div>
    <div class="box"><div class="v">${fmt(dfNew.d)}</div><div class="l">DF totale D (30%)</div></div>

    <div class="box"><div class="v">${fmt(rr.m)}</div><div class="l">RR raccolto M</div></div>
    <div class="box"><div class="v">${fmt(rr.c)}</div><div class="l">RR raccolto C</div></div>
    <div class="box"><div class="v">${fmt(rr.d)}</div><div class="l">RR raccolto D</div></div>

    <div class="box"><div class="v">${fmt(dfLeft.m)}</div><div class="l">DF rimasto M (stim.)</div></div>
    <div class="box"><div class="v">${fmt(dfLeft.c)}</div><div class="l">DF rimasto C (stim.)</div></div>
    <div class="box"><div class="v">${fmt(dfLeft.d)}</div><div class="l">DF rimasto D (stim.)</div></div>
  `;
}

function renderRRTable(rrTotals){
  const el=document.getElementById("rrTable");
  if(!el) return;
  const entries=Object.entries(rrTotals||{});
  if(!entries.length){ el.innerHTML='<div class="mini">Nessun RR caricato.</div>'; return; }
  const rows=entries.map(([p,v])=>`<tr><td>${p}</td><td>${fmt(v.m)}</td><td>${fmt(v.c)}</td><td>${fmt(v.d)}</td><td>${v.count||0}</td></tr>`).join("");
  el.innerHTML=`<table><thead><tr><th>Giocatore</th><th>Metallo</th><th>Cristallo</th><th>Deuterio</th><th>RR</th></tr></thead><tbody>${rows}</tbody></table>`;
}

function renderResults(computed){
  const {players,totLoss,totRec,gain,quota}=computed;

  const header=`
    <div class="kpi">
      <div class="box"><div class="v">${fmt(totRec.m)} / ${fmt(totRec.c)} / ${fmt(totRec.d)}</div><div class="l">Riciclato totale (M/C/D)</div></div>
      <div class="box"><div class="v">${fmt(totLoss.m)} / ${fmt(totLoss.c)} / ${fmt(totLoss.d)}</div><div class="l">Perdite totali (M/C/D)</div></div>
      <div class="box"><div class="v">${fmt(gain.m)} / ${fmt(gain.c)} / ${fmt(gain.d)}</div><div class="l">Gain da dividere (M/C/D)</div></div>
    </div>`;

  const rows=players.map(p=>{
    const q=quota[p];
    const mClass=q.m>=0?"good":"bad";
    const cClass=q.c>=0?"good":"bad";
    const dClass=q.d>=0?"good":"bad";
    return `
      <tr>
        <td>${p} <span class="mini">[${(q.w*100).toFixed(2)}%]</span></td>
        <td>${fmt(q.lost.m)}</td><td>${fmt(q.lost.c)}</td><td>${fmt(q.lost.d)}</td>
        <td>${fmt(q.rec.m)}</td><td>${fmt(q.rec.c)}</td><td>${fmt(q.rec.d)}</td>
        <td class="${mClass}">${fmt(q.m)}</td>
        <td class="${cClass}">${fmt(q.c)}</td>
        <td class="${dClass}">${fmt(q.d)}</td>
      </tr>`;
  }).join("");

  const table=`
    <table style="margin-top:10px">
      <thead>
        <tr>
          <th>Giocatore</th>
          <th>Perse M</th><th>Perse C</th><th>Perse D</th>
          <th>Raccolto M</th><th>Raccolto C</th><th>Raccolto D</th>
          <th>Quota M</th><th>Quota C</th><th>Quota D</th>
        </tr>
      </thead>
      <tbody>${rows}</tbody>
    </table>
    <div class="mini" style="margin-top:8px">Quota positiva = deve ricevere. Quota negativa = deve inviare.</div>`;

  document.getElementById("resultsTables").innerHTML = header + table;

  const mt=buildTransfers(players,quota,"m");
  const ct=buildTransfers(players,quota,"c");
  const dt=buildTransfers(players,quota,"d");

  function renderMoveList(label,moves){
    if(!moves.length) return `<div class="mini">Nessun trasferimento per ${label} (gi√† bilanciato).</div>`;
    const r=moves.map(m=>`<tr><td>${m.from}</td><td>${m.to}</td><td>${fmt(m.amount)}</td></tr>`).join("");
    return `<div style="margin-top:10px"><div class="mini" style="margin:6px 0"><b>${label}</b></div><table><thead><tr><th>Da</th><th>A</th><th>Quantit√†</th></tr></thead><tbody>${r}</tbody></table></div>`;
  }
  document.getElementById("transports").innerHTML =
    renderMoveList("Metallo",mt) + renderMoveList("Cristallo",ct) + renderMoveList("Deuterio",dt);
}

function recomputeAndRender(){
  if(!STATE.cr){ return; }
  const mode=document.querySelector('input[name="mode"]:checked')?.value || "paritaria";
  renderResults(computeFromSheetLogic(STATE.cr, STATE.rr||{}, mode));
}

document.querySelectorAll('input[name="mode"]').forEach(r=>r.addEventListener("change",()=>{
  log("Modalit√†: " + document.querySelector('input[name="mode"]:checked').value);
  recomputeAndRender();
}));

function analyzeCurrentCR(){
  const text = document.getElementById("crText").value || "";
  if(!text.trim()){
    log("‚ö†Ô∏è Nessun CR presente. Caricalo da API.");
    return;
  }
  const cr=parseCRText(text);
  STATE.cr=cr;
  renderKPI(cr);
  recomputeAndRender();
  log("‚úÖ CR caricato e analizzato.");
  showStage(2);
}

/* ===================== BACK ===================== */
document.getElementById("btnBack").addEventListener("click",()=>showStage(1));

/* ===================== FETCH HELPERS ===================== */
function abortableFetch(url, timeoutMs){
  const controller=new AbortController();
  const id=setTimeout(()=>controller.abort(), timeoutMs);
  return fetch(url,{signal:controller.signal}).finally(()=>clearTimeout(id));
}
async function fetchTextWithFallback(url, timeoutMs=12000){
  try{
    const res=await abortableFetch(url,timeoutMs);
    if(!res.ok) throw new Error("HTTP "+res.status);
    return await res.text();
  }catch(e1){
    const clean=String(url).replace(/^https?:\/\//i,"");
    const jinaUrl="https://r.jina.ai/http://" + clean;
    const res2=await abortableFetch(jinaUrl,timeoutMs);
    if(!res2.ok) throw new Error("HTTP "+res2.status);
    return await res2.text();
  }
}

/* ===================== NMA CONVERTER ===================== */
const shipNameMapEN2IT = {
  "Small Cargo":"Cargo leggero","Large Cargo":"Cargo Pesante","Light Fighter":"Caccia Leggero","Heavy Fighter":"Caccia Pesante",
  "Cruiser":"Incrociatore","Battleship":"Nave da battaglia","Colony Ship":"Colonizzatrice","Recycler":"Riciclatrice",
  "Espionage Probe":"Sonda spia","Bomber":"Bombardiere","Solar Satellite":"Satellite Solare","Destroyer":"Corazzata",
  "Deathstar":"Morte Nera","Battlecruiser":"Incrociatore da Battaglia","Crawler":"Crawler","Reaper":"Reaper","Pathfinder":"Pathfinder",
  "Rocket Launcher":"Lanciamissili","Light Laser":"Laser leggero","Heavy Laser":"Laser pesante","Gauss Cannon":"Cannone Gauss",
  "Ion Cannon":"Cannone ionico","Plasma Turret":"Cannone al Plasma","Small Shield Dome":"Cupola scudo piccola","Large Shield Dome":"Cupola scudo potenziata"
};
const knownShipNamesEN = Object.keys(shipNameMapEN2IT).sort((a,b)=>b.length-a.length);
function mapShipToIT(name){ const n=(name||"").trim(); return shipNameMapEN2IT[n] || n; }
function matchKnownShipsEN(text){
  const out=[];
  const esc=knownShipNamesEN.map(s=>s.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"));
  const re=new RegExp(`\\b(${esc.join("|")})\\b`,"g");
  let m;
  while((m=re.exec(text||""))!==null) out.push(m[1]);
  return out;
}
function extractNums(text){ return (String(text||"").match(/[\d\.,]+/g) || []); }

function parseNmaApiReaderToClassic(raw){
  if(!raw) return null;
  let t=raw;
  const mdIdx=t.indexOf("Markdown Content:");
  if(mdIdx>=0) t=t.slice(mdIdx+"Markdown Content:".length);

  const idxInit=t.search(/####\s*Initial\s*:/i);
  if(idxInit<0) return null;

  const date=((t.match(/Date:\s*([0-9]{2}-[0-9]{2}-[0-9]{4})/i)||[])[1])||"--:--:--";
  const time=((t.match(/Time:\s*([0-9]{2}:[0-9]{2}:[0-9]{2})/i)||[])[1])||"--:--:--";

  let maxRound=0;
  const roundRe=/####\s*Round\s+(\d+)/gi;
  let rm;
  while((rm=roundRe.exec(t))!==null){
    const r=parseInt(rm[1],10);
    if(!isNaN(r)) maxRound=Math.min(6,Math.max(maxRound,r));
  }
  if(maxRound<1) maxRound=1;

  const idxR1=t.search(/####\s*Round\s+1/i);
  const initEnd=idxR1>=0?idxR1:t.length;
  const initTxt=t.slice(idxInit,initEnd);

  const initial={attackers:{},defenders:{}};
  const nameToTag={};

  const initEntityRe=/(Attacker|Defender)\s+\[[0-9:]+\]\s+([^\[]+?)\s+\[([^\]]+)\][\s\S]*?Type\s+([\s\S]*?)\s+Count\s+([\s\S]*?)(?=Weapon\s*:|Weapon\s|Shield\s*:|Shield\s|Armor\s*:|Armor\s|Attacker\s+\[|Defender\s+\[|$)/gi;
  let em;
  while((em=initEntityRe.exec(initTxt))!==null){
    const side=em[1].toLowerCase();
    const name=(em[2]||"").trim();
    const tag=(em[3]||"").trim();
    const key=`${name} [${tag}]`;
    const shipsEN=matchKnownShipsEN(em[4]||"");
    const nums=extractNums(em[5]||"").map(parseNum);
    if(!shipsEN.length || !nums.length) continue;
    const target = side==="attacker" ? initial.attackers : initial.defenders;
    if(!target[key]) target[key]={};
    nameToTag[name]=tag;
    for(let i=0;i<Math.min(shipsEN.length,nums.length);i++){
      const itName=mapShipToIT(shipsEN[i]);
      target[key][itName]=(target[key][itName]||0)+nums[i];
    }
  }

  const idxRound=t.search(new RegExp(`####\\s*Round\\s+${maxRound}\\b`,"i"));
  if(idxRound<0) return null;
  const afterRound=t.slice(idxRound);
  const nextAfter=afterRound.slice(12).search(/####\s*Round\s+\d+/i);
  const endRound=nextAfter>=0?(12+nextAfter):afterRound.length;
  const roundTxt=afterRound.slice(0,endRound);

  const final={attackers:{},defenders:{}};

  const chunkRe=/Attacker\s+([A-Za-z0-9_√Ä-√ø]+)\s+([\s\S]*?)(?=Attacker\s+[A-Za-z0-9_√Ä-√ø]+|Defender\s+|$)/g;
  let cm;
  while((cm=chunkRe.exec(roundTxt))!==null){
    const shortName=(cm[1]||"").trim();
    const body=(cm[2]||"");
    const idxCount=body.search(/\bCount\b/i);
    if(idxCount<0) continue;
    const beforeCount=body.slice(0,idxCount);
    const afterCount=body.slice(idxCount);
    const idxLost=afterCount.search(/\bLost\b/i);
    const countsPart=idxLost>=0?afterCount.slice(0,idxLost):afterCount;
    const shipsEN=matchKnownShipsEN(beforeCount);
    const nums=extractNums(countsPart).map(parseNum);
    if(!shipsEN.length || !nums.length) continue;
    const tag=nameToTag[shortName];
    const key=tag?`${shortName} [${tag}]`:shortName;
    if(!final.attackers[key]) final.attackers[key]={};
    for(let i=0;i<Math.min(shipsEN.length,nums.length);i++){
      const itName=mapShipToIT(shipsEN[i]);
      final.attackers[key][itName]=(final.attackers[key][itName]||0)+nums[i];
    }
  }

  const lines=[];
  lines.push(`Il ${date} ${time}, le seguenti flotte si scontrano in combattimento:\n`);

  for(const k of Object.keys(initial.attackers)){
    lines.push(`Attaccante ${k}`);
    lines.push("________________________________________________");
    lines.push("");
    for(const [ship,qty] of Object.entries(initial.attackers[k]).sort((a,b)=>a[0].localeCompare(b[0],"it"))){
      lines.push(`${ship} ${fmt(qty)}`);
    }
    lines.push("_________________________________________\n");
  }
  for(const k of Object.keys(initial.defenders)){
    lines.push(`Difensore ${k}`);
    lines.push("________________________________________________");
    lines.push("");
    for(const [ship,qty] of Object.entries(initial.defenders[k]).sort((a,b)=>a[0].localeCompare(b[0],"it"))){
      lines.push(`${ship} ${fmt(qty)}`);
    }
    lines.push("_________________________________________\n");
  }

  lines.push("\nDopo la battaglia...\n");
  for(const k of Object.keys(initial.attackers)){
    lines.push(`Attaccante ${k}`);
    lines.push("________________________________________________");
    lines.push("");
    const initShips=initial.attackers[k]||{};
    const finShips=final.attackers[k]||{};
    const shipSet=new Set([...Object.keys(initShips),...Object.keys(finShips)]);
    for(const ship of Array.from(shipSet).sort((a,b)=>a.localeCompare(b,"it"))){
      const a0=initShips[ship]||0;
      const a1=finShips[ship]||0;
      const lost=Math.max(0,a0-a1);
      lines.push(`${ship} ${fmt(a1)} ( -${fmt(lost)} )`);
    }
    lines.push("_________________________________________\n");
  }

  const dfM=(t.match(/Metal to debrisfield:\s*([\d\.,]+)/i)||[])[1];
  const dfC=(t.match(/Crystal to debrisfield:\s*([\d\.,]+)/i)||[])[1];
  const dfD=(t.match(/Deuterium to debrisfield:\s*([\d\.,]+)/i)||[])[1];
  if(dfM||dfC||dfD){
    lines.push(`At these space coordinates now float ${dfM||"0"} metal, ${dfC||"0"} crystal and ${dfD||"0"} deuterium.`);
  }

  return lines.join("\n");
}

/* ===================== CR API LOADER ===================== */
document.getElementById("btnLoadCRApi").addEventListener("click", async ()=>{
  const apiId=(document.getElementById("crApiId").value||"").trim();
  if(!apiId){ log("‚ö†Ô∏è Inserisci un API ID CR."); return; }
  const timeoutMs=parseNum(document.getElementById("timeoutMs")?.value)||15000;

  const url = /^https?:\/\//i.test(apiId)
    ? apiId
    : `https://nomoreangel.de/api-reader/?apiid=${encodeURIComponent(apiId)}&engOut=on`;

  log(`CR API: richiesta NoMoreAngel per ${apiId}...`);
  try{
    const raw=await fetchTextWithFallback(url,timeoutMs);
    const classic=parseNmaApiReaderToClassic(raw);
    if(!classic){ log("‚ùå CR API: non sono riuscito a convertire la pagina (manca Initial/Round)."); return; }
    document.getElementById("crText").value=classic;
    log("‚úÖ CR caricato da API. Analizzo...");
    analyzeCurrentCR();
  }catch(e){
    log("‚ùå Errore fetch CR API: " + (e?.message || e));
  }
});

/* ===================== RR ===================== */
function extractPre(html){
  const m=html.match(/<pre[^>]*>([\s\S]*?)<\/pre>/i);
  if(!m) return null;
  return m[1].replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&amp;/g,"&").replace(/&#039;/g,"'").replace(/&quot;/g,'"');
}
function parseRRFromPre(pre){
  const owner=(pre.match(/\[owner_name\]\s*=>\s*([^\r\n]+)/)||[])[1];
  if(!owner) return null;
  const m=parseNum((pre.match(/\[metal_retrieved\]\s*=>\s*([\d\.,]+)/)||[])[1]);
  const c=parseNum((pre.match(/\[crystal_retrieved\]\s*=>\s*([\d\.,]+)/)||[])[1]);
  const d=parseNum((pre.match(/\[deuterium_retrieved\]\s*=>\s*([\d\.,]+)/)||[])[1]);
  const coords=(pre.match(/\[coordinates\]\s*=>\s*([^\r\n]+)/)||[])[1]||"";
  const rrid=(pre.match(/\[rr_id\]\s*=>\s*([^\r\n]+)/)||[])[1]||"";
  return {owner:owner.trim(),m,c,d,coords:coords.trim(),rrid:rrid.trim()};
}

document.getElementById("btnLoadRR").addEventListener("click", async ()=>{
  const base=(document.getElementById("proxyBase").value||"").trim();
  const timeoutMs=parseNum(document.getElementById("timeoutMs").value)||12000;
  const ids=(document.getElementById("rrIds").value||"").split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  if(!ids.length){ log("‚ö†Ô∏è Nessun RR apiid inserito."); return; }

  log(`Carico ${ids.length} RR...`);
  const rawLog=[];
  for(const id of ids){
    const url=base+encodeURIComponent(id);
    try{
      const res=await abortableFetch(url,timeoutMs);
      const text=await res.text();
      rawLog.push(`--- ${id} status=${res.status} ok=${res.ok} url=${url} ---\n` + text.slice(0,1200));
      const pre=extractPre(text)||text;
      const parsed=parseRRFromPre(pre);
      if(!parsed){ log(`‚ùå RR non parsato: ${id} (owner_name non trovato)`); continue; }

      const p=parsed.owner;
      if(!STATE.rr[p]) STATE.rr[p]={m:0,c:0,d:0,count:0,list:[]};
      STATE.rr[p].m += parsed.m;
      STATE.rr[p].c += parsed.c;
      STATE.rr[p].d += parsed.d;
      STATE.rr[p].count += 1;
      STATE.rr[p].list.push(parsed);
      log(`‚úÖ RR: ${p} +${fmt(parsed.m)}M +${fmt(parsed.c)}C +${fmt(parsed.d)}D (${parsed.coords})`);
    }catch(e){
      log(`‚ùå Errore fetch RR ${id}: ${e?.message || e}`);
    }
  }
  document.getElementById("rrRaw").textContent = rawLog.join("\n\n");
  renderRRTable(STATE.rr);
  renderKPI(STATE.cr);
  recomputeAndRender();
});

document.getElementById("btnClearRR").addEventListener("click", ()=>{
  STATE.rr={};
  document.getElementById("rrRaw").textContent="";
  renderRRTable(STATE.rr);
  recomputeAndRender();
  log("RR puliti.");
});

/* ===================== SHARE ===================== */
function encodeShareState(obj){
  const json=JSON.stringify(obj);
  return btoa(unescape(encodeURIComponent(json))).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/g,"");
}
function decodeShareState(b64){
  const pad="===".slice((b64.length+3)%4);
  const s=(b64+pad).replace(/-/g,"+").replace(/_/g,"/");
  const json=decodeURIComponent(escape(atob(s)));
  return JSON.parse(json);
}
function collectShareState(){
  return {
    v: 6,
    crText:(document.getElementById("crText").value||"").trim(),
    proxyBase:(document.getElementById("proxyBase").value||"").trim(),
    timeoutMs:parseNum(document.getElementById("timeoutMs").value)||12000,
    rrIds:(document.getElementById("rrIds").value||"").trim(),
    rrTotals: STATE.rr || {},
  };
}
function applyShareState(st){
  if(!st || typeof st!=="object") return;
  if(typeof st.proxyBase==="string" && st.proxyBase.trim()) document.getElementById("proxyBase").value=st.proxyBase.trim();
  if(st.timeoutMs) document.getElementById("timeoutMs").value=String(st.timeoutMs);
  if(typeof st.rrIds==="string") document.getElementById("rrIds").value=st.rrIds;
  if(typeof st.crText==="string") document.getElementById("crText").value=st.crText;

  if(st.rrTotals && typeof st.rrTotals==="object" && Object.keys(st.rrTotals).length){
    STATE.rr=st.rrTotals;
    renderRRTable(STATE.rr);
  }

  if((document.getElementById("crText").value||"").trim()){
    try{ analyzeCurrentCR(); }catch(e){ log("Errore analisi CR da link: "+(e?.message||e)); }
  }
  recomputeAndRender();
}
function shareLink(){
  const token=encodeShareState(collectShareState());
  return `${location.origin}${location.pathname}#s=${token}`;
}
async function doShare(){
  const url=shareLink();
  try{
    if(navigator.share){
      await navigator.share({title:"Spartizione Detriti OGame", text:"Link con CR/RR precompilati", url});
      log("‚úÖ Link condiviso.");
      return;
    }
  }catch(e){}
  try{
    await navigator.clipboard.writeText(url);
    log("‚úÖ Link copiato negli appunti.");
  }catch(e){
    prompt("Copia questo link:", url);
    log("‚ÑπÔ∏è Link mostrato in prompt (clipboard non disponibile).");
  }
}
document.getElementById("btnShare").addEventListener("click", ()=>doShare());

(() => {
  const m=(location.hash||"").match(/#s=([A-Za-z0-9\-_]+)/);
  if(!m) return;
  try{
    applyShareState(decodeShareState(m[1]));
    log("üîó Stato caricato dal link.");
  }catch(e){
    log("‚ö†Ô∏è Hash di condivisione non valido: " + (e?.message || e));
  }
})();

log("Pronto. 1) Carica CR da API (analisi automatica). 2) Inserisci RR. 3) Vedi risultati.");
</script>
</body>
</html>
