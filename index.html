<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Spartizione Detriti OGame</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800&family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#050a10; --text:#dbe7ff; --muted:#93a6c7; --line:rgba(120,160,220,.25);
  --good:#39d98a; --bad:#ff5c5c;
  --accent:rgba(88,166,255,.18); --accentLine:rgba(88,166,255,.65);
  --font-ui:"Rajdhani",system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;
  --font-title:"Orbitron","Rajdhani",system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial;
}
*{box-sizing:border-box}
body{margin:0;font-family:var(--font-ui);color:var(--text);background:var(--bg);}
body::before{
  content:"";position:fixed;inset:0;z-index:-1;
  background:
    radial-gradient(1200px 700px at 15% -10%, rgba(124,240,255,.10), transparent 55%),
    radial-gradient(900px 600px at 110% 10%, rgba(255,179,77,.10), transparent 55%),
    linear-gradient(180deg, rgba(15,25,40,.65), rgba(5,10,16,1));
  filter:saturate(1.05) contrast(1.05);
}
header{
  position:sticky;top:0;z-index:5;
  background:linear-gradient(180deg, rgba(7,12,18,.92), rgba(7,12,18,.65));
  backdrop-filter:blur(10px);
  border-bottom:1px solid var(--line);
}
.wrap{max-width:1100px;margin:0 auto;padding:14px;}
.topbar{display:flex;align-items:center;justify-content:space-between;gap:12px;}
.title{display:flex;align-items:center;gap:10px;min-width:0;}
h1{font-family:var(--font-title);font-size:16px;margin:0;letter-spacing:.8px;text-transform:uppercase}
.badge{font-size:12px;color:var(--muted);border:1px solid var(--line);padding:4px 8px;border-radius:999px;background:rgba(16,26,46,.6)}

.grid{display:grid;grid-template-columns:1fr;gap:12px;margin-top:14px}
@media (min-width:980px){ .grid{grid-template-columns:1fr 1fr;} }

.card{
  border:1px solid var(--line);
  background:linear-gradient(180deg, rgba(16,26,46,.8), rgba(14,23,40,.75));
  border-radius:16px;
  padding:12px;
  box-shadow:0 10px 30px rgba(0,0,0,.25);
}
.min-title{font-family:var(--font-title);letter-spacing:.8px;text-transform:uppercase}
.card h2{margin:0 0 8px 0;font-size:14px;color:var(--text)}
.mini{font-size:12px;color:var(--muted)}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.row > *{flex:1}
input,textarea{
  width:100%;
  background:rgba(8,12,20,.65);
  border:1px solid var(--line);
  color:var(--text);
  border-radius:12px;
  padding:10px;
  font-size:13px;
  outline:none;
}
textarea{min-height:210px;resize:vertical;line-height:1.25}
button{
  border:1px solid var(--accentLine);
  background:var(--accent);
  color:var(--text);
  padding:9px 12px;
  border-radius:12px;
  cursor:pointer;
  font-weight:700;
}
button:hover{background:rgba(88,166,255,.24)}
button.ghost{border-color:var(--line);background:rgba(16,26,46,.5)}
button.ghost:hover{background:rgba(16,26,46,.75)}

details{border:1px solid var(--line);border-radius:12px;padding:10px;background:rgba(8,12,20,.25)}
summary{cursor:pointer;color:var(--muted);font-weight:800}
pre{margin:0;white-space:pre-wrap;word-break:break-word;font-size:12px;color:#cfe0ff}

table{width:100%;border-collapse:collapse;overflow:hidden;border-radius:12px;border:1px solid var(--line);background:rgba(8,12,20,.35)}
th,td{padding:8px;border-bottom:1px solid rgba(34,52,85,.6);font-size:12px;text-align:right;vertical-align:top}
th{color:var(--muted);font-weight:800;background:rgba(16,26,46,.55)}
th:first-child,td:first-child{text-align:left}
tr:last-child td{border-bottom:none}
.good{color:var(--good)}
.bad{color:var(--bad)}
.kpi{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:10px}
.kpi .box{border:1px solid var(--line);background:rgba(8,12,20,.35);border-radius:12px;padding:10px}
.kpi .box .v{font-size:14px;font-weight:900}
.kpi .box .l{font-size:12px;color:var(--muted)}
.gainWrap{margin-top:6px}
.gainBig{
  font-family:var(--font-title);
  letter-spacing:.6px;
  text-transform:uppercase;
  border:1px solid var(--line);
  border-radius:16px;
  padding:14px 14px;
  background:rgba(8,12,20,.35);
  display:flex;align-items:baseline;justify-content:space-between;gap:12px;
}
.gainBig .label{font-size:12px;color:var(--muted)}
.gainBig .value{font-size:22px;font-weight:900}
.gainBig.good{border-color:rgba(57,217,138,.35)}
.gainBig.bad{border-color:rgba(255,92,92,.35)}
.hr{height:1px;background:var(--line);margin:10px 0;border-radius:999px}
.statusLine{display:flex;align-items:center;gap:10px;flex-wrap:wrap;margin-top:10px}
.statusDot{
  width:22px;height:22px;border-radius:999px;border:1px solid var(--line);
  display:inline-flex;align-items:center;justify-content:center;font-weight:900;
}
.statusDot.ok{border-color:rgba(57,217,138,.55); color:var(--good)}
.statusDot.err{border-color:rgba(255,92,92,.55); color:var(--bad)}
.hidden{display:none !important}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1>Spartizione Detriti OGame</h1>
        <span class="badge">CR-KEY (RAW on) + RR API • spartizione solo ATT</span>
      </div>
    </div>
  </div>
</header>

<div class="wrap">

  <div class="card">
    <h2 class="min-title">1) Carica CR (RAW-only)</h2>

    <div class="mini">
      Inserisci la <b>CR-KEY</b> (es. <code>cr-it-...</code>). Verrà usato solo <b>rawOut=on</b>.
      Il RAW viene <b>nascosto</b> (non mostrato in chiaro).
    </div>

    <div class="row" style="gap:8px;margin-top:8px">
      <input id="crApiId" placeholder="CR-KEY (es. cr-it-269-...)" />
      <button id="btnLoadCR" type="button">Carica CR (RAW)</button>
    </div>

    <div class="statusLine">
      <div id="crStatusDot" class="statusDot" title="Stato CR">•</div>
      <div class="mini" id="crStatusText">In attesa del CR…</div>
    </div>

    <details style="margin-top:10px">
      <summary>Log</summary>
      <pre id="logBox" style="margin-top:10px"></pre>
    </details>

    <details style="margin-top:10px">
      <summary>Debug (RAW nascosto)</summary>
      <pre class="mini" style="margin-top:10px">Nascosto.</pre>
    </details>
  </div>

  <div id="app2" class="hidden">
    <div class="grid">

      <div class="card">
        <h2 class="min-title">2) RR + Spartizione</h2>

        <input id="proxyBase" type="hidden" value="https://ogame-api-proxy.matiasquiroz87.workers.dev/?apiid=" />
        <input id="timeoutMs" type="hidden" value="12000" />

        <div class="gainWrap">
          <div id="gainBox" class="gainBig">
            <div>
              <div class="label">GAIN (serve caricare RR)</div>
              <div class="mini" id="gainBreakdown">—</div>
            </div>
            <div class="value" id="gainValue">—</div>
          </div>
        </div>

        <div class="hr"></div>

        <label class="mini">Inserisci uno o più RR apiid (uno per riga)</label>
        <textarea id="rrIds" placeholder="rr-it-..."></textarea>

        <div class="row" style="margin-top:10px">
          <button id="btnLoadRR" type="button">Carica RR</button>
          <button id="btnClearRR" class="ghost" type="button">Pulisci</button>
        </div>

        <div class="row" style="margin-top:10px">
          <label class="mini" style="flex:0 0 auto">
            <input type="radio" name="mode" value="paritaria" checked> Paritaria
          </label>
          <label class="mini" style="flex:0 0 auto">
            <input type="radio" name="mode" value="equa"> Equa (peso flotta in campo)
          </label>
        </div>

        <details style="margin-top:10px">
          <summary>Raccolte lette (RR)</summary>
          <div id="rrTable" style="margin-top:8px"></div>
          <details style="margin-top:10px">
            <summary>Dettagli RR (debug)</summary>
            <pre id="rrRaw"></pre>
          </details>
        </details>

        <details style="margin-top:10px">
          <summary>Attaccanti letti (slot → nome)</summary>
          <div id="attSlots" style="margin-top:8px"></div>
          <div class="mini" style="margin-top:8px">
            Nota: per la spartizione usiamo gli <b>attaccanti aggregati per nome</b>. Questo box serve solo a capire gli slot.
          </div>
        </details>

        <details style="margin-top:10px">
          <summary>Debug perdite (initial → final) ✅</summary>
          <div id="lossDebugTable" style="margin-top:8px"></div>
          <div class="mini" style="margin-top:8px">
            Mostra slot, valore flotta (per modalità Equa) e perdite in risorse calcolate da <b>(initial - final)</b> usando COSTS (stile OGotcha).
          </div>
        </details>

      </div>

      <div class="card">
        <h2 class="min-title">Risultati</h2>
        <div id="resultsTables" style="margin-top:10px"></div>

        <details style="margin-top:12px" open>
          <summary>Trasporti finali suggeriti (SOLO su riciclato)</summary>
          <div class="mini" style="margin-top:8px">
            Questi trasferimenti agiscono solo sul totale riciclato: chi ha riciclato “troppo” invia a chi ha riciclato “meno” rispetto alla sua %.
          </div>
          <div id="transports" style="margin-top:8px"></div>
        </details>
      </div>

    </div>
  </div>

</div>

<script>
/* ===================== CONFIG ===================== */
const INCLUDE_LOOT = false;

const COSTS = {
  "Cargo leggero":[2000,2000,0],"Cargo Pesante":[6000,6000,0],"Caccia Leggero":[3000,1000,0],"Caccia Pesante":[6000,4000,0],
  "Incrociatore":[20000,7000,2000],"Nave da battaglia":[45000,15000,0],"Bombardiere":[50000,25000,15000],"Corazzata":[60000,50000,15000],
  "Incrociatore da Battaglia":[30000,40000,15000],"Reaper":[85000,55000,20000],"Pathfinder":[8000,15000,8000],
  "Riciclatrice":[10000,6000,2000],"Colonizzatrice":[10000,20000,10000],"Sonda spia":[0,1000,0],"Satellite Solare":[0,2000,500],
  "Crawler":[2000,2000,1000],"Morte Nera":[5000000,4000000,1000000],
  "Lanciamissili":[2000,0,0],"Laser leggero":[1500,500,0],"Laser pesante":[6000,2000,0],"Cannone Gauss":[20000,15000,2000],
  "Cannone ionico":[2000,6000,0],"Cannone al Plasma":[50000,50000,30000],"Cupola scudo piccola":[10000,10000,0],"Cupola scudo potenziata":[50000,50000,0]
};

// ship_type (OGame) -> chiave COSTS (IT)
const SHIP_ID_TO_NAME = {
  202:"Cargo leggero",203:"Cargo Pesante",204:"Caccia Leggero",205:"Caccia Pesante",
  206:"Incrociatore",207:"Nave da battaglia",208:"Colonizzatrice",209:"Riciclatrice",210:"Sonda spia",
  211:"Bombardiere",212:"Satellite Solare",213:"Corazzata",214:"Morte Nera",215:"Incrociatore da Battaglia",
  217:"Crawler",218:"Reaper",219:"Pathfinder",
  401:"Lanciamissili",402:"Laser leggero",403:"Laser pesante",404:"Cannone Gauss",405:"Cannone ionico",
  406:"Cannone al Plasma",407:"Cupola scudo piccola",408:"Cupola scudo potenziata"
};

/* ===================== UTILS ===================== */
function fmt(n){
  if(n===null||n===undefined||isNaN(n)) return "—";
  return Math.round(n).toLocaleString("it-IT");
}
function parseNum(str){
  if(str===null||str===undefined) return 0;
  const s = String(str).replace(/\./g,"").replace(/,/g,"").replace(/\s+/g,"").trim();
  const n = Number(s);
  return isNaN(n)?0:n;
}
const LOG=[];
function log(msg){
  const t = new Date().toLocaleTimeString();
  const line = `[${t}] ${msg}`;
  LOG.push(line);
  const el = document.getElementById("logBox");
  if(el) el.textContent = LOG.join("\n");
}
function setCrStatus(ok, text){
  const dot = document.getElementById("crStatusDot");
  const label = document.getElementById("crStatusText");
  dot.classList.remove("ok","err");
  if(ok===true){ dot.classList.add("ok"); dot.textContent="✓"; }
  else if(ok===false){ dot.classList.add("err"); dot.textContent="×"; }
  else { dot.textContent="•"; }
  label.textContent = text || "";
}
function showApp2(){
  const el = document.getElementById("app2");
  el.classList.remove("hidden");
  el.scrollIntoView({behavior:"auto", block:"start"});
}

/* ===================== STATE ===================== */
const STATE = {
  cr:null,
  rr:{}
};

/* ===================== FETCH HELPERS ===================== */
function abortableFetch(url, timeoutMs){
  const controller=new AbortController();
  const id=setTimeout(()=>controller.abort(), timeoutMs);
  return fetch(url,{signal:controller.signal}).finally(()=>clearTimeout(id));
}
async function fetchTextWithFallback(url, timeoutMs=12000){
  try{
    const res=await abortableFetch(url,timeoutMs);
    if(!res.ok) throw new Error("HTTP "+res.status);
    return await res.text();
  }catch(e1){
    const clean=String(url).replace(/^https?:\/\//i,"");
    const jinaUrl="https://r.jina.ai/http://" + clean;
    const res2=await abortableFetch(jinaUrl,timeoutMs);
    if(!res2.ok) throw new Error("HTTP "+res2.status);
    return await res2.text();
  }
}

/* ===================== DEBUG HELPERS (TAB) ===================== */
function fleetValueFromShips(shipCounts){
  let v = 0;
  for(const [ship,cnt] of Object.entries(shipCounts||{})){
    const cost = COSTS[ship];
    if(!cost) continue;
    v += (cost[0]+cost[1]+cost[2]) * (cnt||0);
  }
  return v;
}

/* ✅ NUOVA: perdite stile OGotcha = (initial - final) × COSTS */
function lossesResFromInitialFinal(initialShips, finalShips){
  const out = { m:0, c:0, d:0, tot:0 };
  const keys = new Set([
    ...Object.keys(initialShips || {}),
    ...Object.keys(finalShips || {})
  ]);

  for(const ship of keys){
    const cost = COSTS[ship];
    if(!cost) continue;

    const ini = Number(initialShips?.[ship] || 0);
    const fin = Number(finalShips?.[ship] || 0);
    const lost = Math.max(0, ini - fin);
    if(!lost) continue;

    out.m += cost[0] * lost;
    out.c += cost[1] * lost;
    out.d += cost[2] * lost;
  }

  out.tot = out.m + out.c + out.d;
  return out;
}

function formatLostShipsCompact(lostShips){
  const entries = Object.entries(lostShips||{})
    .filter(([,v])=>v>0)
    .sort((a,b)=>b[1]-a[1]);
  if(!entries.length) return "—";
  const top = entries.slice(0, 12).map(([k,v])=>`${k}: ${fmt(v)}`).join(" • ");
  const rest = entries.length > 12 ? ` • +${entries.length-12} altri` : "";
  return top + rest;
}

function renderLossDebugTable(cr){
  const el = document.getElementById("lossDebugTable");
  if(!el) return;

  if(!cr || !cr.attackers){
    el.innerHTML = `<div class="mini">Carica un CR RAW per vedere il debug.</div>`;
    return;
  }

  const players = Object.keys(cr.attackers);
  if(!players.length){
    el.innerHTML = `<div class="mini">Nessun attaccante nel CR.</div>`;
    return;
  }

  const rows = players.map(name=>{
    const p = cr.attackers[name];
    const slots = Array.isArray(p.slots) ? p.slots.slice().sort((a,b)=>a-b).join(", ") : "—";
    const fleetV = fleetValueFromShips(p.initial);

    /* ✅ QUI: prima usavi p.lost (attacker_ship_losses). Ora initial/final */
    const lossR  = lossesResFromInitialFinal(p.initial, p.final);

    /* Per lista "navi perse", mostriamo (initial-final) */
    const lostShips = {};
    const keys = new Set([...Object.keys(p.initial||{}), ...Object.keys(p.final||{})]);
    for(const ship of keys){
      const ini = p.initial?.[ship] || 0;
      const fin = p.final?.[ship] || 0;
      const lost = Math.max(0, ini - fin);
      if(lost>0) lostShips[ship] = lost;
    }
    const lostShipsTxt = formatLostShipsCompact(lostShips);

    return `
      <tr>
        <td style="text-align:left">${name}${p.tag ? ` <span class="mini">[${p.tag}]</span>` : ""}</td>
        <td>${slots}</td>
        <td>${fmt(fleetV)}</td>
        <td>${fmt(lossR.m)}</td>
        <td>${fmt(lossR.c)}</td>
        <td>${fmt(lossR.d)}</td>
        <td>${fmt(lossR.tot)}</td>
        <td style="text-align:left">${lostShipsTxt}</td>
      </tr>
    `;
  }).join("");

  el.innerHTML = `
    <table>
      <thead>
        <tr>
          <th style="text-align:left">Giocatore (ATT)</th>
          <th>Slot</th>
          <th>Valore flotta (M+C+D)</th>
          <th>Perse M</th>
          <th>Perse C</th>
          <th>Perse D</th>
          <th>Perse Tot</th>
          <th style="text-align:left">Navi perse (top)</th>
        </tr>
      </thead>
      <tbody>${rows}</tbody>
    </table>
    <div class="mini" style="margin-top:6px">
      Debug calcolato da <b>(initial - final)</b> → conversione in risorse via COSTS (stile OGotcha).
    </div>
  `;
}

/* ===================== RAW CR READER (NoMoreAngel rawOut=on) ===================== */
function stripRawText(t){
  const mdIdx = String(t||"").indexOf("Markdown Content:");
  if(mdIdx>=0) t = String(t).slice(mdIdx + "Markdown Content:".length);
  return String(t||"").replace(/\r/g,"").trim();
}
function pickScalar(text, key){
  const safe = key.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const m = text.match(new RegExp("\\["+safe+"\\]\\s*=>\\s*([^\\n]+)"));
  return m ? m[1].trim() : "";
}
function sliceBetween(text, startMark, endMark){
  const i = text.indexOf(startMark);
  if(i < 0) return "";
  if(!endMark) return text.slice(i);
  const j = text.indexOf(endMark, i);
  return j > 0 ? text.slice(i, j) : text.slice(i);
}
function parseFleetsBlock(blockText){
  const lines = String(blockText||"").split("\n");
  const slotsBucket = {};
  const ownerNumToName = {};

  let curSlot = null;
  let curShipType = 0;

  let fleetIndent = null;
  const leadingSpaces = (s)=> (String(s).match(/^\s*/)?.[0]?.length ?? 0);

  function ensureSlot(slot){
    const k = String(slot);
    if(!slotsBucket[k]){
      slotsBucket[k] = { slot:Number(slot), name:"", tag:"", initial:{}, lost:{}, final:{}, side:"" };
    }
    return slotsBucket[k];
  }

  for(let i=0;i<lines.length;i++){
    const l = lines[i];

    const idxM = l.match(/^\s*\[(\d+)\]\s*=>\s*stdClass Object/i);
    if(idxM){
      const ind = leadingSpaces(l);
      if(fleetIndent === null) fleetIndent = ind;
      if(ind !== fleetIndent) continue;

      curSlot = String(parseInt(idxM[1],10) + 1);
      curShipType = 0;
      ensureSlot(curSlot);
      continue;
    }

    if(!curSlot) continue;

    if(l.includes("[fleet_owner] =>")){
      const curName = (l.split("=>")[1]||"").trim();
      const s = ensureSlot(curSlot);
      if(curName) s.name = curName;
      ownerNumToName[curSlot] = curName || ownerNumToName[curSlot] || "";
      continue;
    }

    if(l.includes("[fleet_owner_alliance_tag] =>")){
      const curTag = (l.split("=>")[1]||"").trim();
      const s = ensureSlot(curSlot);
      if(curTag) s.tag = curTag;
      continue;
    }

    if(l.includes("[ship_type] =>")){
      curShipType = Number((l.split("=>")[1]||"").trim()) || 0;
      continue;
    }

    if(l.includes("[count] =>") && curShipType){
      const cnt = Number((l.split("=>")[1]||"").trim()) || 0;
      const shipName = SHIP_ID_TO_NAME[curShipType];
      if(shipName && cnt > 0){
        const s = ensureSlot(curSlot);
        s.initial[shipName] = (s.initial[shipName]||0) + cnt;
      }
      curShipType = 0;
      continue;
    }
  }

  return { slotsBucket, ownerNumToName };
}

function parseLossesBlock(blockText, slotsBucket, ownerNumToName){
  const lines = String(blockText||"").split("\n");
  let curOwner = null;
  let curShipType = 0;

  function ensureSlot(slot){
    const k = String(slot);
    if(!slotsBucket[k]){
      slotsBucket[k] = { slot:Number(slot), name: ownerNumToName[k]||"", tag:"", initial:{}, lost:{}, final:{}, side:"" };
    }else{
      if(!slotsBucket[k].name && ownerNumToName[k]) slotsBucket[k].name = ownerNumToName[k];
    }
    return slotsBucket[k];
  }

  for(let i=0;i<lines.length;i++){
    const l = lines[i];

    if (l.includes("[owner] =>")) {
      const rawOwner = Number((l.split("=>")[1] || "").trim());
      if (isNaN(rawOwner)) { curOwner = ""; continue; }

      const k0 = String(rawOwner);
      const k1 = String(rawOwner + 1);

      if (slotsBucket[k0]) curOwner = k0;
      else if (slotsBucket[k1]) curOwner = k1;
      else curOwner = k0;

      continue;
    }

    if(l.includes("[ship_type] =>")){
      curShipType = Number((l.split("=>")[1]||"").trim()) || 0;
      continue;
    }
    if(l.includes("[count] =>") && curOwner && curShipType){
      const cnt = Number((l.split("=>")[1]||"").trim()) || 0;
      const shipName = SHIP_ID_TO_NAME[curShipType];
      if(shipName && cnt > 0){
        const s = ensureSlot(curOwner);
        s.lost[shipName] = (s.lost[shipName]||0) + cnt;
      }
      curShipType = 0;
      continue;
    }
  }
}

function computeFinal(slotsBucket){
  for(const s of Object.values(slotsBucket)){
    const keys = new Set([...Object.keys(s.initial||{}), ...Object.keys(s.lost||{})]);
    const fin = {};
    for(const k of keys){
      const a = s.initial?.[k] || 0;
      const b = s.lost?.[k] || 0;
      const v = Math.max(0, a - b);
      if(v>0) fin[k] = v;
    }
    s.final = fin;
  }
}
function aggregateByName(slotsBucket){
  const agg = {};
  for(const s of Object.values(slotsBucket)){
    const name = (s.name||"").trim();
    if(!name) continue;
    if(!agg[name]) agg[name] = { tag:s.tag||"", slots:[], initial:{}, lost:{}, final:{} };
    if(s.tag && !agg[name].tag) agg[name].tag = s.tag;
    agg[name].slots.push(s.slot);

    for(const [ship,cnt] of Object.entries(s.initial||{})){
      agg[name].initial[ship] = (agg[name].initial[ship]||0) + cnt;
    }
    for(const [ship,cnt] of Object.entries(s.lost||{})){
      agg[name].lost[ship] = (agg[name].lost[ship]||0) + cnt;
    }
    for(const [ship,cnt] of Object.entries(s.final||{})){
      agg[name].final[ship] = (agg[name].final[ship]||0) + cnt;
    }
  }
  for(const v of Object.values(agg)) v.slots.sort((a,b)=>a-b);
  return agg;
}

function parseCR_RawOnly(rawText){
  const text = stripRawText(rawText);
  if(!text.includes("stdClass Object")) throw new Error("RAW non riconosciuto (manca 'stdClass Object').");

  const attackersBlock = sliceBetween(text, "[attackers] =>", "[defenders] =>");
  const defendersBlock = sliceBetween(text, "[defenders] =>", "[attacker_ship_losses] =>");
  const attLossBlock   = sliceBetween(text, "[attacker_ship_losses] =>", "[defender_ship_losses] =>");
  const defLossBlock   = sliceBetween(text, "[defender_ship_losses] =>", null);

  const att = parseFleetsBlock(attackersBlock);
  const def = parseFleetsBlock(defendersBlock);

  parseLossesBlock(attLossBlock, att.slotsBucket, att.ownerNumToName);
  parseLossesBlock(defLossBlock, def.slotsBucket, def.ownerNumToName);

  computeFinal(att.slotsBucket);
  computeFinal(def.slotsBucket);

  const attackers = aggregateByName(att.slotsBucket);
  const defenders = aggregateByName(def.slotsBucket);

  if(!Object.keys(attackers).length){
    throw new Error("Nessun attaccante trovato (blocco [attackers] non parsato).");
  }

  const meta = {
    cr_id: pickScalar(text, "cr_id"),
    event_time: pickScalar(text, "event_time"),
    coords: pickScalar(text, "combat_coordinates"),
    rounds: Number(pickScalar(text, "combat_rounds")) || 0,
    winner: pickScalar(text, "winner"),
    moon_chance: Number(pickScalar(text, "moon_chance")) || 0
  };

  const debris = {
    m: parseNum(pickScalar(text, "debris_metal")),
    c: parseNum(pickScalar(text, "debris_crystal")),
    d: parseNum(pickScalar(text, "debris_deuterium"))
  };

  const loot = {
    m: parseNum(pickScalar(text, "loot_metal")),
    c: parseNum(pickScalar(text, "loot_crystal")),
    d: parseNum(pickScalar(text, "loot_deuterium"))
  };
  if(!INCLUDE_LOOT) loot.m=loot.c=loot.d=0;

  return {
    source:"nomoreangel-raw",
    meta, debris, loot,
    attackersSlots: att.slotsBucket,
    defendersSlots: def.slotsBucket,
    attackers, defenders
  };
}

/* ===================== ECONOMIA (SOLO ATT) ===================== */
function computeFromRawAttackersOnly(cr, rrTotals, mode){
  const players = Object.keys(cr.attackers||{});
  const n = players.length || 1;

  const lossesRes={}, fleetValue={};
  players.forEach(name=>{
    const p = cr.attackers[name];

    /* ✅ QUI: prima prendevi le perdite da attacker_ship_losses.
       Ora le calcoli da (initial - final) × COSTS */
    const L = lossesResFromInitialFinal(p.initial, p.final);
    lossesRes[name] = { m:L.m, c:L.c, d:L.d, total:L.tot };

    let fv = 0;
    for(const [ship,cnt] of Object.entries(p.initial||{})){
      const cost = COSTS[ship];
      if(cost) fv += (cost[0]+cost[1]+cost[2]) * cnt;
    }
    fleetValue[name] = fv;
  });

  const totLoss = players.reduce((a,nm)=>({
    m:a.m+(lossesRes[nm]?.m||0),
    c:a.c+(lossesRes[nm]?.c||0),
    d:a.d+(lossesRes[nm]?.d||0)
  }),{m:0,c:0,d:0});

  const totRec = players.reduce((a,nm)=>{
    const r = rrTotals[nm] || {m:0,c:0,d:0};
    return {m:a.m+r.m, c:a.c+r.c, d:a.d+r.d};
  },{m:0,c:0,d:0});

  const gain = { m:totRec.m-totLoss.m, c:totRec.c-totLoss.c, d:totRec.d-totLoss.d };

  const weights={};
  if(mode==="paritaria"){
    players.forEach(nm=>weights[nm]=1/n);
  }else{
    const totFleet = players.reduce((s,nm)=>s+(fleetValue[nm]||0),0) || 1;
    players.forEach(nm=>weights[nm]=(fleetValue[nm]||0)/totFleet);
  }

  const saldo={};
  players.forEach(nm=>{
    const r=rrTotals[nm]||{m:0,c:0,d:0};
    const L = lossesRes[nm] || {m:0,c:0,d:0};
    saldo[nm]={
      m: L.m + gain.m*weights[nm] - r.m,
      c: L.c + gain.c*weights[nm] - r.c,
      d: L.d + gain.d*weights[nm] - r.d,
      w: weights[nm],
      lost: L,
      rec: r
    };
  });

  return {players,totLoss,totRec,gain,weights,saldo};
}

/* ===================== TRASPORTI SOLO SU RICICLATO (ΔRR) ===================== */
function computeDeltaRR(players, rrTotals, weights){
  const totRR = players.reduce((a,p)=>{
    const r = rrTotals[p] || {m:0,c:0,d:0};
    return { m:a.m+r.m, c:a.c+r.c, d:a.d+r.d };
  },{m:0,c:0,d:0});

  const delta = {};
  players.forEach(p=>{
    const r = rrTotals[p] || {m:0,c:0,d:0};
    delta[p] = {
      m: totRR.m*weights[p] - r.m,
      c: totRR.c*weights[p] - r.c,
      d: totRR.d*weights[p] - r.d
    };
  });
  return {totRR, delta};
}
function buildTransfers(players, bucket, resKey){
  const recv=[], send=[];
  players.forEach(p=>{
    const v=bucket[p][resKey];
    if(v>0.5) recv.push([p,v]);
    else if(v<-0.5) send.push([p,-v]);
  });
  recv.sort((a,b)=>b[1]-a[1]); send.sort((a,b)=>b[1]-a[1]);
  const moves=[]; let i=0,j=0;
  while(i<send.length && j<recv.length){
    const [sp,sv]=send[i], [rp,rv]=recv[j];
    const x=Math.min(sv,rv);
    if(x>0.5) moves.push({from:sp,to:rp,amount:x});
    send[i][1]-=x; recv[j][1]-=x;
    if(send[i][1]<=0.5) i++;
    if(recv[j][1]<=0.5) j++;
  }
  return moves;
}

/* ===================== RENDER ===================== */
function renderRRTable(rrTotals){
  const el=document.getElementById("rrTable");
  const entries=Object.entries(rrTotals||{});
  if(!entries.length){ el.innerHTML='<div class="mini">Nessun RR caricato.</div>'; return; }

  const rows=entries.map(([p,v])=>`
    <tr>
      <td>${p}</td><td>${fmt(v.m)}</td><td>${fmt(v.c)}</td><td>${fmt(v.d)}</td><td>${v.count||0}</td>
    </tr>`).join("");

  el.innerHTML = `
    <table>
      <thead><tr><th>Giocatore</th><th>Metallo</th><th>Cristallo</th><th>Deuterio</th><th>RR</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>`;
}

function renderAttSlots(cr){
  const el = document.getElementById("attSlots");
  if(!cr?.attackersSlots){ el.innerHTML = `<div class="mini">—</div>`; return; }
  const slots = Object.values(cr.attackersSlots).sort((a,b)=>a.slot-b.slot);
  if(!slots.length){ el.innerHTML = `<div class="mini">Nessuno slot attaccante trovato.</div>`; return; }

  const rows = slots.map(s=>{
    const ships = Object.entries(s.initial||{}).reduce((sum,[,cnt])=>sum+(cnt||0),0);
    const lost  = Object.entries(s.lost||{}).reduce((sum,[,cnt])=>sum+(cnt||0),0);
    return `<tr><td>${s.slot}</td><td>${s.name||"—"}</td><td>${s.tag||"—"}</td><td>${ships}</td><td>${lost}</td></tr>`;
  }).join("");

  el.innerHTML = `
    <table>
      <thead><tr><th>Slot</th><th>Nome</th><th>TAG</th><th># navi (initial)</th><th># navi perse</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>
  `;
}

function renderGainBox(computed){
  const gainBox = document.getElementById("gainBox");
  const gainValue = document.getElementById("gainValue");
  const gainBreakdown = document.getElementById("gainBreakdown");

  if(!computed){
    gainBox.classList.remove("good","bad");
    gainValue.textContent="—";
    gainBreakdown.textContent="—";
    gainBox.querySelector(".label").textContent="GAIN (serve caricare RR)";
    return;
  }

  const total = (computed.gain.m + computed.gain.c + computed.gain.d);
  gainBox.classList.remove("good","bad");
  gainBox.classList.add(total>=0 ? "good" : "bad");
  gainBox.querySelector(".label").textContent="GAIN TOTALE (M+C+D)";
  gainValue.textContent = fmt(total);
  gainBreakdown.textContent = `M ${fmt(computed.gain.m)} • C ${fmt(computed.gain.c)} • D ${fmt(computed.gain.d)}`;
}

function renderResults(computed){
  const resEl = document.getElementById("resultsTables");
  const trEl = document.getElementById("transports");

  if(!computed){
    resEl.innerHTML = `<div class="mini">Carica CR e almeno un RR per calcolare gain/saldi/trasporti.</div>`;
    trEl.innerHTML = `<div class="mini">—</div>`;
    return;
  }

  const {players,totLoss,totRec,gain,weights,saldo}=computed;

  const header=`
    <div class="kpi">
      <div class="box"><div class="v">${fmt(totRec.m)} / ${fmt(totRec.c)} / ${fmt(totRec.d)}</div><div class="l">Riciclato totale ATT (M/C/D)</div></div>
      <div class="box"><div class="v">${fmt(totLoss.m)} / ${fmt(totLoss.c)} / ${fmt(totLoss.d)}</div><div class="l">Perdite ATT (initial-final)</div></div>
      <div class="box"><div class="v">${fmt(gain.m)} / ${fmt(gain.c)} / ${fmt(gain.d)}</div><div class="l">Gain ATT (M/C/D)</div></div>
    </div>`;

  const rows=players.map(p=>{
    const q=saldo[p];
    const mClass=q.m>=0?"good":"bad";
    const cClass=q.c>=0?"good":"bad";
    const dClass=q.d>=0?"good":"bad";
    return `
      <tr>
        <td>${p} <span class="mini">[${(q.w*100).toFixed(2)}%]</span></td>
        <td>${fmt(q.lost.m)}</td><td>${fmt(q.lost.c)}</td><td>${fmt(q.lost.d)}</td>
        <td>${fmt(q.rec.m)}</td><td>${fmt(q.rec.c)}</td><td>${fmt(q.rec.d)}</td>
        <td class="${mClass}">${fmt(q.m)}</td>
        <td class="${cClass}">${fmt(q.c)}</td>
        <td class="${dClass}">${fmt(q.d)}</td>
      </tr>`;
  }).join("");

  const table=`
    <table style="margin-top:10px">
      <thead>
        <tr>
          <th>Giocatore (ATT)</th>
          <th>Perse M</th><th>Perse C</th><th>Perse D</th>
          <th>Riciclato M</th><th>Riciclato C</th><th>Riciclato D</th>
          <th>Saldo M</th><th>Saldo C</th><th>Saldo D</th>
        </tr>
      </thead>
      <tbody>${rows}</tbody>
    </table>
    <div class="mini" style="margin-top:8px">
      Spartizione calcolata <b>solo tra attaccanti</b>. I difensori sono esclusi (anche dalle perdite).
      <br>Saldo = Perdite(ATT da initial-final) + (Gain×%) − Riciclato.
    </div>`;

  resEl.innerHTML = header + table;

  const {delta} = computeDeltaRR(players, STATE.rr, weights);
  const mt=buildTransfers(players,delta,"m");
  const ct=buildTransfers(players,delta,"c");
  const dt=buildTransfers(players,delta,"d");

  function renderMoveList(label,moves){
    if(!moves.length) return `<div class="mini">Nessun trasferimento per ${label} (già bilanciato sul riciclato).</div>`;
    const r=moves.map(m=>`<tr><td>${m.from}</td><td>${m.to}</td><td>${fmt(m.amount)}</td></tr>`).join("");
    return `
      <div style="margin-top:10px">
        <div class="mini" style="margin:6px 0"><b>${label}</b></div>
        <table><thead><tr><th>Da</th><th>A</th><th>Quantità</th></tr></thead><tbody>${r}</tbody></table>
      </div>`;
  }
  trEl.innerHTML = renderMoveList("Metallo",mt) + renderMoveList("Cristallo",ct) + renderMoveList("Deuterio",dt);
}

/* ===================== RECOMPUTE ===================== */
function hasAnyRR(){ return Object.keys(STATE.rr||{}).length>0; }
function recomputeAndRender(){
  if(!STATE.cr || !hasAnyRR()){
    renderGainBox(null);
    renderResults(null);
    renderLossDebugTable(STATE.cr);
    return;
  }
  const mode = document.querySelector('input[name="mode"]:checked')?.value || "paritaria";
  const computed = computeFromRawAttackersOnly(STATE.cr, STATE.rr||{}, mode);
  renderGainBox(computed);
  renderResults(computed);
  renderLossDebugTable(STATE.cr);
}
document.querySelectorAll('input[name="mode"]').forEach(r=>r.addEventListener("change", ()=>{
  log("Modalità: " + (document.querySelector('input[name="mode"]:checked')?.value || "paritaria"));
  recomputeAndRender();
}));

/* ===================== CR LOADER (RAW-ONLY, SOLO CR KEY) ===================== */
document.getElementById("btnLoadCR").addEventListener("click", async ()=>{
  const apiid=(document.getElementById("crApiId").value||"").trim();
  const timeoutMs = parseNum(document.getElementById("timeoutMs")?.value) || 15000;

  setCrStatus(null,"Caricamento CR (RAW)…");

  try{
    if(!apiid) throw new Error("Inserisci la CR-KEY.");

    const rawUrl = `https://nomoreangel.de/api-reader/?apiid=${encodeURIComponent(apiid)}&rawOut=on`;
    log("CR: fetch RAW (rawOut=on)…");
    const raw = await fetchTextWithFallback(rawUrl, timeoutMs);

    STATE.cr = parseCR_RawOnly(raw);

    const attNames = Object.keys(STATE.cr.attackers||{});
    const defNames = Object.keys(STATE.cr.defenders||{});

    setCrStatus(true,`CR OK. Att: ${attNames.length} • Def: ${defNames.length} • ${STATE.cr.meta.coords||""} (def esclusi)`);
    log("✅ CR RAW caricato. ATT: " + attNames.join(", "));
    if(defNames.length) log("ℹ️ Difensori presenti nel RAW ma esclusi dalla spartizione.");

    renderAttSlots(STATE.cr);
    renderLossDebugTable(STATE.cr);
    showApp2();
    recomputeAndRender();
  }catch(e){
    setCrStatus(false,"Errore CR.");
    log("❌ Errore CR: " + (e?.message || e));
  }
});

/* ===================== RR ===================== */
function extractPre(html){
  const m=html.match(/<pre[^>]*>([\s\S]*?)<\/pre>/i);
  if(!m) return null;
  return m[1]
    .replace(/&lt;/g,"<").replace(/&gt;/g,">")
    .replace(/&amp;/g,"&").replace(/&#039;/g,"'")
    .replace(/&quot;/g,'"');
}
function parseRRFromPre(pre){
  const owner=(pre.match(/\[owner_name\]\s*=>\s*([^\r\n]+)/)||[])[1];
  if(!owner) return null;
  const m=parseNum((pre.match(/\[metal_retrieved\]\s*=>\s*([\d\.,]+)/)||[])[1]);
  const c=parseNum((pre.match(/\[crystal_retrieved\]\s*=>\s*([\d\.,]+)/)||[])[1]);
  const d=parseNum((pre.match(/\[deuterium_retrieved\]\s*=>\s*([\d\.,]+)/)||[])[1]);
  const coords=(pre.match(/\[coordinates\]\s*=>\s*([^\r\n]+)/)||[])[1]||"";
  const rrid=(pre.match(/\[rr_id\]\s*=>\s*([^\r\n]+)/)||[])[1]||"";
  return {owner:owner.trim(),m,c,d,coords:coords.trim(),rrid:rrid.trim()};
}

document.getElementById("btnLoadRR").addEventListener("click", async ()=>{
  if(!STATE.cr){ log("⚠️ Carica prima il CR."); return; }

  STATE.rr = {};
  const base=(document.getElementById("proxyBase").value||"").trim();
  const timeoutMs=parseNum(document.getElementById("timeoutMs").value)||12000;
  const ids=(document.getElementById("rrIds").value||"").split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  if(!ids.length){ log("⚠️ Nessun RR inserito."); return; }

  log(`Carico ${ids.length} RR…`);
  const rawLog=[];
  for(const id of ids){
    const url=base+encodeURIComponent(id);
    try{
      const res=await abortableFetch(url,timeoutMs);
      const text=await res.text();
      rawLog.push(`--- ${id} status=${res.status} ok=${res.ok} ---\n` + text.slice(0,1200));

      const pre=extractPre(text)||text;
      const parsed=parseRRFromPre(pre);
      if(!parsed){ log(`❌ RR non parsato: ${id} (owner_name non trovato)`); continue; }

      const p=parsed.owner;
      if(!STATE.rr[p]) STATE.rr[p]={m:0,c:0,d:0,count:0,list:[]};
      STATE.rr[p].m += parsed.m;
      STATE.rr[p].c += parsed.c;
      STATE.rr[p].d += parsed.d;
      STATE.rr[p].count += 1;
      STATE.rr[p].list.push(parsed);
      log(`✅ RR: ${p} +${fmt(parsed.m)}M +${fmt(parsed.c)}C +${fmt(parsed.d)}D (${parsed.coords})`);
    }catch(e){
      log(`❌ Errore fetch RR ${id}: ${e?.message || e}`);
    }
  }

  document.getElementById("rrRaw").textContent = rawLog.join("\n\n");
  renderRRTable(STATE.rr);
  recomputeAndRender();
});

document.getElementById("btnClearRR").addEventListener("click", ()=>{
  STATE.rr={};
  document.getElementById("rrRaw").textContent="";
  document.getElementById("rrIds").value="";
  renderRRTable(STATE.rr);
  recomputeAndRender();
  log("RR puliti.");
});

/* ===================== INIT ===================== */
setCrStatus(null,"In attesa del CR…");
log("Pronto. 1) Carica CR (RAW-only via CR-KEY). 2) Carica RR. 3) Vedi gain/saldi e trasporti (solo su riciclato, solo ATT).");
</script>
</body>
</html>
