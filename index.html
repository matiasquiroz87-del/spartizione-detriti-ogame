<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Spartizione Detriti — ACS (2 step)</title>
<style>
  :root{
    --bg0:#050a10; --bg1:#071321; --card:#0a2238cc;
    --stroke:#1f3c56; --stroke2:#2a516f;
    --text:#d9e6f2; --muted:#8fb0c9;
    --accent:#f0c45a; --good:#53d39c; --bad:#ff6b6b;
    --shadow:0 12px 36px rgba(0,0,0,.55);
    --radius:18px;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    color:var(--text);
    background:
      radial-gradient(1200px 800px at 20% 10%, rgba(39,110,160,.35), transparent 60%),
      radial-gradient(1000px 700px at 90% 10%, rgba(20,130,120,.25), transparent 55%),
      radial-gradient(900px 600px at 50% 90%, rgba(210,170,80,.12), transparent 55%),
      linear-gradient(180deg, var(--bg1), var(--bg0) 65%);
    min-height:100vh;
  }
  .wrap{max-width:1100px; margin:24px auto; padding:0 16px 40px;}
  .topbar{
    display:flex; gap:12px; align-items:center; justify-content:space-between;
    padding:14px 16px; border-radius:22px;
    background:linear-gradient(180deg, rgba(15,40,64,.75), rgba(6,18,32,.7));
    border:1px solid rgba(255,255,255,.07);
    box-shadow: var(--shadow);
  }
  .brand{display:flex; align-items:center; gap:12px;}
  .logo{
    width:42px;height:42px;border-radius:14px;
    background:
      radial-gradient(circle at 35% 30%, rgba(240,196,90,.55), transparent 55%),
      radial-gradient(circle at 70% 75%, rgba(140,190,230,.35), transparent 55%),
      linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    border:1px solid rgba(240,196,90,.35);
    box-shadow:0 10px 26px rgba(0,0,0,.35);
  }
  .title{line-height:1.05}
  .title h1{margin:0;font-size:18px;font-weight:800;letter-spacing:.2px}
  .title p{margin:4px 0 0;color:var(--muted);font-size:12.5px}
  .actions{display:flex; gap:10px; flex-wrap:wrap}
  button, .btn{
    cursor:pointer; color:var(--text);
    background:linear-gradient(180deg, rgba(18,44,68,.9), rgba(10,24,40,.9));
    border:1px solid rgba(255,255,255,.10);
    border-radius:14px;
    padding:10px 12px;
    font-weight:700;
    box-shadow:0 10px 22px rgba(0,0,0,.35);
  }
  button:hover{border-color:rgba(240,196,90,.35)}
  button.primary{
    background:linear-gradient(180deg, rgba(240,196,90,.22), rgba(10,24,40,.92));
    border-color:rgba(240,196,90,.35);
  }
  button.ghost{background:transparent; border:1px solid rgba(255,255,255,.12); box-shadow:none}
  .grid{display:grid; grid-template-columns: 1.15fr .85fr; gap:16px; margin-top:16px;}
  @media (max-width: 960px){ .grid{grid-template-columns:1fr} }
  .card{
    background:linear-gradient(180deg, rgba(14,40,64,.80), rgba(6,18,32,.70));
    border:1px solid rgba(255,255,255,.08);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    overflow:hidden;
  }
  .card .head{
    display:flex; align-items:center; justify-content:space-between;
    padding:14px 16px;
    border-bottom:1px solid rgba(255,255,255,.07);
  }
  .card .head .h{
    display:flex; align-items:center; gap:10px; font-weight:900;
  }
  .pill{font-size:12px; color:var(--muted); background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08);
    padding:4px 10px; border-radius:999px; font-weight:800}
  .body{padding:14px 16px}
  label{display:block; font-size:12px; color:var(--muted); margin:10px 0 6px}
  input, textarea, select{
    width:100%; color:var(--text);
    background:rgba(0,0,0,.20);
    border:1px solid rgba(255,255,255,.10);
    border-radius:12px;
    padding:10px 12px;
    outline:none;
  }
  textarea{min-height:140px; resize:vertical; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:12px}
  .row{display:grid; grid-template-columns: 1fr 1fr; gap:12px}
  @media (max-width: 640px){ .row{grid-template-columns:1fr} }
  .hint{color:var(--muted); font-size:12px; margin-top:8px}
  .status{
    padding:10px 12px; border-radius:14px; margin-top:12px;
    background:rgba(0,0,0,.22); border:1px dashed rgba(255,255,255,.12);
    font-size:12.5px; color:var(--muted); white-space:pre-wrap;
  }
  .status.good{border-color:rgba(83,211,156,.35); color:#bff6df}
  .status.bad{border-color:rgba(255,107,107,.35); color:#ffd0d0}
  table{width:100%; border-collapse:separate; border-spacing:0; overflow:hidden}
  th, td{padding:10px 10px; border-bottom:1px solid rgba(255,255,255,.07); font-size:13px}
  th{color:var(--muted); text-align:left; font-size:12px}
  tr:last-child td{border-bottom:none}
  .kpi{display:grid; grid-template-columns: repeat(3, 1fr); gap:10px}
  @media (max-width: 640px){ .kpi{grid-template-columns:1fr} }
  .kpi .box{
    background:rgba(0,0,0,.18); border:1px solid rgba(255,255,255,.08);
    border-radius:14px; padding:10px 12px;
  }
  .kpi .box b{display:block; font-size:12px; color:var(--muted); margin-bottom:6px}
  .kpi .box .v{font-weight:900; font-size:15px}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace}
  .right{display:flex; justify-content:flex-end; gap:10px; flex-wrap:wrap}
  .divider{height:1px; background:rgba(255,255,255,.07); margin:12px 0}
  .page{display:none}
  .page.active{display:block}
  .small{font-size:12px; color:var(--muted)}
  .warn{color:#ffd59a}
</style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div class="brand">
      <div class="logo"></div>
      <div class="title">
        <h1>Spartizione Detriti — ACS</h1>
        <p>Step 1: carica CR (da API o testo) → Step 2: pagina compilata automaticamente.</p>
      </div>
    </div>
    <div class="actions">
      <button class="ghost" id="btnReset">Reset</button>
      <button class="ghost" id="btnPasteExample">Incolla esempio (convertito)</button>
    </div>
  </div>

  <!-- PAGE 1 -->
  <div class="page active" id="page1">
    <div class="grid">
      <div class="card">
        <div class="head">
          <div class="h">1) Carica CR <span class="pill">input</span></div>
          <div class="small">API → estrazione testo → parsing “convertito”</div>
        </div>
        <div class="body">
          <div class="row">
            <div>
              <label>Proxy API base</label>
              <input id="proxyBase" value="https://ogame-api-proxy.matiasquiroz87.workers.dev" />
              <div class="hint">Deve rispondere a <span class="mono">/?apiid=cr-...</span> e restituire HTML (nomoreangel).</div>
            </div>
            <div>
              <label>API ID (CR)</label>
              <input id="crApiId" placeholder="cr-it-269-..." />
              <div class="hint">Esempio: <span class="mono">cr-it-269-99ac0412...</span></div>
            </div>
          </div>

          <div class="right" style="margin-top:12px">
            <button id="btnTestCR" class="ghost">Test</button>
            <button id="btnLoadCR" class="primary">Carica &amp; Vai alla pagina compilata</button>
          </div>

          <div class="divider"></div>

          <label>Oppure incolla qui il CR già “convertito” (English Output) e premi “Vai”</label>
          <textarea id="crText" placeholder="Incolla qui il testo tipo:&#10;General Information:&#10;...&#10;Metal to debrisfield: ...&#10;Crystal to debrisfield: ...&#10;Attacker&#10;[2:..] Nome&#10;..."></textarea>
          <div class="right" style="margin-top:10px">
            <button id="btnGoFromText" class="primary">Vai (da testo incollato)</button>
          </div>

          <div id="status1" class="status">Pronto.</div>
        </div>
      </div>

      <div class="card">
        <div class="head">
          <div class="h">Cosa viene letto <span class="pill">info</span></div>
        </div>
        <div class="body">
          <div class="kpi">
            <div class="box"><b>Attaccanti</b><div class="v" id="kpiAtk">—</div></div>
            <div class="box"><b>DF Metallo</b><div class="v mono" id="kpiM">—</div></div>
            <div class="box"><b>DF Cristallo</b><div class="v mono" id="kpiC">—</div></div>
          </div>
          <div class="hint" style="margin-top:12px">
            Nota: se l’HTML restituisce solo <span class="mono">stdClass Object</span>, il parsing “convertito” non è possibile.
            In quel caso usa “Incolla esempio / testo convertito”.
          </div>
          <div class="divider"></div>
          <div class="small warn">
            Suggerimento: in nomoreangel “API-Reader” abilita <b>English-Output</b> e <b>Raw-Output OFF</b> (quando copi a mano).
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- PAGE 2 -->
  <div class="page" id="page2">
    <div class="grid">
      <div class="card">
        <div class="head">
          <div class="h">2) Pagina compilata <span class="pill">output</span></div>
          <div class="right">
            <button class="ghost" id="btnBack">← Indietro</button>
            <button class="primary" id="btnCopySummary">Copia riepilogo</button>
          </div>
        </div>
        <div class="body">
          <div class="kpi">
            <div class="box"><b>Combat coords</b><div class="v mono" id="outCoords">—</div></div>
            <div class="box"><b>DF Metallo</b><div class="v mono" id="outM">—</div></div>
            <div class="box"><b>DF Cristallo</b><div class="v mono" id="outC">—</div></div>
          </div>

          <div class="divider"></div>
          <table>
            <thead><tr><th>Attaccante</th><th>Quota (paritaria)</th></tr></thead>
            <tbody id="tblAtk"></tbody>
          </table>

          <div class="divider"></div>
          <div class="small">Questa pagina è il “primo step” richiesto: CR → pagina compilata. Da qui possiamo reintrodurre RR e conguagli in un terzo step, senza cambiare il flusso.</div>

          <div id="status2" class="status" style="margin-top:12px">—</div>
        </div>
      </div>

      <div class="card">
        <div class="head">
          <div class="h">Debug <span class="pill">log</span></div>
          <div class="right">
            <button class="ghost" id="btnShowText">Mostra testo CR usato</button>
          </div>
        </div>
        <div class="body">
          <div id="debug" class="status" style="min-height:220px">—</div>
        </div>
      </div>
    </div>
  </div>

</div>

<!-- MODAL -->
<div id="modal" style="position:fixed; inset:0; display:none; place-items:center; background:rgba(0,0,0,.55); padding:16px; z-index:50">
  <div class="card" style="max-width:1000px; width:100%">
    <div class="head">
      <div class="h" id="modalTitle">Testo</div>
      <div class="right">
        <button class="ghost" id="btnModalCopy">Copia</button>
        <button class="primary" id="btnModalClose">Chiudi</button>
      </div>
    </div>
    <div class="body">
      <textarea id="modalText" style="min-height:55vh"></textarea>
      <div class="hint">Se l’API torna solo stdClass, qui vedrai quel dump (non parseabile come “convertito”).</div>
    </div>
  </div>
</div>

<script>
(function(){
  const $ = (id)=>document.getElementById(id);

  // ---------- Utilities ----------
  const nf = new Intl.NumberFormat('it-IT');
  function parseDotNumber(s){
    // "8.451.301.052" -> 8451301052
    const t = (s||"").replace(/[^\d]/g,'');
    return t ? Number(t) : 0;
  }
  function fmt(n){ return nf.format(Number(n||0)); }

  function setStatus(el, msg, kind){
    el.classList.remove('good','bad');
    if(kind) el.classList.add(kind);
    el.textContent = msg;
  }

  function showPage(n){
    $('page1').classList.toggle('active', n===1);
    $('page2').classList.toggle('active', n===2);
    window.scrollTo({top:0, behavior:'smooth'});
  }

  // ---------- Extraction ----------
  function htmlToText(html){
    const doc = new DOMParser().parseFromString(html, 'text/html');
    // Prefer <pre> content (nomoreangel uses <pre> for dumps)
    const pre = doc.querySelector('pre');
    if(pre && pre.textContent && pre.textContent.trim().length>30){
      return pre.textContent.trim();
    }
    // Otherwise take visible text
    const bodyText = (doc.body ? doc.body.innerText : doc.documentElement.innerText) || "";
    return bodyText.trim();
  }

  // ---------- Converted CR parsing (SAFE, line-by-line, no fragile regex) ----------
  function parseConvertedCR(text){
    const lines = (text||"").split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length>0);
    const out = {
      ok:false,
      coords:"",
      df_m:0, df_c:0,
      attackers:[],
      notes:[]
    };

    // Detect if converted markers exist
    const hasConverted = lines.some(l => l.toLowerCase().startsWith("general information:")) ||
                         lines.some(l => l.toLowerCase().includes("metal to debrisfield"));
    if(!hasConverted){
      out.notes.push("Nessuna sezione 'General Information' / 'Metal to debrisfield' trovata: probabilmente è RAW stdClass.");
      return out;
    }

    // Parse DF & coords
    for(const line of lines){
      const low = line.toLowerCase();
      if(low.startsWith("combat coordinates:")){
        out.coords = line.split(":").slice(1).join(":").trim();
      }
      if(low.startsWith("metal to debrisfield:")){
        out.df_m = parseDotNumber(line.split(":").slice(1).join(":"));
      }
      if(low.startsWith("crystal to debrisfield:")){
        out.df_c = parseDotNumber(line.split(":").slice(1).join(":"));
      }
    }

    // Parse attackers (unique) by scanning the "Combat Report:" section.
    // Strategy: whenever we see a line "Attacker" then next lines often include "[g:s:p] Name"
    const names = [];
    let expectName = false;
    for(let i=0;i<lines.length;i++){
      const line = lines[i];
      if(line === "Attacker"){
        expectName = true;
        continue;
      }
      if(expectName){
        // Usually: "[2:96:10] Pablito"
        if(line.startsWith("[") && line.includes("]")){
          const after = line.split("]").slice(1).join("]").trim();
          if(after){
            names.push(after);
            expectName = false;
          }
          continue;
        }
        // Sometimes "Attacker" followed by coords line on same line (rare)
        if(line.startsWith("[")===false && line.includes("]")){
          const parts = line.split("]");
          const after = parts.slice(1).join("]").trim();
          if(after){
            names.push(after);
            expectName = false;
          }
        }
        // If another section begins, stop expecting
        if(line === "Defender" || line.startsWith("Defender")){
          expectName = false;
        }
      }
    }
    // De-duplicate while preserving order
    const seen = new Set();
    out.attackers = names.filter(n=>{
      const key = n.toLowerCase();
      if(seen.has(key)) return false;
      seen.add(key);
      return true;
    });

    // Validate
    if(out.df_m>0 || out.df_c>0) out.notes.push(`DF letti: M=${fmt(out.df_m)} C=${fmt(out.df_c)}`);
    if(out.attackers.length>0) out.notes.push(`Attaccanti letti: ${out.attackers.join(", ")}`);

    out.ok = out.attackers.length>0 && (out.df_m>0 || out.df_c>0);
    if(!out.ok){
      if(out.attackers.length===0) out.notes.push("Attaccanti non trovati nel testo convertito (manca sezione 'Attacker' o formato diverso).");
      if(out.df_m===0 && out.df_c===0) out.notes.push("DF non trovati (manca 'Metal/Crystal to debrisfield').");
    }
    return out;
  }

  
  // ---------- RAW stdClass CR parsing (line-by-line, best-effort) ----------
  function parseStdClassCR(text){
    const lines = (text||"").split(/\r?\n/);
    const out = { ok:false, coords:"", df_m:0, df_c:0, attackers:[], notes:[] };

    // coords
    for(const l of lines){
      const m = l.match(/\[\s*coordinates\s*\]\s*=>\s*([0-9]+:[0-9]+:[0-9]+)/i);
      if(m){ out.coords = m[1]; break; }
    }

    // debris (try multiple key variants seen in ogame dumps)
    const debrisKeys = [
      ["debris_metal", "df_metal", "metal_debris", "metal_to_debrisfield", "metal_to_debris", "metal_in_debris_field"],
      ["debris_crystal", "df_crystal", "crystal_debris", "crystal_to_debrisfield", "crystal_to_debris", "crystal_in_debris_field"],
    ];
    for(const l of lines){
      for(const k of debrisKeys[0]){
        const re = new RegExp("\\\\[\\\\s*"+k+"\\\\s*\\\\]\\\\s*=>\\\\s*([0-9]+)","i");
        const m = l.match(re);
        if(m){ out.df_m = Number(m[1]||0); }
      }
      for(const k of debrisKeys[1]){
        const re = new RegExp("\\\\[\\\\s*"+k+"\\\\s*\\\\]\\\\s*=>\\\\s*([0-9]+)","i");
        const m = l.match(re);
        if(m){ out.df_c = Number(m[1]||0); }
      }
    }

    // players/attackers
    let inPlayers = false;
    let cur = null;
    function commit(){
      if(cur && cur.name){
        if(cur.isAttacker){
          out.attackers.push(cur.name);
        }
      }
      cur = null;
    }

    for(const raw of lines){
      const line = raw.trim();
      if(!inPlayers && line.match(/^\[\s*players\s*\]\s*=>\s*Array/i)){
        inPlayers = true;
        continue;
      }
      if(inPlayers){
        // stop when rounds start
        if(line.match(/^\[\s*rounds\s*\]\s*=>\s*Array/i) || line.match(/^\[\s*generic\s*\]\s*=>/i)){
          commit();
          inPlayers = false;
          continue;
        }
        if(line.startsWith("stdClass Object")){
          commit();
          cur = {name:"", isAttacker:false};
          continue;
        }
        // key/value lines like: [player_name] => Abubu
        const kv = line.match(/^\[\s*([a-zA-Z0-9_]+)\s*\]\s*=>\s*(.*)$/);
        if(kv){
          const key = kv[1].toLowerCase();
          const val = (kv[2]||"").trim();
          if(!cur) cur = {name:"", isAttacker:false};
          if(key==="player_name" || key==="name" || key==="username"){
            cur.name = val.replace(/\s+\(.*\)\s*$/,'').trim();
          }
          if(key==="is_attacker" || key==="isattacker" || key==="attacker"){
            cur.isAttacker = (val==="1" || val.toLowerCase()==="true" || val.toLowerCase()==="yes");
          }
          if(key==="side" || key==="role" || key==="combat_side"){
            if(val.toLowerCase().includes("attacker")) cur.isAttacker = true;
          }
        }
        // some dumps have explicit attacker list
        const am = line.match(/^\[\s*attacker_name\s*\]\s*=>\s*(.*)$/i);
        if(am){
          const nm = am[1].trim();
          if(nm) out.attackers.push(nm);
        }
      }
    }
    commit();

    // uniq attackers
    out.attackers = Array.from(new Set(out.attackers.filter(Boolean)));

    if(out.attackers.length>0) out.notes.push(`Attaccanti RAW letti: ${out.attackers.join(", ")}`);
    if(out.df_m || out.df_c) out.notes.push(`DF RAW: M=${fmt(out.df_m)} C=${fmt(out.df_c)}`);
    out.ok = out.attackers.length>0 && (out.df_m>0 || out.df_c>0);
    if(!out.ok){
      if(out.attackers.length===0) out.notes.push("RAW: attaccanti non trovati nella sezione [players] (formato diverso).");
      if(out.df_m===0 && out.df_c===0) out.notes.push("RAW: DF non trovati (chiavi debris_* non presenti).");
    }
    return out;
  }

// ---------- Fetch helper ----------
  async function fetchNomoreangelHTML(proxyBase, apiid){
    const base = (proxyBase||"").replace(/\/+$/,'');
    const candidates = [
      `${base}/?apiid=${encodeURIComponent(apiid)}&en=1&raw=0`,
      `${base}/?apiid=${encodeURIComponent(apiid)}&english=1&raw=0`,
      `${base}/?apiid=${encodeURIComponent(apiid)}&en=1&raw-output=0`,
      `${base}/?apiid=${encodeURIComponent(apiid)}&english-output=1`,
      `${base}/?apiid=${encodeURIComponent(apiid)}`
    ];

    let last = null;
    for(const url of candidates){
      try{
        const res = await fetch(url, {method:'GET', mode:'cors'});
        const txt = await res.text();
        last = {url, status:res.status, ok:res.ok, html:txt};
        // If looks like converted, return early
        const t = htmlToText(txt);
        let parsed = parseConvertedCR(t);
        if(parsed.ok) return {...last, extracted:t, parsed};
        // fallback: RAW stdClass parsing
        parsed = parseStdClassCR(t);
        if(parsed.ok) return {...last, extracted:t, parsed};
      }catch(e){
        last = {url, status:0, ok:false, html:"", error:String(e)};
      }
    }
    // return last attempt, with extracted text
    if(last && last.html){
      last.extracted = htmlToText(last.html);
      last.parsed = (()=>{ const p1=parseConvertedCR(last.extracted); return p1.ok?p1:parseStdClassCR(last.extracted); })();
    }
    return last;
  }

  // ---------- Render page 2 ----------
  function renderCompiled(state){
    $('outCoords').textContent = state.coords || "—";
    $('outM').textContent = state.df_m ? fmt(state.df_m) : "0";
    $('outC').textContent = state.df_c ? fmt(state.df_c) : "0";

    const atk = state.attackers || [];
    const total = (state.df_m||0) + (state.df_c||0);
    const per = atk.length ? total / atk.length : 0;

    const tb = $('tblAtk');
    tb.innerHTML = "";
    for(const n of atk){
      const tr = document.createElement('tr');
      const td1 = document.createElement('td'); td1.textContent = n;
      const td2 = document.createElement('td'); td2.textContent = atk.length ? fmt(Math.round(per)) : "—";
      tr.appendChild(td1); tr.appendChild(td2);
      tb.appendChild(tr);
    }

    const dbg = [];
    dbg.push(`coords=${state.coords||""}`);
    dbg.push(`df_m=${state.df_m||0} df_c=${state.df_c||0}`);
    dbg.push(`attackers=${atk.length}`);
    if(state.sourceUrl) dbg.push(`source=${state.sourceUrl}`);
    if(state.notes && state.notes.length) dbg.push(`notes: ${state.notes.join(" | ")}`);
    $('debug').textContent = dbg.join("\n");

    setStatus($('status2'), state.ok ? "OK: pagina compilata da CR convertito." : "ATTENZIONE: parsing incompleto. Usa testo convertito/incolla manuale.", state.ok ? "good":"bad");
  }

  // ---------- State ----------
  const STATE_KEY = "sd_acs_state_v15";
  function saveState(s){ sessionStorage.setItem(STATE_KEY, JSON.stringify(s)); }
  function loadState(){ try{ return JSON.parse(sessionStorage.getItem(STATE_KEY)||"null"); }catch(_){return null} }
  function clearState(){ sessionStorage.removeItem(STATE_KEY); }

  // ---------- Actions ----------
  $('btnReset').addEventListener('click', ()=>{
    clearState();
    $('crText').value = "";
    $('crApiId').value = "";
    $('kpiAtk').textContent = "—";
    $('kpiM').textContent = "—";
    $('kpiC').textContent = "—";
    setStatus($('status1'), "Reset completato.", null);
    showPage(1);
  });

  $('btnPasteExample').addEventListener('click', ()=>{
    $('crText').value = `General Information:
Date: 28-01-2026 (DD-MM-YYYY)
Time: 07:04:18 (hh-mm-ss)
Timezone: +01:00
Combat coordinates: 2:96:8
Metal to debrisfield: 8.451.301.052
Crystal to debrisfield: 6.135.502.953

Combat Report:
Initial:
Attacker
[2:96:14] Abubu
Attacker
[2:96:10] Pablito
Attacker
[2:96:7] Germund
Attacker
[2:96:2] LordB
Attacker
[2:96:1] Pippozzy
Defender
[2:96:8] Bartok`;
    setStatus($('status1'), "Esempio incollato. Premi “Vai (da testo incollato)”.", "good");
  });

  function updateKpis(parsed){
    $('kpiAtk').textContent = parsed.attackers?.length ?? "—";
    $('kpiM').textContent = parsed.df_m ? fmt(parsed.df_m) : "0";
    $('kpiC').textContent = parsed.df_c ? fmt(parsed.df_c) : "0";
  }

  $('btnTestCR').addEventListener('click', async ()=>{
    const apiid = $('crApiId').value.trim();
    if(!apiid){
      setStatus($('status1'), "Inserisci un API ID CR (cr-...).", "bad");
      return;
    }
    setStatus($('status1'), "Test in corso…", null);
    const res = await fetchNomoreangelHTML($('proxyBase').value.trim(), apiid);
    if(!res){
      setStatus($('status1'), "Nessuna risposta.", "bad");
      return;
    }
    const msg = [
      `CR TEST status=${res.status} ok=${res.ok} url=${res.url}`,
      res.parsed?.notes?.length ? `notes: ${res.parsed.notes.join(" | ")}` : "",
      res.parsed?.ok ? "✅ Parsing convertito OK." : "⚠️ Parsing convertito NON OK (probabile RAW stdClass o formato diverso).",
      `Lunghezza testo estratto: ${(res.extracted||"").length}`
    ].filter(Boolean).join("\n");
    setStatus($('status1'), msg, res.parsed?.ok ? "good" : "bad");
    updateKpis(res.parsed||{});
  });

  async function goWithParsed(parsed, sourceText, sourceUrl){
    const state = {
      ok: parsed.ok,
      coords: parsed.coords||"",
      df_m: parsed.df_m||0,
      df_c: parsed.df_c||0,
      attackers: parsed.attackers||[],
      notes: parsed.notes||[],
      sourceUrl: sourceUrl||"",
      sourceText: sourceText||""
    };
    saveState(state);
    renderCompiled(state);
    showPage(2);
  }

  $('btnLoadCR').addEventListener('click', async ()=>{
    const apiid = $('crApiId').value.trim();
    if(!apiid){
      setStatus($('status1'), "Inserisci un API ID CR (cr-...).", "bad");
      return;
    }
    setStatus($('status1'), "Caricamento CR via proxy…", null);
    const res = await fetchNomoreangelHTML($('proxyBase').value.trim(), apiid);
    if(!res){
      setStatus($('status1'), "Nessuna risposta.", "bad");
      return;
    }
    updateKpis(res.parsed||{});
    if(!(res.parsed && (res.parsed.ok || (res.parsed.attackers?.length||0)>0 || (res.parsed.df_m||0)>0 || (res.parsed.df_c||0)>0))){
      setStatus($('status1'), `Ho caricato l'HTML ma non riesco a ricavare il CR convertito.\nSoluzione rapida: copia il testo convertito (English Output) e incollalo nel box sotto.\nURL usato: ${res.url}`, "bad");
      return;
    }
    await goWithParsed(res.parsed, res.extracted||"", res.url);
  });

  $('btnGoFromText').addEventListener('click', async ()=>{
    const text = $('crText').value.trim();
    if(!text){
      setStatus($('status1'), "Incolla un testo CR convertito.", "bad");
      return;
    }
    let parsed = parseConvertedCR(text); if(!parsed.ok) parsed = parseStdClassCR(text);
    updateKpis(parsed);
    if(!parsed.ok){
      setStatus($('status1'), `Parsing incompleto.\n${(parsed.notes||[]).join(" | ")}`, "bad");
      return;
    }
    await goWithParsed(parsed, text, "manual-paste");
  });

  $('btnBack').addEventListener('click', ()=> showPage(1));

  $('btnCopySummary').addEventListener('click', ()=>{
    const s = loadState();
    if(!s) return;
    const total = (s.df_m||0)+(s.df_c||0);
    const per = s.attackers?.length ? Math.round(total/s.attackers.length) : 0;
    const txt = [
      `ACS — Spartizione Detriti`,
      `Coords: ${s.coords||"-"}`,
      `DF: M ${fmt(s.df_m)} | C ${fmt(s.df_c)} | Tot ${fmt(total)}`,
      `Attaccanti (${s.attackers.length}): ${s.attackers.join(", ")}`,
      `Quota paritaria (totale): ${fmt(per)} ciascuno (valore totale, non split M/C)`
    ].join("\n");
    navigator.clipboard.writeText(txt);
    setStatus($('status2'), "Riepilogo copiato negli appunti.", "good");
  });

  // Modal show text
  function openModal(title, text){
    $('modalTitle').textContent = title;
    $('modalText').value = text || "";
    $('modal').style.display = "grid";
  }
  function closeModal(){ $('modal').style.display = "none"; }
  $('btnModalClose').addEventListener('click', closeModal);
  $('modal').addEventListener('click', (e)=>{ if(e.target.id==='modal') closeModal(); });
  $('btnModalCopy').addEventListener('click', ()=> navigator.clipboard.writeText($('modalText').value||""));

  $('btnShowText').addEventListener('click', ()=>{
    const s = loadState();
    openModal("Testo CR usato", s?.sourceText || "");
  });

  // Auto restore
  const saved = loadState();
  if(saved){
    renderCompiled(saved);
    showPage(2);
  }
})();
</script>
</body>
</html>
